This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-08-29T15:33:44.580Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>
<user_provided_header>
Packed CS710S Android codebase for AI analysis of BLE/RFID flows, including C# source, projects, and docs.
</user_provided_header>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
CS710S-C-Sharp-APP-for-ANDROID.sln
Library/CSLibrary/CSLibrary2024-NET4.csproj
Library/CSLibrary/CSLibrary2024-NET8-MAUI.csproj
Library/CSLibrary/CSLibrary2024-NETStandard.csproj
Library/CSLibrary/Source/BarcodeReader/ClassBarCode.cs
Library/CSLibrary/Source/BarcodeReader/Events/CSLibrary.Barcode.EventArgs.cs
Library/CSLibrary/Source/BarcodeReader/Structures/CSLibrary.Barcode.Structures.cs
Library/CSLibrary/Source/Battery/ClassBattery.cs
Library/CSLibrary/Source/BluetoothIC/ClassBluetoothIC.cs
Library/CSLibrary/Source/BluetoothProtocol/BTConnect.cs
Library/CSLibrary/Source/BluetoothProtocol/BTReceive.cs
Library/CSLibrary/Source/BluetoothProtocol/BTSend.cs
Library/CSLibrary/Source/BluetoothProtocol/ClassBleDebug.cs
Library/CSLibrary/Source/BluetoothProtocol/CSLibrary.Private.cs
Library/CSLibrary/Source/CSLibrary.cs
Library/CSLibrary/Source/HAL/MvvmCross.Plugin.BLE/ClassDebug.cs
Library/CSLibrary/Source/HAL/MvvmCross.Plugin.BLE/ClassDeviceFinder.cs
Library/CSLibrary/Source/HAL/MvvmCross.Plugin.BLE/CodeFileBLE.cs
Library/CSLibrary/Source/HAL/Plugin.BLE/ClassDebug.cs
Library/CSLibrary/Source/HAL/Plugin.BLE/ClassDeviceFinder.cs
Library/CSLibrary/Source/HAL/Plugin.BLE/CodeFileBLE.cs
Library/CSLibrary/Source/HAL/Plugin.BLE/MvvmCross.Plugin.BLE/ClassDebug.cs
Library/CSLibrary/Source/HAL/Plugin.BLE/MvvmCross.Plugin.BLE/ClassDeviceFinder.cs
Library/CSLibrary/Source/HAL/Plugin.BLE/MvvmCross.Plugin.BLE/CodeFileBLE.cs
Library/CSLibrary/Source/Notification/ClassNotification.cs
Library/CSLibrary/Source/RFIDReader/Comm_Protocol/Ex10Commands/ClassRFID.AdministrationCommands.cs
Library/CSLibrary/Source/RFIDReader/Comm_Protocol/Ex10Commands/ClassRFID.OperationCommands.cs
Library/CSLibrary/Source/RFIDReader/Comm_Protocol/Ex10Commands/ClassRFID.ReadRegister.cs
Library/CSLibrary/Source/RFIDReader/Comm_Protocol/Ex10Commands/ClassRFID.Registers.cs
Library/CSLibrary/Source/RFIDReader/Comm_Protocol/Ex10Commands/ClassRFID.UplinkPackets.cs
Library/CSLibrary/Source/RFIDReader/Comm_Protocol/Ex10Commands/ClassRFID.WriteRegister.cs
Library/CSLibrary/Source/RFIDReader/Comm_Protocol/RX000Commands/ClassRFID.Private.ByPassRegister.cs
Library/CSLibrary/Source/RFIDReader/Comm_Protocol/RX000Commands/ClassRFID.Private.MacRegister.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Private.Country.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Private.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Private.FrequencyChannel.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Private.Inventory.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Private.Read.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Private.Select.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Private.Write.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.Algorithm.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.Antenna.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.Country.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.FrequencyChannel.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.InventoryOptions.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.Operation.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.Power.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.Profile.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.QTCommandParms.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.RSSIFilter.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.SetLNA.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Puiblic.EngineeringAPI.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.UCODE8.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.UnifiedAPI.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Private.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Private.FrequencyChannel.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Private.Inventory.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Private.OEM.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Private.PowerManager.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Private.Read.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Private.Select.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Private.Write.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.Algorithm.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.Antenna.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.Country.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.FrequencyChannel.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.Operation.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.Power.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.Profile.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.RSSIFilter.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.SetLNA.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/Antenna/Antenna.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/Antenna/AntennaConfig.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/Antenna/AntennaList.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/Antenna/AntennaStatus.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Private.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Private.Read.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Private.Select.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Private.Write.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Public.Algorithm.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Public.Antenna.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Public.Country.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Public.FrequencyChannel.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Public.Operation.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Public.Power.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Public.Profile.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Public.RSSIFilter.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.UnifiedAPI.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Constants/AntennaPort.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Constants/AntennaSequenceMode.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Constants/CSLibrary.Constants.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Constants/FreqAgile.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Constants/SelectFlags.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Events/CSLibrary.Events.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Structures/AntennaPortCollections.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Structures/CSLibrary.Structures.TagKill.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Structures/CSLibrary.Structures.TagLock.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Structures/CSLibrary.Structures.TagRead.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Structures/CSLibrary.Structures.TagWrite.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/TAG_ASYN/ClassRFID.ASYN.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/TAG_EM4325/ClassRFID.EM4325.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/TAG_FM13DT160/ClassRFID.FM13DT160.cs
Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/TAG_FM13DT160/ClassRFID.Private.FM13DT160.cs
Library/CSLibrary/Source/SiliconLabIC/ClassEvent.cs
Library/CSLibrary/Source/SiliconLabIC/ClassSiliconLabIC.cs
Library/CSLibrary/Source/SystemInformation/ClassCountryInformation.cs
Library/CSLibrary/Source/SystemInformation/ClassDeviceInformation.cs
Library/CSLibrary/Source/SystemInformation/ClassFrequencyBandInformation.cs
Library/CSLibrary/Source/SystemInformation/CS710SErrorCode.cs
Library/CSLibrary/Source/Tools/ClassCRC16.cs
Library/CSLibrary/Source/Tools/ClassdBm2dBuV.cs
Library/CSLibrary/Source/Tools/ClassFIFIQueue.cs
Library/CSLibrary/Source/Tools/ClassTimer.cs
Library/CSLibrary/Source/Tools/HexEncoding.cs
MobileMvxApp/BLE.Client.Droid/BLE.Client.Droid.csproj
MobileMvxApp/BLE.Client.Droid/Bootstrap/BlePluginBootstrap.cs
MobileMvxApp/BLE.Client.Droid/ClassIAppVersion.cs
MobileMvxApp/BLE.Client.Droid/ClassIBatteryOptimizationService.cs
MobileMvxApp/BLE.Client.Droid/ClassIExternalStorage.cs
MobileMvxApp/BLE.Client.Droid/ClassSystemSound.cs
MobileMvxApp/BLE.Client.Droid/DebugTrace.cs
MobileMvxApp/BLE.Client.Droid/LinkerPleaseInclude.cs
MobileMvxApp/BLE.Client.Droid/MainActivity.cs
MobileMvxApp/BLE.Client.Droid/MainApplication.cs
MobileMvxApp/BLE.Client.Droid/Properties/AndroidManifest.xml
MobileMvxApp/BLE.Client.Droid/Properties/AssemblyInfo.cs
MobileMvxApp/BLE.Client.Droid/Resources/layout/SplashScreen.axml
MobileMvxApp/BLE.Client.Droid/Resources/layout/tabs.axml
MobileMvxApp/BLE.Client.Droid/Resources/layout/toolbar.axml
MobileMvxApp/BLE.Client.Droid/Resources/values/colors.xml
MobileMvxApp/BLE.Client.Droid/Resources/values/SplashStyle.xml
MobileMvxApp/BLE.Client.Droid/Resources/values/style.xml
MobileMvxApp/BLE.Client.Droid/Setup.cs
MobileMvxApp/BLE.Client.Droid/SplashScreen.cs
MobileMvxApp/BLE.Client/BLE.Client.csproj
MobileMvxApp/BLE.Client/BleMvxApplication.cs
MobileMvxApp/BLE.Client/BleMvxFormsApp.xaml.cs
MobileMvxApp/BLE.Client/ClassBattery.cs
MobileMvxApp/BLE.Client/Converters/InverseBooleanValueConverter.cs
MobileMvxApp/BLE.Client/Extensions/IUserDialogsExtensions.cs
MobileMvxApp/BLE.Client/Helpers/Settings.cs
MobileMvxApp/BLE.Client/InterfaceIAppVersion.cs
MobileMvxApp/BLE.Client/InterfaceIBatteryOptimizationService.cs
MobileMvxApp/BLE.Client/InterIExternalStorage.cs
MobileMvxApp/BLE.Client/InterISystemSound.cs
MobileMvxApp/BLE.Client/Pages/DeviceListPage.xaml.cs
MobileMvxApp/BLE.Client/Pages/PageViewPage.xaml.cs
MobileMvxApp/BLE.Client/PagesViewModelsSet/GeigerSearch/PageGeiger.xaml.cs
MobileMvxApp/BLE.Client/PagesViewModelsSet/GeigerSearch/ViewModelGeiger.cs
MobileMvxApp/BLE.Client/PagesViewModelsSet/Inventory/PageBarcodeScan.xaml.cs
MobileMvxApp/BLE.Client/PagesViewModelsSet/Inventory/PageInventory.xaml.cs
MobileMvxApp/BLE.Client/PagesViewModelsSet/Inventory/PageInventorynScan.xaml.cs
MobileMvxApp/BLE.Client/PagesViewModelsSet/Inventory/ViewModelInventorynScan.cs
MobileMvxApp/BLE.Client/PagesViewModelsSet/PageMainMenu.xaml.cs
MobileMvxApp/BLE.Client/PagesViewModelsSet/Settings/PageAbout.xaml.cs
MobileMvxApp/BLE.Client/PagesViewModelsSet/Settings/PageSetting.xaml.cs
MobileMvxApp/BLE.Client/PagesViewModelsSet/Settings/PageSettingAdministration.xaml.cs
MobileMvxApp/BLE.Client/PagesViewModelsSet/Settings/PageSettingAntenna.xaml.cs
MobileMvxApp/BLE.Client/PagesViewModelsSet/Settings/PageSettingOperation.xaml.cs
MobileMvxApp/BLE.Client/PagesViewModelsSet/Settings/PageSettingPowerSequencing.xaml.cs
MobileMvxApp/BLE.Client/PagesViewModelsSet/Settings/ViewModelSetting.cs
MobileMvxApp/BLE.Client/PagesViewModelsSet/ViewModelMainMenu.cs
MobileMvxApp/BLE.Client/ViewModels/BaseViewModel.cs
MobileMvxApp/BLE.Client/ViewModels/DeviceListItemViewModel.cs
MobileMvxApp/BLE.Client/ViewModels/DeviceListViewModel.cs
MobileMvxApp/BLE.Client/ViewModels/ViewModelViewPage.cs
README.md
repomix-instruction.md
repomix.config.json
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="CS710S-C-Sharp-APP-for-ANDROID.sln">
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36414.22
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "CSLibrary2024-NETStandard", "Library\CSLibrary\CSLibrary2024-NETStandard.csproj", "{37821040-260A-C116-1C05-A4BAAB5AB070}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BLE.Client.Droid", "MobileMvxApp\BLE.Client.Droid\BLE.Client.Droid.csproj", "{7B0E4EFD-EEB8-4CE9-9C8D-7A4BF734E9A7}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BLE.Client", "MobileMvxApp\BLE.Client\BLE.Client.csproj", "{B896F061-18D5-53A0-7545-BBF57B0953F7}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{37821040-260A-C116-1C05-A4BAAB5AB070}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{37821040-260A-C116-1C05-A4BAAB5AB070}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{37821040-260A-C116-1C05-A4BAAB5AB070}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{37821040-260A-C116-1C05-A4BAAB5AB070}.Release|Any CPU.Build.0 = Release|Any CPU
		{7B0E4EFD-EEB8-4CE9-9C8D-7A4BF734E9A7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7B0E4EFD-EEB8-4CE9-9C8D-7A4BF734E9A7}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7B0E4EFD-EEB8-4CE9-9C8D-7A4BF734E9A7}.Debug|Any CPU.Deploy.0 = Debug|Any CPU
		{7B0E4EFD-EEB8-4CE9-9C8D-7A4BF734E9A7}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7B0E4EFD-EEB8-4CE9-9C8D-7A4BF734E9A7}.Release|Any CPU.Build.0 = Release|Any CPU
		{7B0E4EFD-EEB8-4CE9-9C8D-7A4BF734E9A7}.Release|Any CPU.Deploy.0 = Release|Any CPU
		{B896F061-18D5-53A0-7545-BBF57B0953F7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B896F061-18D5-53A0-7545-BBF57B0953F7}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B896F061-18D5-53A0-7545-BBF57B0953F7}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B896F061-18D5-53A0-7545-BBF57B0953F7}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {9066E0E0-C3FB-42C6-A1AE-49474AA161F0}
	EndGlobalSection
EndGlobal
</file>

<file path="Library/CSLibrary/CSLibrary2024-NET4.csproj">
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{B84B1CFC-D8C3-420C-9526-E604D2710959}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>CSLibrary</RootNamespace>
    <AssemblyName>CSLibrary2024.NET4</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
    <Reference Include="wclBluetoothFramework">
      <HintPath>Source\HAL\btframework\wclBluetoothFramework.dll</HintPath>
    </Reference>
    <Reference Include="wclCommon">
      <HintPath>Source\HAL\btframework\wclCommon.dll</HintPath>
    </Reference>
    <Reference Include="wclCommunication">
      <HintPath>Source\HAL\btframework\wclCommunication.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Source\BarcodeReader\ClassBarCode.cs" />
    <Compile Include="Source\BarcodeReader\Constants\CSLibrary.Barcode.Constants.cs" />
    <Compile Include="Source\BarcodeReader\Events\CSLibrary.Barcode.EventArgs.cs" />
    <Compile Include="Source\BarcodeReader\Structures\CSLibrary.Barcode.Structures.cs" />
    <Compile Include="Source\Battery\ClassBattery.cs" />
    <Compile Include="Source\BluetoothIC\ClassBluetoothIC.cs" />
    <Compile Include="Source\BluetoothProtocol\BTConnect.cs" />
    <Compile Include="Source\BluetoothProtocol\BTReceive.cs" />
    <Compile Include="Source\BluetoothProtocol\BTSend.cs" />
    <Compile Include="Source\BluetoothProtocol\ClassBleDebug.cs" />
    <Compile Include="Source\BluetoothProtocol\CSLibrary.Private.cs" />
    <Compile Include="Source\CSLibrary.cs" />
    <Compile Include="Source\HAL\btframework\ClassDebug.cs" />
    <Compile Include="Source\HAL\btframework\ClassDeviceFinder.cs" />
    <Compile Include="Source\HAL\btframework\CodeFileBLE.cs" />
    <Compile Include="Source\Notification\ClassNotification.cs" />
    <Compile Include="Source\RFIDReader\Comm_Protocol\Ex10Commands\ClassRFID.AdministrationCommands.cs" />
    <Compile Include="Source\RFIDReader\Comm_Protocol\Ex10Commands\ClassRFID.OperationCommands.cs" />
    <Compile Include="Source\RFIDReader\Comm_Protocol\Ex10Commands\ClassRFID.ReadRegister.cs" />
    <Compile Include="Source\RFIDReader\Comm_Protocol\Ex10Commands\ClassRFID.Registers.cs" />
    <Compile Include="Source\RFIDReader\Comm_Protocol\Ex10Commands\ClassRFID.UplinkPackets.cs" />
    <Compile Include="Source\RFIDReader\Comm_Protocol\Ex10Commands\ClassRFID.WriteRegister.cs" />
    <Compile Include="Source\RFIDReader\Comm_Protocol\RX000Commands\ClassRFID.Private.ByPassRegister.cs" />
    <Compile Include="Source\RFIDReader\Comm_Protocol\RX000Commands\ClassRFID.Private.MacRegister.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Private.Country.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Private.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Private.FrequencyChannel.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Private.Inventory.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Private.Read.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Private.Select.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Private.Write.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Public.Algorithm.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Public.Antenna.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Public.Country.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Public.FrequencyChannel.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Public.InventoryOptions.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Public.Operation.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Public.Power.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Public.Profile.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Public.QTCommandParms.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Public.RSSIFilter.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Public.SetLNA.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.Puiblic.EngineeringAPI.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.UCODE8.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\ClassRFID.UnifiedAPI.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.Private.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.Private.FrequencyChannel.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.Private.Inventory.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.Private.OEM.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.Private.PowerManager.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.Private.Read.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.Private.Select.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.Private.Write.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.Public.Algorithm.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.Public.Antenna.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.Public.Country.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.Public.FrequencyChannel.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.Public.Operation.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.Public.Power.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.Public.Profile.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.Public.RSSIFilter.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS108\ClassRFID.Public.SetLNA.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\Antenna\Antenna.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\Antenna\AntennaConfig.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\Antenna\AntennaList.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\Antenna\AntennaStatus.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\ClassRFID.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\ClassRFID.Private.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\ClassRFID.Private.Read.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\ClassRFID.Private.Select.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\ClassRFID.Private.Write.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\ClassRFID.Public.Algorithm.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\ClassRFID.Public.Antenna.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\ClassRFID.Public.Country.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\ClassRFID.Public.FrequencyChannel.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\ClassRFID.Public.Operation.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\ClassRFID.Public.Power.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\ClassRFID.Public.Profile.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\ClassRFID.Public.RSSIFilter.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_API\CS710S\ClassRFID.UnifiedAPI.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_Constants\AntennaPort.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_Constants\AntennaSequenceMode.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_Constants\CSLibrary.Constants.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_Constants\CSLibrary.Constants.Packet.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_Constants\FreqAgile.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_Constants\Intel.Constants.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_Constants\SelectFlags.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_Events\CSLibrary.Events.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_Structures\AntennaPortCollections.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_Structures\CSLibrary.Structures.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_Structures\CSLibrary.Structures.TagKill.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_Structures\CSLibrary.Structures.TagLock.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_Structures\CSLibrary.Structures.TagRead.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_Structures\CSLibrary.Structures.TagWrite.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\Basic_Structures\Intel.Structures.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\TAG_ASYN\ClassRFID.ASYN.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\TAG_EM4325\ClassRFID.EM4325.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\TAG_FM13DT160\ClassRFID.FM13DT160.cs" />
    <Compile Include="Source\RFIDReader\CSLUnifiedAPI\TAG_FM13DT160\ClassRFID.Private.FM13DT160.cs" />
    <Compile Include="Source\SystemInformation\ClassCountryInformation.cs" />
    <Compile Include="Source\SiliconLabIC\ClassEvent.cs" />
    <Compile Include="Source\SiliconLabIC\ClassSiliconLabIC.cs" />
    <Compile Include="Source\SystemInformation\ClassDeviceInformation.cs" />
    <Compile Include="Source\SystemInformation\ClassFrequencyBandInformation.cs" />
    <Compile Include="Source\Tools\ClassCRC16.cs" />
    <Compile Include="Source\Tools\ClassdBm2dBuV.cs" />
    <Compile Include="Source\Tools\ClassFIFIQueue.cs" />
    <Compile Include="Source\Tools\ClassTimer.cs" />
    <Compile Include="Source\Tools\HexEncoding.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup />
  <ItemGroup>
    <Content Include="Readme.txt" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
</file>

<file path="Library/CSLibrary/CSLibrary2024-NET8-MAUI.csproj">
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <RootNamespace>CSLibrary</RootNamespace>
    <AssemblyName>CSLibrary2024.NET8.MAUI</AssemblyName>
    <Version>3.0.3</Version>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
    <Optimize>true</Optimize>
  </PropertyGroup>
  <ItemGroup>
    <Compile Remove="Source\HAL\Acr.ble\**" />
    <Compile Remove="Source\HAL\btframework\**" />
    <Compile Remove="Source\HAL\MvvmCross.Plugin.BLE\**" />
    <Compile Remove="Source\HAL\UWP\**" />
    <Compile Remove="Source\RFIDReader\Antenna\**" />
    <Compile Remove="Source\RFIDReader\API_EM4325\**" />
    <Compile Remove="Source\RFIDReader\API_FM13DT160\**" />
    <EmbeddedResource Remove="Source\HAL\Acr.ble\**" />
    <EmbeddedResource Remove="Source\HAL\btframework\**" />
    <EmbeddedResource Remove="Source\HAL\MvvmCross.Plugin.BLE\**" />
    <EmbeddedResource Remove="Source\HAL\UWP\**" />
    <EmbeddedResource Remove="Source\RFIDReader\Antenna\**" />
    <EmbeddedResource Remove="Source\RFIDReader\API_EM4325\**" />
    <EmbeddedResource Remove="Source\RFIDReader\API_FM13DT160\**" />
    <None Remove="Source\HAL\Acr.ble\**" />
    <None Remove="Source\HAL\btframework\**" />
    <None Remove="Source\HAL\MvvmCross.Plugin.BLE\**" />
    <None Remove="Source\HAL\UWP\**" />
    <None Remove="Source\RFIDReader\Antenna\**" />
    <None Remove="Source\RFIDReader\API_EM4325\**" />
    <None Remove="Source\RFIDReader\API_FM13DT160\**" />
  </ItemGroup>
  <ItemGroup>
    <Compile Remove="CSLibrary.cs" />
    <Compile Remove="Properties\AssemblyInfo.cs" />
    <Compile Remove="Properties\Resources.Designer.cs" />
    <Compile Remove="Source\SystemInformation\ClassdBm2dBV.cs" />
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Remove="Properties\Resources.resx" />
  </ItemGroup>
  <ItemGroup>
    <None Remove=".DS_Store" />
    <None Remove="CSLibrary-UWP.projitems" />
  </ItemGroup>
  <ItemGroup>
    <Folder Include="Properties\" />
    <Folder Include="Source\RFIDReader\Comm_Protocol\" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="Plugin.BLE" Version="3.0.0" />
  </ItemGroup>
</Project>
</file>

<file path="Library/CSLibrary/CSLibrary2024-NETStandard.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
    <RootNamespace>CSLibrary</RootNamespace>
    <AssemblyName>CSLibrary2024.NETSTD2</AssemblyName>
    <Version>3.0.7</Version>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
    <Optimize>true</Optimize>
  </PropertyGroup>

  <ItemGroup>
    <Compile Remove="Source\HAL\Acr.ble\**" />
    <Compile Remove="Source\HAL\btframework\**" />
    <Compile Remove="Source\HAL\Plugin.BLE\**" />
    <Compile Remove="Source\HAL\TCPIP\**" />
    <Compile Remove="Source\HAL\UWP\**" />
    <Compile Remove="Source\RFIDReader\Antenna\**" />
    <Compile Remove="Source\RFIDReader\API_EM4325\**" />
    <Compile Remove="Source\RFIDReader\API_FM13DT160\**" />
    <EmbeddedResource Remove="Source\HAL\Acr.ble\**" />
    <EmbeddedResource Remove="Source\HAL\btframework\**" />
    <EmbeddedResource Remove="Source\HAL\Plugin.BLE\**" />
    <EmbeddedResource Remove="Source\HAL\TCPIP\**" />
    <EmbeddedResource Remove="Source\HAL\UWP\**" />
    <EmbeddedResource Remove="Source\RFIDReader\Antenna\**" />
    <EmbeddedResource Remove="Source\RFIDReader\API_EM4325\**" />
    <EmbeddedResource Remove="Source\RFIDReader\API_FM13DT160\**" />
    <None Remove="Source\HAL\Acr.ble\**" />
    <None Remove="Source\HAL\btframework\**" />
    <None Remove="Source\HAL\Plugin.BLE\**" />
    <None Remove="Source\HAL\TCPIP\**" />
    <None Remove="Source\HAL\UWP\**" />
    <None Remove="Source\RFIDReader\Antenna\**" />
    <None Remove="Source\RFIDReader\API_EM4325\**" />
    <None Remove="Source\RFIDReader\API_FM13DT160\**" />
  </ItemGroup>

  <ItemGroup>
    <Compile Remove="CSLibrary.cs" />
    <Compile Remove="Properties\AssemblyInfo.cs" />
    <Compile Remove="Properties\Resources.Designer.cs" />
    <Compile Remove="Source\SystemInformation\ClassdBm2dBV.cs" />
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Remove="Properties\Resources.resx" />
  </ItemGroup>

  <ItemGroup>
    <None Remove=".DS_Store" />
    <None Remove="CSLibrary-UWP.projitems" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Properties\" />
    <Folder Include="Source\RFIDReader\Comm_Protocol\" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="MvvmCross.Plugin.BLE" Version="2.2.0-pre5" />
  </ItemGroup>
</Project>
</file>

<file path="Library/CSLibrary/Source/BarcodeReader/ClassBarCode.cs">
using System;

using CSLibrary.Barcode;
using CSLibrary.Barcode.Constants;
using CSLibrary.Barcode.Structures;

namespace CSLibrary
{
    public partial class BarcodeReader
    {
        public enum STATE
        {
            UNKNOWN,            // unknown
            READY,              // hardware exists
            NOTVALID,           // hardware fail
            OLDVERSION          // not update 
        }

        public enum VIBRATORMODE
        {
            NORMAL,
            INVENTORYON,
            BAROCDEGOODREAD
        }

        private class DOWNLINKCMD
        {
            public static readonly byte[] BARCODEPOWERON = { 0x90, 0x00 };
            public static readonly byte[] BARCODEPOWEROFF = { 0x90, 0x01 };
            public static readonly byte[] BARCODESCANTRIGGER = { 0x90, 0x02 };
            public static readonly byte[] BARCODERAWDATA = { 0x90, 0x03 };
            public static readonly byte[] VIBRATORON = { 0x90, 0x04 };
            public static readonly byte[] VIBRATOROFF = { 0x90, 0x05 };
            public static readonly byte[] FASTBARCODEMODE = { 0xA0, 0x06 };
        }

        private HighLevelInterface _deviceHandler;

        STATE _state = STATE.NOTVALID;
        public STATE state { get { return _state; } }


        private bool _goodRead = false;
        private bool _perfix = false;
        private string _barcodeStr = "";
        readonly byte[] _barcodePrefix = new byte[] { 0x02, 0x00, 0x07, 0x10, 0x17, 0x13 };
        readonly byte[] _barcodeSuffix = new byte[] { 0x05, 0x01, 0x11, 0x16, 0x03, 0x04 };

        internal BarcodeReader(HighLevelInterface handler)
        {
            _deviceHandler = handler;
        }

        public void ClearEventHandler()
        {
            //OnCapturedNotify = delegate { };
            OnCapturedNotify = null;
        }

        /// <summary>
        /// Receive BarCode packet
        /// </summary>
        /// <param name="recvData"></param>
        /// <param name="offset"></param>
        /// <param name="size"></param>
        internal bool DeviceRecvData(byte[] recvData)
        {
            try
            {
                if (recvData[2] == 3 && recvData[10] == 0x06) // if return success
                    return true;

                if (recvData[2] > 7)
                if (recvData[10] == 0x02 && recvData[11] == 0x00 && recvData[14] == 0x34)
                {
                    // Query
                    if (recvData.Length < 24 || recvData[15] != 0x01 || recvData[16] != 0x06 || recvData[23] != 0x01 || recvData[24] != 0x06)
                        FactoryReset();
                    else
                    {
                        FactoryReset_Second();
                        _state = STATE.READY;
                    }
                    return true;
                }

                _barcodeStr += System.Text.Encoding.UTF8.GetString(recvData, 10, recvData[2] - 2);

                if (_barcodeStr.Length >= 12)
                {
                    int prefixat;
                    int suffixat;

                    do
                    {
                        prefixat = _barcodeStr.IndexOf("\u0002\u0000\u0007\u0010\u0017\u0013", StringComparison.Ordinal);
                        suffixat = _barcodeStr.IndexOf("\u0005\u0001\u0011\u0016\u0003\u0004", StringComparison.Ordinal);

                        if (prefixat == -1 && suffixat == -1)
                        {
                            // no prefix and no suffix
                            if (_barcodeStr.Length > 5)
                                _barcodeStr = _barcodeStr.Substring(_barcodeStr.Length - 5, 5);
                        }
                        else if (prefixat != -1 && suffixat == -1)
                        {
                            CSLibrary.Debug.WriteLine("barcode not complete, wait again!!!");
                            // have prefix and no suffix
                        }
                        else if (prefixat == -1 && suffixat != -1)
                        {
                            // have prefix and no suffix
                            _barcodeStr = _barcodeStr.Substring(suffixat + 6, _barcodeStr.Length - (suffixat + 6));
                        }
                        else if (prefixat != -1 && suffixat != -1)
                        {
                            if (prefixat < suffixat)
                            {
                                // have prefix and no suffix
                                if (OnCapturedNotify != null)
                                {
                                    Barcode.Structures.DecodeMessage decodeInfo = new Barcode.Structures.DecodeMessage();       // Decode message structure.

                                    decodeInfo.pchMessage = _barcodeStr.Substring(prefixat + 10, suffixat - prefixat - 10);

                                    try
                                    {
                                        FireCaptureCompletedEvent(new BarcodeEventArgs(MessageType.DEC_MSG, decodeInfo));
                                    }
                                    catch (Exception ex)
                                    {
                                        Debug.WriteLine("Barcode event (UI) error : " + ex.Message);
                                    }
                                }
                            }

                            _barcodeStr = _barcodeStr.Substring(suffixat + 6, _barcodeStr.Length - (suffixat + 6));
                        }
                    } while (prefixat != -1 && suffixat != -1);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Barcode decode error : " + ex.Message);
            }

            return true;
        }

        internal bool DeviceRecvGoodRead()
        {
            _goodRead = true;
            return true;
        }

        string GetAimID(string code)
        {
            string desc = "";
            string CodeID = code.Substring(0, 1);
            string AimID = code.Substring(1, 3);

            switch (CodeID)
            {
                case "j":
                    switch (AimID)
                    {
                        case "]C0":
                            break;
                    }
                    break;

                case "f":
                    break;

                case "d":
                    break;

                case "c":
                    break;

                case "e":
                    break;

                case "v":
                    break;

                case "b":
                    break;

                case "a":
                    break;

                case "i":
                    break;

                case "H":
                    break;

                case "R":
                    break;

                case "y":
                    break;

                case "B":
                    break;

                case "n":
                    break;

                //case "v":
                //    break;

                case "I":
                    break;

                case "D":
                    break;

                //case "f":
                //    break;

                case "s":
                    break;

                //case "n":
                //    break;

                case "p":
                    break;

                case "m":
                    break;

                case "r":
                    break;

                //case "s":
                //    break;

                case "Q":
                    break;

                case "z":
                    break;

                case "u":
                    break;

                case "x":
                    break;

                case "h":
                    break;
            }

            return desc;
        }



        public event EventHandler<CSLibrary.Barcode.BarcodeEventArgs> OnCapturedNotify;

        private BarcodeState m_state = BarcodeState.IDLE;
        // Helper for marshalling execution to GUI thread
        private object synlock = new object();

        private void TellThemCaptureCompleted(BarcodeEventArgs e)
        {
            if (OnCapturedNotify != null)
            {
                OnCapturedNotify(_deviceHandler, e);
            }
        }

        private void FireCaptureCompletedEvent(BarcodeEventArgs e)
        {
            TellThemCaptureCompleted(e);
        }


        /// <summary>
        /// Start to capture barcode, until stop is sent.
        /// </summary>
        /// <returns></returns>
        public bool Start()
        {
            try
            {
                if (_state == STATE.NOTVALID)
                    return false;

                _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_ContinueMode, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);

                _goodRead = false;
                _barcodeStr = "";
            }
            catch (System.Exception ex)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Stop capturing
        /// </summary>
        /// <returns></returns>
        public bool Stop()
        {
            bool rc = true;

            try
            {
                _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_StopContinue, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
            }
            catch (System.Exception ex)
            {
                rc = false;
            }
            return rc;
        }

        public bool VibratorOn()
        {
            //if (_state != STATE.READY)
            //    return false;

            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.VIBRATORON, null, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
            return true;
        }

        public bool VibratorOn(VIBRATORMODE mode, uint time)
        {
            //if (_state != STATE.READY)
            //    return false;

            byte[] payload = new byte[3];

            payload[0] = (byte)mode;
            payload[1] = (byte)(time >> 8);
            payload[2] = (byte)(time);

            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.VIBRATORON, payload, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
            return true;
        }

        public bool VibratorOff()
        {
            //if (_state != STATE.READY)
            //    return false;

            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.VIBRATOROFF, null, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.VIBRATOROFF, null, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
            return true;
        }

        public bool FastBarcodeMode (bool enable)
        {
            byte[] payload = new byte[1];

            if (enable)
                payload[0] = 0x01;
            else
                payload[0] = 0x00;

            _deviceHandler.SendAsync(0, 2, DOWNLINKCMD.FASTBARCODEMODE, payload, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
            return true;
        }

        readonly byte[] barcodecmd_TriggerMode = new byte[] { 0x1b, 0x31 };     // Start Trigger Mode
        readonly byte[] barcodecmd_ContinueMode = new byte[] { 0x1b, 0x33 };    // Start Continue Scan Mode
        readonly byte[] barcodecmd_StopContinue = new byte[] { 0x1b, 0x30 };    // Stop Continue Scan Mode
        readonly byte[] barcodecmd_SysModeEnter = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x30, 0x30, 0x36, 0x30, 0x31, 0x30, 0x3b };  // Enter Engineer Mode
        readonly byte[] barcodecmd_PermContinueMode = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x30, 0x32, 0x30, 0x32, 0x30, 0x3b };  
        readonly byte[] barcodecmd_PermTriggerMode = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x30, 0x32, 0x30, 0x30, 0x30, 0x3b };
        readonly byte[] barcodecmd_ScanCycleTime30000 = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x31, 0x33, 0x30, 0x30, 0x30, 0x3d, 0x33, 0x30, 0x30, 0x30, 0x30, 0x3b };
        readonly byte[] barcodecmd_SysModeExit = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x30, 0x30, 0x36, 0x30, 0x30, 0x30, 0x3b };   // Exit Engineer Mode
        readonly byte[] barcodecmd_QueryESN = new byte[] { 0x7e, 0x00, 0x00, 0x05, 0x33, 0x48, 0x30, 0x32, 0x30, 0xB3 };
        readonly byte[] barcodecmd_QueryPrefix = new byte[] { 0x7e, 0x00, 0x00, 0x02, 0x33, 0x37, 0xf9 };    // Query Prefix and Suffix

        readonly byte[] barcodecmd_EnableAllPrefixSuffix    = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x31, 0x31, 0x30, 0x31, 0x30, 0x3b };
        readonly byte[] barcodecmd_SelfPrefixCodeIdAimId    = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x31, 0x37, 0x30, 0x34, 0x30, 0x3b };
        readonly byte[] barcodecmd_EnableSelfPrefix         = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x30, 0x35, 0x30, 0x31, 0x30, 0x3b };
        readonly byte[] barcodecmd_DisableSelfPrefix = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x30, 0x35, 0x30, 0x30, 0x30, 0x3b };
        readonly byte[] barcodecmd_SetSelfPrefix            = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x3d, 0x20, 0x30, 0x78, 0x30, 0x32, 0x30, 0x30, 0x30, 0x37, 0x31, 0x30, 0x31, 0x37, 0x31, 0x33, 0x3b };
        //readonly byte[] barcodecmd_SetSelfPrefix = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x30, 0x30, 0x30, 0x30, 0x30, 0x20, 0x3d, 0x20, 0x30, 0x78, 0x30, 0x32, 0x3b };
        readonly byte[] barcodecmd_EnableSelfSuffix         = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x30, 0x36, 0x30, 0x31, 0x30, 0x3b };
        readonly byte[] barcodecmd_DisableSelfSuffix = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x30, 0x36, 0x30, 0x30, 0x30, 0x3b };
        readonly byte[] barcodecmd_SetSelfSuffix            = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x30, 0x31, 0x30, 0x30, 0x30, 0x20, 0x3d, 0x20, 0x30, 0x78, 0x30, 0x35, 0x30, 0x31, 0x31, 0x31, 0x31, 0x36, 0x30, 0x33, 0x30, 0x34, 0x3b };
        //readonly byte[] barcodecmd_SetSelfSuffix = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x30, 0x31, 0x30, 0x30, 0x30, 0x20, 0x3d, 0x20, 0x30, 0x78, 0x30, 0x35, 0x3b };
        readonly byte[] barcodecmd_EnableAimId              = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x30, 0x38, 0x30, 0x33, 0x30, 0x3b };
        readonly byte[] barcodecmd_EnableCodeId             = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x30, 0x37, 0x30, 0x31, 0x30, 0x3b };

        readonly byte[] barcodecmd_SetContinueMode = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x30, 0x32, 0x30, 0x32, 0x30, 0x3b };
        readonly byte[] barcodecmd_Timeout = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x31, 0x33, 0x30, 0x30, 0x30, 0x3b };
        readonly byte[] barcodecmd_Duplicate = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x31, 0x33, 0x30, 0x31, 0x30, 0x3b };
        readonly byte[] barcodecmd_TimeoutBetweenDecode = new byte[] { 0x6e, 0x6c, 0x73, 0x30, 0x33, 0x31, 0x33, 0x30, 0x34, 0x30, 0x3b };

        readonly byte[] barcodecmd_QueryReadingMode = new byte[] { 0x7E, 0x00, 0x00, 0x05, 0x33, 0x44, 0x30, 0x30, 0x30, 0xBD };

        readonly byte[] barcodecmd_TiggerModeStep01 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x30, 0x30, 0x36, 0x30, 0x31, 0x30, 0x3B };
        readonly byte[] barcodecmd_TiggerModeStep02 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x33, 0x30, 0x32, 0x30, 0x30, 0x30, 0x3B };
        readonly byte[] barcodecmd_TiggerModeStep03 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x33, 0x31, 0x33, 0x30, 0x30, 0x30, 0x3D, 0x33, 0x30, 0x30, 0x30, 0x3B, 0x6E, 0x6C, 0x73, 0x30, 0x33, 0x31, 0x33, 0x30, 0x31, 0x30, 0x3D, 0x31, 0x30, 0x30, 0x30, 0x3B, 0x6E, 0x6C, 0x73, 0x30, 0x33, 0x31, 0x33, 0x30, 0x34, 0x30, 0x3D, 0x31, 0x30, 0x30, 0x30, 0x3B, 0x6E, 0x6C, 0x73, 0x30, 0x33, 0x30, 0x32, 0x30, 0x30, 0x30, 0x3B, 0x6E, 0x6C, 0x73, 0x30, 0x30, 0x30, 0x37, 0x30, 0x31, 0x30, 0x3B };
        readonly byte[] barcodecmd_TiggerModeStep04 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x30, 0x30, 0x31, 0x31, 0x35, 0x30, 0x3B, 0x6E, 0x6C, 0x73, 0x30, 0x30, 0x30, 0x36, 0x30, 0x30, 0x30, 0x3B };

        readonly byte[] barcodecmd_V4Format2Step01 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x30, 0x30, 0x36, 0x30, 0x31, 0x30, 0x3B };
        readonly byte[] barcodecmd_V4Format2Step02 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x33, 0x31, 0x31, 0x30, 0x31, 0x30, 0x3B };
        readonly byte[] barcodecmd_V4Format2Step03 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x33, 0x31, 0x37, 0x30, 0x34, 0x30, 0x3B };
        readonly byte[] barcodecmd_V4Format2Step04 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x33, 0x30, 0x35, 0x30, 0x31, 0x30, 0x3B };
        readonly byte[] barcodecmd_V4Format2Step05 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x33, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3D, 0x30, 0x78, 0x30, 0x32, 0x30, 0x30, 0x30, 0x37, 0x31, 0x30, 0x31, 0x37, 0x31, 0x33, 0x3B };
        readonly byte[] barcodecmd_V4Format2Step06 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x33, 0x30, 0x36, 0x30, 0x31, 0x30, 0x3B };
        readonly byte[] barcodecmd_V4Format2Step07 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x33, 0x30, 0x31, 0x30, 0x30, 0x30, 0x3D, 0x30, 0x78, 0x30, 0x35, 0x30, 0x31, 0x31, 0x31, 0x31, 0x36, 0x30, 0x33, 0x30, 0x34, 0x3B };
        readonly byte[] barcodecmd_V4Format2Step08 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x33, 0x30, 0x38, 0x30, 0x33, 0x30, 0x3B };
        readonly byte[] barcodecmd_V4Format2Step09 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x33, 0x30, 0x37, 0x30, 0x31, 0x30, 0x3B };
        readonly byte[] barcodecmd_V4Format2Step10 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x33, 0x30, 0x39, 0x30, 0x31, 0x30, 0x3B, 0x6E, 0x6C, 0x73, 0x30, 0x33, 0x31, 0x30, 0x30, 0x31, 0x30, 0x3B };
        readonly byte[] barcodecmd_V4Format2Step11 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x35, 0x30, 0x32, 0x31, 0x31, 0x30 };
        readonly byte[] barcodecmd_V4Format2Step12 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x30, 0x30, 0x31, 0x31, 0x35, 0x30, 0x3B, 0x6E, 0x6C, 0x73, 0x30, 0x30, 0x30, 0x36, 0x30, 0x30, 0x30, 0x3B };

        readonly byte[] barcodecmd_T14FormatStep01 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x30, 0x30, 0x36, 0x30, 0x31, 0x30, 0x3B };
        readonly byte[] barcodecmd_T14FormatStep02 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x34, 0x30, 0x35, 0x31, 0x30, 0x30, 0x3B };
        readonly byte[] barcodecmd_T14FormatStep03 = new byte[] { 0x6E, 0x6C, 0x73, 0x30, 0x30, 0x30, 0x36, 0x30, 0x30, 0x30, 0x3B };

        internal void CheckHWValid()
        {
            //var a = GetLRC(new byte[] { 0x48, 0x30, 0x32, 0x30 });
            //var b = GetLRC(new byte[] { 0x37 });

            _state = STATE.NOTVALID;
            //_deviceHandler.SendAsync(CSLibrary.HighLevelInterface.DEVICEID.Barcode, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_QueryESN, CSLibrary.HighLevelInterface.BTCOMMANDTYPE.Validate, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1);
            _deviceHandler.SendAsync(CSLibrary.HighLevelInterface.DEVICEID.Barcode, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_QueryPrefix, CSLibrary.HighLevelInterface.BTCOMMANDTYPE.Validate, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1);
        }

        // public barcode function
        public void FactoryReset()
        {
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_TiggerModeStep01, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_TiggerModeStep02, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_TiggerModeStep03, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_TiggerModeStep04, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);

            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_V4Format2Step01, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_V4Format2Step02, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_V4Format2Step03, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_V4Format2Step04, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_V4Format2Step05, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_V4Format2Step06, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_V4Format2Step07, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_V4Format2Step08, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_V4Format2Step09, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_V4Format2Step10, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_V4Format2Step11, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_V4Format2Step12, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);

#if V3Reader
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_SysModeEnter, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_ScanCycleTime30000, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_PermTriggerMode, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_EnableAllPrefixSuffix, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_SelfPrefixCodeIdAimId, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_EnableSelfPrefix, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_SetSelfPrefix, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_EnableSelfSuffix, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_SetSelfSuffix, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_EnableAimId, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_EnableCodeId, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            //_deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_SetContinueMode, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            //_deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_Timeout, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            //_deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_Duplicate, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            //_deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_TimeoutBetweenDecode, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_SysModeExit, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
#endif

            CheckHWValid();

            //_deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_QueryReadingMode, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
        }

        internal void FactoryReset_Second()
        {
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_T14FormatStep01, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_T14FormatStep02, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
            _deviceHandler.SendAsync(0, 1, DOWNLINKCMD.BARCODERAWDATA, barcodecmd_T14FormatStep03, CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
        }

        // LRC : Data checkout value 1 bytes(Computing method: 0xff^lens^types^data
        Byte GetLRC (Byte [] data)
        {
            int lrc = 0xff ^ (data.Length + 1) ^ 0x33;

            for (int cnt = 0; cnt < data.Length; cnt++)
                lrc ^= data[cnt];

            return (Byte)lrc;
        }

    }
}
</file>

<file path="Library/CSLibrary/Source/BarcodeReader/Events/CSLibrary.Barcode.EventArgs.cs">
using System;
using System.Collections.Generic;
using System.Text;

using CSLibrary.Barcode.Structures;
using CSLibrary.Barcode.Constants;

namespace CSLibrary.Barcode
{
    /// <summary>
    /// Barcode Event Argument
    /// </summary>
    public class BarcodeEventArgs : EventArgs
    {
        private MessageBase m_msg = null;
        private MessageType m_type = MessageType.ERR_MSG;
        private string m_error = String.Empty;

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="type"></param>
        /// <param name="msg"></param>
        public BarcodeEventArgs(MessageType type, MessageBase msg)
        {
            m_type = type;
            m_msg = msg;
        }
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="type"></param>
        /// <param name="error"></param>
        public BarcodeEventArgs(MessageType type, string error)
        {
            m_type = type;
            m_error = error;
        }

        /// <summary>
        /// Decoded Barcode Message
        /// </summary>
        public MessageBase Message
        {
            get
            {
                return m_msg;
            }

        }
        /// <summary>
        /// Capture result
        /// </summary>
        public MessageType MessageType
        {
            get { return m_type; }
        }
        /// <summary>
        /// Error message
        /// </summary>
        public string ErrorMessage
        {
            get { return m_error; }
        }
    }
    /// <summary>
    /// 
    /// </summary>
    public class BarcodeStateEventArgs : EventArgs
    {
        private BarcodeState m_state = BarcodeState.IDLE;

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="state"></param>
        public BarcodeStateEventArgs(BarcodeState state)
        {
            m_state = state;
        }
        /// <summary>
        /// Current operation state
        /// </summary>
        public BarcodeState State
        {
            get { return m_state; }
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/BarcodeReader/Structures/CSLibrary.Barcode.Structures.cs">
using System;
using System.Collections.Generic;
using System.Text;

using CSLibrary.Barcode.Constants;

namespace CSLibrary.Barcode.Structures
{
    using OCR_T         =  SymCodeOCR;
    using AZTEC_T       =  SymFlagsRange;
    using CODABAR_T     =  SymFlagsRange;
    using CODE11_T      =  SymFlagsRange;
    using CODE128_T     =  SymFlagsRange;
    using CODE39_T      =  SymFlagsRange;
    using CODE49_T      =  SymFlagsRange;
    using CODE93_T      =  SymFlagsRange;
    using COMPOSITE_T   =  SymFlagsRange;
    using DATAMATRIX_T  =  SymFlagsRange;
    using INT25_T       =  SymFlagsRange;
    using MAXICODE_T    =  SymFlagsRange;
    using MICROPDF_T    =  SymFlagsRange;
    using PDF417_T      =  SymFlagsRange;
    using QR_T          =  SymFlagsRange;
    using RSS_T         =  SymFlagsRange;
    using IATA25_T      =  SymFlagsRange;
    using CODABLOCK_T   =  SymFlagsRange;
    using MSI_T        =   SymFlagsRange;
    using MATRIX25_T   =   SymFlagsRange;
    using KORPOST_T    =   SymFlagsRange;
    using CODE25_T     =   SymFlagsRange;
    using PLESSEY_T    =   SymFlagsRange;
    using CHINAPOST_T  =   SymFlagsRange;
    using TELEPEN_T    =   SymFlagsRange;
    using CODE16K_T   =    SymFlagsRange;
    using POSICODE_T  =    SymFlagsRange;
    using MESA_T        =  SymFlagsOnly;
    using EAN8_T        =  SymFlagsOnly;
    using EAN13_T       =  SymFlagsOnly;
    using POSTNET_T     =  SymFlagsOnly;
    using UPCA_T        =  SymFlagsOnly;
    using UPCE_T        =  SymFlagsOnly;
    using ISBT_T        =  SymFlagsOnly;
    using BPO_T         =  SymFlagsOnly;
    using CANPOST_T     =  SymFlagsOnly;
    using AUSPOST_T     =  SymFlagsOnly;
    using JAPOST_T      =  SymFlagsOnly;
    using PLANET_T      =  SymFlagsOnly;
    using DUTCHPOST_T   =  SymFlagsOnly;
    using TLCODE39_T   =   SymFlagsOnly;
    using TRIOPTIC_T   =   SymFlagsOnly;
    using CODE32_T     =   SymFlagsOnly;
    using COUPONCODE_T =    SymFlagsOnly;
    using UPUIDTAG_T   =   SymFlagsOnly;
    using CODE4CB_T     =  SymFlagsOnly;

    /// <summary>
    /// Image Size
    /// </summary>
    public struct SIZE
    {
        /// <summary>
        /// width
        /// </summary>
        public int width;
        /// <summary>
        /// height
        /// </summary>
        public int height;
    }

    /// <summary>
    /// Image Size
    /// </summary>
    public struct RECT
    {
        /// <summary>
        /// left position
        /// </summary>
        public Int32 left;
        /// <summary>
        /// top position
        /// </summary>
        public Int32 top;
        /// <summary>
        /// right position
        /// </summary>
        public Int32 right;
        /// <summary>
        /// bottom position
        /// </summary>
        public Int32 bottom;
    }

    #region Message
    ///<summary>
    /// Image information structure
    ///</summary>
    public class ImageMessage : MessageBase
    {
        /// <summary>
        /// Pointer Buffer for image
        /// </summary>
        public IntPtr puchBuffer;
        /// <summary>
        /// Size of buffer in bytes
        /// </summary>
        public Int32 nBufferSize;
        /// <summary>
        /// Image Format for returned data
        /// </summary>
        public ImgFormat imageFormat;
        /// <summary>
        /// JPEG Quality Factor, default 80%
        /// </summary>
        public uint dwJpegQFactor = 80;
        /// <summary>
        /// Number of bytes returned.
        /// </summary>
        public Int32 nBytesReturned;
        /// <summary>
        /// Size of image returned.
        /// </summary>
        public SIZE imgSize;
        /// <summary>
        /// Number of frames captured prior to this image
        /// </summary>
        public Int32 nCapturedFrames;
        /// <summary>
        /// Gain value used to capture this image
        /// </summary>
        public Int32 nGain;
        /// <summary>
        /// Exposure time used to capture this image
        /// </summary>
        public Int32 nExposureTime;
        /// <summary>
        /// Number of underexposed pixels in image
        /// </summary>
        public Int32 nUnderexposedPixels;
        /// <summary>
        /// Number of overexposed pixels in image
        /// </summary>
        public Int32 nOverexposedPixels;
        /// <summary>
        /// Constructor
        /// </summary>
        public ImageMessage()
        {
//            base.length = 52;
        }

    }
    /// <summary>
    /// error message structure
    /// </summary>
    public class ErrorMessage : MessageBase
    {
        /// <summary>
        /// decoded message data
        /// </summary>
        public String message;
        /// <summary>
        /// AIM Id of symbology
        /// </summary>
        public Result result;
    }
    /// <summary>
    /// decode structure
    /// </summary>
    public class DecodeMessage : MessageBase
    {
        /// <summary>
        /// decoded message data
        /// </summary>
        public String pchMessage;
        /// <summary>
        /// AIM Id of symbology
        /// </summary>
        //public AimID chCodeID;
        /// <summary>
        /// HHP Id of symbology
        /// </summary>
        //public SymID chSymLetter;
        /// <summary>
        /// Modifier characters.
        /// </summary>
        public Char chSymModifier;
        /// <summary>
        /// length of the decoded message
        /// </summary>
        public UInt32 nLength;
        /// <summary>
        /// Constructor
        /// </summary>
        public DecodeMessage()
        {
//            base.length = 8208;
        }
    }
    /// <summary>
    /// Raw decode structure
    /// </summary>
    public class RawDecodeMessage : MessageBase
    {
        /// <summary>
        /// decoded message data
        /// </summary>
        public byte[] pchMessage;
        /*/// <summary>
        /// AIM Id of symbology
        /// </summary>
        public byte chCodeID;
        /// <summary>
        /// Id of symbology
        /// </summary>
        public byte chSymLetter;
        /// <summary>
        /// Modifier characters.
        /// </summary>
        public byte chSymModifier;
        /// <summary>
        /// length of the decoded message
        /// </summary>
        public uint nLength;
        /// <summary>
        /// Constructor
        /// </summary>
        public RawDecodeMessage()
        {
            base.length = 4108;
        }*/
    }
    /// <summary>
    /// Barcode Message base class
    /// </summary>
    public class MessageBase
    {
        /// <summary>
        /// Constructor
        /// </summary>
        public MessageBase()
        {
            // NOP - length_ MUST be set by child classes
        }
        /*
        /// <summary>
        /// Structure size
        /// </summary>
        public UInt32 length
        {
            get { return this.m_length; }
            set { this.m_length = value; }
        }
        */
    }

    /// <summary>
    /// Text message type
    /// </summary>
    public class TextMessage
    {
        /// <summary>
        /// Structure size
        /// </summary>
        protected UInt32 dwStructSize = 8200;
        /// <summary>
        /// Text message with 4096 maximum length
        /// </summary>
        public UInt16[] tcTextMsg = new UInt16[Constants.Constants.MAX_MESAGE_LENGTH];
        /// <summary>
        /// Message length
        /// </summary>
        public UInt32 nLength;
    }

#endregion

    /// <summary>
    /// Intelligent Image Capture
    /// </summary>
    public class IntelligentImage
    {
        /// <summary>
        /// Structure size
        /// </summary>
        protected UInt32 dwStructSize = 36;
        /// <summary>
        /// ratio of barcode height to narrow element width
        /// </summary>
        public UInt32 dwAspectRatio;  
        /// <summary>
        /// offset in X direction, relative to barcode center
        /// </summary>
        public Int64 nOffsetX;       
        /// <summary>
        /// offset in Y direction
        /// </summary>
        public Int64 nOffsetY;       
        /// <summary>
        /// width of image in IntellBarcodeUnits
        /// </summary>
        public UInt32 dwWidth;       
        /// <summary>
        /// height of image
        /// </summary>
        public UInt32 dwHeight;       
        /// <summary>
        /// Maximum width and height for intell image
        /// </summary>
        public SIZE maxImgSize;     
        /// <summary>
        /// Have reader binarize data before transfer.
        /// </summary>
        public bool bSendBinary;     

    }

    #region Config Structs

    ///<summary>
    /// Image Acquisition structure
    ///</summary>
    public class ImageAcquisitionParms : ConfigBase
    {
        /// <summary>
        /// Mask of active items. Notes: You can use OR to enable multiple items
        /// </summary>
        public ImgAcquisitionMask dwMask = ImgAcquisitionMask.CAPTURE_MASK_ALL;
        /// <summary>
        /// Target "white pixel" value.
        /// </summary>
        public uint dwWhiteValue;
        /// <summary>
        /// Acceptable delta from white value.
        /// </summary>
        public uint dwWhiteWindow;
        /// <summary>
        /// Max frame capture tries for white value.
        /// </summary>
        public uint dwMaxNumExposures;
        /// <summary>
        /// Illumination duty cycle (never on, on during imaging).
        /// </summary>
        public DutyCycle illuminatCycle;
        /// <summary>
        /// Aimer duty cycle (never on, on during imaging).
        /// </summary>
        public DutyCycle aimerCycle;
        /// <summary>
        /// If manual capture mode, gain value for capture.
        /// </summary>
        public Gain fixedGain;
        /// <summary>
        /// If manual capture mode, exposure time for capture.(1-7874)
        /// </summary>
        public uint dwFixedExposure;
        /// <summary>
        /// If manual capture mode, frame rate for capture.
        /// </summary>
        public FrameRate frameRate;
        /// <summary>
        /// Autoexposure (AGC) Capture mode: barcode, photo or manual.
        /// </summary>
        public AutoExposure captureMode;
        /// <summary>
        /// 640x480 Max Image Size.
        /// </summary>
        public bool bVgaCompatibleImage; 
        /// <summary>
        /// Wait for hardware or software trigger before capturing image.
        /// </summary>
        public bool bWaitForTrigger;
        /// <summary>
        /// Capture a preview image. These are subsample 3, full window, JPEG transfer images.
        /// </summary>
        public bool bPreviewImage;
        /// <summary>
        /// Constructor
        /// </summary>
        public ImageAcquisitionParms()
        {
            base.m_length = 56;
        }
    }

    ///<summary>
    /// Image Transfer structure
    ///</summary>
    public class ImageTransferParms : ConfigBase
    {
        /// <summary>
        /// Mask of active items. Notes: You can use OR to enable multiple items
        /// </summary>
        public ImgTransferMask dwMask = ImgTransferMask.TRANSFER_MASK_ALL;
        /// <summary>
        /// Bits per pixel for transferred image (1 or 8 bits only).
        /// </summary>
        public uint dwBitsPerPixel;
        /// <summary>
        /// Subsample value. This means take every dwSubSample pixels 
        /// of every dwSubSample row.  The default is 1.(1-10)
        /// </summary>
        public uint dwSubSample;
        /// <summary>
        /// Rectangle describing a window within the image. 
        /// All pixels outside this rectangle are omitted from the transferred image. 
        /// </summary>
        public RECT boundingRect;
        /// <summary>
        /// Scaled frequency of total image pixels.
        /// </summary>
        public bool bHistogramStretch;
        /// <summary>
        /// How image is compressed on transfer.  Compression reduces 
        /// the amount of data to transfer but can reduce image quality 
        /// (Lossy compression) and does take a finite length of time.
        /// </summary>
        public Compression compressionMode;
        /// <summary>
        /// Lossy compression is JPEG lossy.  If lossy compression, this 
        /// value specifies the image quality percentage from 100 (virtually 
        /// no loss) to 1 (very poor).  Image size drops with decrease in 
        /// image quality.
        /// </summary>
        public uint dwCompressionFactor;
        /// <summary>
        /// A sharpening filter used to sharpen light/dark edges within the 
        /// image.  The valid range of values is 0 (no edge enhancement) 
        /// to 23 (maximum edge enhancement).
        /// </summary>
        public uint dwEdgeEhancement;
        /// <summary>
        /// Applies gamma correction to the image. The valid range is 0 (no 
        /// gamma correction) to 1000 (maximum correction).
        /// </summary>
        public uint dwGammaCorrection;
        /// <summary>
        /// This filter is an edge sharpening filter optimized for text. The 
        /// valid range is 0 (no text enhancement) to 255 (maximum 
        /// enhancement).
        /// </summary>
        public uint dwTextEnhancement;
        /// <summary>
        /// This is a boolean flag (TRUE or FALSE) that applies a filter to 
        /// the image that sharpens objects beyond the normal focal dis-
        /// tance of the imager.
        /// </summary>
        public bool bInfinityFilter;
        /// <summary>
        /// This is a boolean flag (TRUE or FALSE) that flips the image 180 
        /// </summary>
        public bool bFlipImage;
        /// <summary>
        /// This is a boolean flag (TRUE or FALSE) that enables or dis-
        /// ables the imager smoothing filter.
        /// </summary>
        public bool bNoiseFilter;
        /// <summary>
        /// The user-defined window message. 
        /// WM_ID.WM_SDK_PROGRESS_HWND_MSG (wParam is bytes so far, 
        /// lParam is bytes to send) will be sent if this member mask speci-
        /// fied and its value is a valid windows handle.
        /// </summary>
        public IntPtr hTransferNotifyHwnd;
        /// <summary>
        /// If non-NULL and specified in MASK, the percent complete of 
        /// the transfer is placed here.  It is up to the caller to check the 
        /// value in a thread or timer callback.
        /// </summary>
        public IntPtr pdwTransferPercent;
        /// <summary>
        /// Constructor
        /// </summary>
        public ImageTransferParms()
        {
            base.m_length = 76;
        }
    }

    ///<summary>
    /// Beeper structure
    ///</summary>
    // Beeper structure
    public class BeeperParms : ConfigBase
    {
        /// <summary>
        /// Mask of active items. Notes: You can use OR to enable multiple items
        /// </summary>
        public BeeperMask dwMask = BeeperMask.ALL;
        /// <summary>
        /// Sound beeper on successful decode.
        /// </summary>
        public bool bBeepOnDecode;
        /// <summary>
        /// Sound beeper whenever imager resets.
        /// </summary>
        public bool bShortBeep;
        /// <summary>
        /// Sound beeper whenever a menu command is received.
        /// </summary>
        public bool bMenuCmdBeep;
        /// <summary>
        /// Set the beeper volume.
        /// </summary>
        public BeeperVolume beepVolume;
        /// <summary>
        /// Constructor
        /// </summary>
        public BeeperParms()
        {
            base.m_length = 24;
        }
    }

    /// <summary>
    /// Triggering control
    /// </summary>
    public class TriggerParms : ConfigBase
    {
        /// <summary>
        /// Mask of active items. Notes: You can use OR to enable multiple items
        /// </summary>
        public TriggerMask dwMask = TriggerMask.ALL;
        /// <summary>
        /// Trigger Mode
        /// </summary>
        public TriggerMode TriggerMode;
        /// <summary>
        /// 0->300000 (milliseconds)
        /// </summary>
        public uint dwTriggerTimeout;
        /// <summary>
        /// Constructor
        /// </summary>
        public TriggerParms()
        {
            base.m_length = 16;
        }
    }

    /// <summary>
    ///  Sequence mode barcode descriptor
    /// </summary>
    public class SequenceBarcodeParms
    {
        /// <summary>
        /// Symbology Identifier SYM_xxxx
        /// </summary>
        //public Symbol nSymId;
        /// <summary>
        ///  Match length or 9999 to match any length.
        /// </summary>
        public Int32 nLength;
        /// <summary>
        /// Match string (from start)
        /// </summary>
        public String tcStartChars;

    }
    /// <summary>
    /// Sequence Mode control
    /// </summary>
    public class SequenceModeParms : ConfigBase
    {
        /// <summary>
        /// Mask of active items. Notes: You can use OR to enable multiple items
        /// </summary>
        public SequenceMask dwMask = SequenceMask.ALL;
        /// <summary>
        /// Disabled/Enabled/Enabled and Required.
        /// </summary>
        public SequenceMode sequenceMode;
        /// <summary>
        /// This MUST be sent if sending seqBarCodes.
        /// </summary>
        public uint dwNumBarCodes;
        /// <summary>
        /// Barcodes to sequence in order they are to be sent
        /// </summary>
        public SequenceBarcodeParms[] seqBarCodes = new SequenceBarcodeParms[Constants.Constants.MAX_SEQ_BARCODES];
        /// <summary>
        /// Constructor
        /// </summary>
        public SequenceModeParms()
        {
            base.m_length = 928;
        }

    }

    /// <summary>
    /// Decoder functionality settings.
    /// </summary>
    public class DecoderParms : ConfigBase
    {
        /// <summary>
        /// Mask of active items. Notes: You can use OR to enable multiple items
        /// </summary>
        public DecoderMask dwMask = DecoderMask.ALL;
        /// <summary>
        /// Maximum length for any returned barcode string.  This is a read only value.
        /// </summary>
        public uint dwMaxMsgSize;
        /// <summary>
        /// Decode and send all symbols decoded with first frame where at least 1 symbol is found.
        /// </summary>
        public bool bDecodeMultiple;
        /// <summary>
        /// Turn on aimers during barcode capture.
        /// </summary>
        public bool bUseAimers;
        /// <summary>
        /// How dark the barcode elements are relative to the background (1-7).
        /// </summary>
        public uint dwPrintWeight;
        /// <summary>
        /// Normal decoder, linear codes only, fast normal decoder, which 
        /// omits checking at the image margins as well as some bad bar-
        /// code correction.
        /// </summary>
        public DecoderMode decodeMethod;
        /// <summary>
        /// Does symbol have to intersect center decode window to be valid.
        /// </summary>
        public bool bCenterDecodeEnable;
        /// <summary>
        /// Bounding coords or window that decoded symbol must intersect
        /// </summary>
        public RECT centerWindow;
        /// <summary>
        /// Illumination LED color to use.
        /// </summary>
        public IllumLedColor illumLedColor;
        /// <summary>
        /// 10->500  Delay before reading UPC if expecting addenda.
        /// </summary>
        public uint dwUpcAddendaDelay;
        /// <summary>
        /// 10->1000 Delay before reading code if expecting composite.
        /// </summary>
        public uint dwCompositeDelay;
        /// <summary>
        /// 10->1000 Delay to wait before reading code if expecting concatenated code.
        /// </summary>
        public uint dwConcatenateDelay;
        /// <summary>
        /// Constructor
        /// </summary>
        public DecoderParms()
        {
            base.m_length = 64;
        }

    }

    /// <summary>
    /// Matrix Products Power management structure
    /// </summary>
    public class PowerParms : ConfigBase
    {
        /// <summary>
        /// Mask of active items. Notes: You can use OR to enable multiple items
        /// </summary>
        public PowerMask dwMask = PowerMask.ALL;
        /// <summary>
        /// Trigger mode (same as per trigger struct)
        /// </summary>
        public TriggerMode TriggerMode;           
        /// <summary>
        /// 0 -> 300000 (milliseconds)
        /// </summary>
        public uint dwTriggerTimeout;       
        /// <summary>
        /// 0 -> 300    (seconds)
        /// </summary>
        public uint dwLowPowerTimeout;     
        /// <summary>
        /// 0 -> 100%
        /// </summary>
        public uint dwLEDIntensityPercent; 
        /// <summary>
        /// Clock speed for reset of system (except RS232)
        /// </summary>
        public SystemSpeed systemClockSpeed;       
        /// <summary>
        /// Aimer Mode
        /// </summary>
        public AimerModes AimerMode;              
        /// <summary>
        /// 0 -> 240000 (milliseconds)
        /// </summary>
        public uint dwAimerDuration;        
        /// <summary>
        ///  0 -> 4000   (milliseconds)
        /// </summary>
        public uint dwAimerDelay;          
        /// <summary>
        /// 0 -> 30000  (milliseconds)
        /// </summary>
        public uint dwAutoAimerTimeout;     
        /// <summary>
        /// 0 -> 999999 (milliseconds)
        /// </summary>
        public uint dwImagerIdleTimeout;    
        /// <summary>
        /// 0 -> 300    (seconds)RS232 inactivity timeout used to enter sleep mode.
        /// </summary>
        public uint dwRS232LowPwrTimeout;   
        /// <summary>
        /// These are used to notify on suspend (WinCE Suspend)
        /// </summary>
        public IntPtr hPowerOffHandle;
        /// <summary>
        /// 
        /// </summary>
        public IntPtr hPowerOffHwnd;
        /// <summary>
        /// Constructor
        /// </summary>
        public PowerParms()
        {
            base.m_length = 60;
        }
    }

    /// <summary>
    /// Revision information
    /// </summary>
    public class VersionParms : ConfigBase
    {
        /// <summary>
        /// Mask of active items. Notes: You can use OR to enable multiple items
        /// </summary>
        public VersionMask dwMask = VersionMask.ALL;
        /// <summary>
        /// SDK API version string
        /// </summary>
        public String tcAPIRev;
        /// <summary>
        /// Imager firmware version
        /// </summary>
        public String tcFirmwareRev;      
        /// <summary>
        /// Engine PartNumber.
        /// </summary>
        public String tcFirmwarePartNumber;
        /// <summary>
        /// Imager boot code version.
        /// </summary>
        public String tcBootCodeRev;
        /// <summary>
        /// Imager device string.
        /// </summary>
        public String tcDeviceType;
        /// <summary>
        /// Engine Report string.
        /// </summary>
        public String tcManufacturersId;
        /// <summary>
        /// Decoder Revision
        /// </summary>
        public String tcDecoderRev;
        /// <summary>
        /// Scan Driver Revision
        /// </summary>
        public String tcScanDriverRev;
        /// <summary>
        /// Constructor
        /// </summary>
        public VersionParms()
        {
            base.m_length = 1704;
        }

    }
    /// <summary>
    /// Engine Information Structure (5000K engine with PSOC only)
    /// </summary>
    public class EngineInfoParms
    {
        /// <summary>
        /// Structure size
        /// </summary>
        protected uint dwStructSize = 224;                                   // Structure size
        /// <summary>
        /// 4 digit ASCII Hex.
        /// </summary>
        public UInt16[] tcEngId = new UInt16[Constants.Constants.ENGINE_ID_DIGITS];                    
        /// <summary>
        /// ASCII Decimal
        /// </summary>
        public UInt16[] tcHHPSerialNumber = new UInt16[Constants.Constants.MAX_SERIAL_NUMBER_LEN];     
        /// <summary>
        /// ASCII Decimal
        /// </summary>
        public UInt16[] tcCustomSerialNumber = new UInt16[Constants.Constants.MAX_SERIAL_NUMBER_LEN];  
        /// <summary>
        /// Aimer X
        /// </summary>
        public long nAimerX;                                        
        /// <summary>
        /// Aimer Y
        /// </summary>
        public long nAimerY;                                        
        /// <summary>
        /// Laser power in mW
        /// </summary>
        public long nLaserPower;                                    
        /// <summary>
        /// Firmware Checksum (ASCII Decimal)
        /// </summary>
        public UInt16[] tcFirmwareChecksum = new UInt16[Constants.Constants.MAX_CHECKSUM_LEN];         
        /// <summary>
        /// Firmware Revision Number
        /// </summary>
        public UInt16[] tcFirmwareRev = new UInt16[Constants.Constants.MAX_SHORT_VERSION_LEN];      
        /// <summary>
        /// How LEDs are controled.
        /// </summary>
        public long nLedCtrlMode;                                   
        /// <summary>
        /// LED color (Red or Green LEDs)
        /// </summary>
        public long nLedClr;                                        
        /// <summary>
        /// PWM base frequence.
        /// </summary>
        public long nPwmFreq;                                      
        /// <summary>
        /// Red LED current (mA).
        /// </summary>
        public long nRedLedCurrent;                                 
        /// <summary>
        /// Red LED max current (mA).
        /// </summary>
        public long nRedLedMaxCurrent;                              
        /// <summary>
        /// Green LED current (mA).
        /// </summary>
        public long nGreenLedCurrent;                              
        /// <summary>
        ///  Green LED max current (mA).
        /// </summary>
        public long nGreenLedMaxCurrent;                            
        /// <summary>
        /// Aimer current (mA).
        /// </summary>
        public long nAimerCurrent;                                  
        /// <summary>
        /// Aimer max current (mA).
        /// </summary>
        public long nAimerMaxCurrent;                               
        /// <summary>
        /// Pixel clock frequency (MHz)
        /// </summary>
        public long nPixelClockFreq;                               
        /// <summary>
        /// Register Checksum.
        /// </summary>
        public UInt16[] tcRegisterChecksum = new UInt16[Constants.Constants.MAX_CHECKSUM_LEN];      

    }

    ///<summary>
    /// Big mother of them all configuration structure.
    ///</summary>
    public class AllConfigParms : ConfigBase
    {
        /// <summary>
        /// Beeper config
        /// </summary>
        public BeeperParms beeperCfg = new BeeperParms();
        /// <summary>
        /// Trigger config
        /// </summary>
        public TriggerParms triggerCfg = new TriggerParms();
        /// <summary>
        /// Decoder config
        /// </summary>
        public DecoderParms decoderCfg = new DecoderParms();
        /// <summary>
        /// Power setting config
        /// </summary>
        public PowerParms powerCfg = new PowerParms();
        /// <summary>
        /// Version information
        /// </summary>
        public VersionParms versionInfo = new VersionParms();
        /// <summary>
        /// Symbology
        /// </summary>
        public SymbologyParms symbolCfg = new SymbologyParms();
        /// <summary>
        /// Image acquisition config
        /// </summary>
        public ImageAcquisitionParms imgAcqu = new ImageAcquisitionParms();
        /// <summary>
        /// Image Transfer config
        /// </summary>
        public ImageTransferParms imgTrans = new ImageTransferParms();
        /// <summary>
        /// Sequence mode config
        /// </summary>
        public SequenceModeParms sequenceCfg = new SequenceModeParms();
#if ADD_PREFIX_SUFFIX_DATA_FORMATTER
        public CFG_DATA_EDITING      dataEditCfg;
#endif
        /// <summary>
        /// 
        /// </summary>
        public AllConfigParms()
        {
            base.m_length = 5364;
        }

    }
    /// <summary>
    /// Configuration base class
    /// </summary>
    public class ConfigBase
    {
        /// <summary>
        /// Structure size
        /// </summary>
        protected Int32 m_length = 4;
        /// <summary>
        /// 
        /// </summary>
        public ConfigBase()
        {
            // NOP - length_ MUST be set by child classes
        }
        /// <summary>
        /// Structure size
        /// </summary>
        public Int32 length
        {
            get { return this.m_length; }
            protected set { m_length = value; }
        }
    }


    #endregion

    #region Symbo
    /// <summary>
    /// Structure for symbologies with no specified min or max length.
    /// </summary>
    public class SymFlagsOnly : ConfigBase
    {
        /// <summary>
        /// Mask of active items. Notes: You can use OR to enable multiple items
        /// </summary>
        public SymbolMask dwMask = SymbolMask.ALL;
        /// <summary>
        /// OR of valid flags for the given symbology.
        /// </summary>
        public SymbolFlags dwFlags;
        /// <summary>
        /// Constructor
        /// </summary>
        public SymFlagsOnly()
        {
            base.m_length = 12;
        }
    }
    /// <summary>
    /// Structure for symbologies with min or max length.
    /// </summary>
    public class SymFlagsRange : ConfigBase
    {
        /// <summary>
        /// Mask of active items. Notes: You can use OR to enable multiple items
        /// </summary>
        public SymbolMask dwMask = SymbolMask.ALL;
        /// <summary>
        /// OR of valid flags for the given symbology.
        /// </summary>
        public SymbolFlags dwFlags;
        /// <summary>
        /// Minimum length for valid barcode string for this symbology.
        /// </summary>
        public uint dwMinLen;
        /// <summary>
        /// Maximum length for valid barcode string for this symbology.
        /// </summary>
        public uint dwMaxLen;
        /// <summary>
        /// Constructor
        /// </summary>
        public SymFlagsRange()
        {
            base.m_length = 20;
        }
    }
    /// <summary>
    /// Structure for unusual OCR
    /// </summary>
    public class SymCodeOCR : ConfigBase
    {
        /// <summary>
        /// Mask of active items. Notes: You can use OR to enable multiple items
        /// </summary>
        public SymbolMask dwMask = SymbolMask.ALL;
        /// <summary>
        /// OCR Enable/Mode structure.
        /// </summary>
        public OCR ocrMode;
        /// <summary>
        /// OCR direction structure.
        /// </summary>
        public OCRDirection ocrDirection;
        /// <summary>
        /// Template for decoded data ('d' - decimal, 'a' - ASCII, 'l' - letter, 'e' - extended).
        /// Maximum len is 256
        /// </summary>
        public String tcTemplate;
        /// <summary>
        /// Group G character string.
        /// Maximum len is 256
        /// </summary>
        public String tcGroupG;
        /// <summary>
        /// Group H character string.
        /// Maximum len is 256
        /// </summary>
        public String tcGroupH;
        /// <summary>
        ///  Check character string.
        /// Maximum len is 64
        /// </summary>
        public String tcCheckChar;
        /// <summary>
        /// Constructor
        /// </summary>
        public SymCodeOCR()
        {
            base.m_length = 1680;
        }
    }

    ///<summary>
    /// Structure of structures, one for each symbology.
    ///</summary>
    public class SymbologyParms : ConfigBase
    {
        // Linear Codes                 // Flags supported for this code
        //---------------------------------------------------------------
        /// <summary>
        /// CODABAR Configuration
        /// </summary>
        public CODABAR_T codabar = new CODABAR_T();        // Enable,Check,CheckSend,StartStop,Concatenate
        /// <summary>
        /// CODE11 Configuration
        /// </summary>
        public CODE11_T code11 = new CODE11_T();         // Enable,Check,CheckSend
        /// <summary>
        /// CODE11 Configuration
        /// </summary>
        /// <summary>
        /// CODE128 Configuration
        /// </summary>
        public CODE128_T code128 = new CODE128_T();        // Enable
        /// <summary>
        /// CODE39 Configuration
        /// </summary>
        public CODE39_T code39 = new CODE39_T();         // Enable,Check,CheckSend,StartStop,Append,FullAscii
        /// <summary>
        /// CODE49 Configuration
        /// </summary>
        public CODE49_T code49 = new CODE49_T();         // Enable
        /// <summary>
        /// CODE93 Configuration
        /// </summary>
        public CODE93_T code93 = new CODE93_T();         // Enable
        /// <summary>
        /// COMPOSITE Configuration
        /// </summary>
        public COMPOSITE_T composite = new COMPOSITE_T();      // Enable,CompositeUPC
        /// <summary>
        /// DATAMATRIX Configuration
        /// </summary>
        public DATAMATRIX_T datamatrix = new DATAMATRIX_T();     // Enable
        /// <summary>
        /// EAN8 Configuration
        /// </summary>
        public EAN8_T ean8 = new EAN8_T();           // Enable,Check,Addenda2,Addenda5,AddendaReq,AddendaSep
        /// <summary>
        /// EAN13 Configuration
        /// </summary>
        public EAN13_T ean13 = new EAN13_T();          // Enable,Check,Addenda2,Addenda5,AddendaReq,AddendaSep
        /// <summary>
        /// IATA25 Configuration
        /// </summary>
        public IATA25_T iata25 = new IATA25_T();         // Enable
        /// <summary>
        /// INT25 Configuration
        /// </summary>
        public INT25_T int2of5 = new INT25_T();        // Enable,Check,CheckSend
        /// <summary>
        /// ISBT Configuration
        /// </summary>
        public ISBT_T isbt = new ISBT_T();           // Enable
        /// <summary>
        /// MSI Configuration
        /// </summary>
        public MSI_T msi = new MSI_T();            // Enable,Check
        /// <summary>
        /// UPCA Configuration
        /// </summary>
        public UPCA_T upcA = new UPCA_T();           // Enable,check,NumSysTrans,Addenda2,Addenda5,AddendaReq,AddendaSep
        /// <summary>
        /// UPCE Configuration
        /// </summary>
        public UPCE_T upcE = new UPCE_T();           // Enable,check,NumSysTrans,Addenda2,Addenda5,AddendaReq,AddendaSep,ExpandedE,EnableE1
         // Postal Codes
        /// <summary>
        /// AUSPOST Configuration
        /// </summary>
        public AUSPOST_T australiaPost = new AUSPOST_T();  // Enable,AustralianBar
        /// <summary>
        /// BPO Configuration
        /// </summary>
        public BPO_T britishPost = new BPO_T();    // Enable
        /// <summary>
        /// CANPOST Configuration
        /// </summary>
        public CANPOST_T canadaPost = new CANPOST_T();     // Enable
        /// <summary>
        /// DUTCHPOST Configuration
        /// </summary>
        public DUTCHPOST_T dutchPost = new DUTCHPOST_T();      // Enable
        /// <summary>
        /// JAPOST Configuration
        /// </summary>
        public JAPOST_T japanPost = new JAPOST_T();      // Enable
        /// <summary>
        /// PLANET Configuration
        /// </summary>
        public PLANET_T usPlanet = new PLANET_T();       // Enable,Check
        /// <summary>
        /// POSTNET Configuration
        /// </summary>
        public POSTNET_T usPostnet = new POSTNET_T();      // Enable,Check
        // 2D Codes
        /// <summary>
        /// AZTEC Configuration
        /// </summary>
        public AZTEC_T aztec = new AZTEC_T();          // Enable,AztecRune
        /// <summary>
        /// MESA Configuration
        /// </summary>
        public MESA_T aztecMesa = new MESA_T();      // EnableIMS,Enable1MS,Enable3MS,Enable9MS,EnableUMS,EnableEMS
        /// <summary>
        /// CODABLOCK Configuration
        /// </summary>
        public CODABLOCK_T codablock = new CODABLOCK_T();      // Enable
        /// <summary>
        /// MAXICODE Configuration
        /// </summary>
        public MAXICODE_T maxicode = new MAXICODE_T();       // Enable,SCMOnly
        /// <summary>
        /// MICROPDF Configuration
        /// </summary>
        public MICROPDF_T microPDF = new MICROPDF_T();       // Enable
        /// <summary>
        /// PDF417 Configuration
        /// </summary>
        public PDF417_T pdf417 = new PDF417_T();         // Enable
        /// <summary>
        /// QR Configuration
        /// </summary>
        public QR_T qr = new QR_T();             // Enable
        /// <summary>
        /// RSS Configuration
        /// </summary>
        public RSS_T rss = new RSS_T();            // Enable (RSS,RSL,RSE)
        /// <summary>
        /// TLCODE39 Configuration
        /// </summary>
        public TLCODE39_T tlCode39 = new TLCODE39_T();       // Enable
        // Special OCR "code"
        /// <summary>
        /// OCR Configuration
        /// </summary>
        public OCR_T ocr = new OCR_T();            // None (See SymCodeOCR_t)
        // New codes
        /// <summary>
        /// MATRIX25 Configuration
        /// </summary>
        public MATRIX25_T matrix25 = new MATRIX25_T();       // Enable,
        /// <summary>
        /// KORPOST Configuration
        /// </summary>
        public KORPOST_T koreaPost = new KORPOST_T();      // Enable
        /// <summary>
        /// TRIOPTIC Configuration
        /// </summary>
        public TRIOPTIC_T triopticCode = new TRIOPTIC_T();   // Enable
        /// <summary>
        /// CODE32 Configuration
        /// </summary>
        public CODE32_T code32 = new CODE32_T();         // Enable
        /// <summary>
        /// CODE25 Configuration
        /// </summary>
        public CODE25_T code2of5 = new CODE25_T();       // Enable
        /// <summary>
        /// PLESSEY Configuration
        /// </summary>
        public PLESSEY_T plesseyCode = new PLESSEY_T();    // Enable
        /// <summary>
        /// CHINAPOST Configuration
        /// </summary>
        public CHINAPOST_T chinaPost = new CHINAPOST_T();      // Enable
        /// <summary>
        /// TELEPEN Configuration
        /// </summary>
        public TELEPEN_T telepen = new TELEPEN_T();        // Enable,OldStyle?
        /// <summary>
        /// CODE16K Configuration
        /// </summary>
        public CODE16K_T code16k = new CODE16K_T();        // Enable
        /// <summary>
        /// POSICODE Configuration
        /// </summary>
        public POSICODE_T posiCode = new POSICODE_T();       // Enable,Limited 1 and 2
        /// <summary>
        /// COUPONCODE Configuration
        /// </summary>
        public COUPONCODE_T couponCode = new COUPONCODE_T();     // Enable
        // 5000 engine only codes?
        /// <summary>
        /// UPUIDTAG Configuration
        /// </summary>
        public UPUIDTAG_T upuIdTag = new UPUIDTAG_T();       // Enable
        /// <summary>
        /// CODE4CB Configuration
        /// </summary>
        public CODE4CB_T code4CB = new CODE4CB_T();        // Enable
        /// <summary>
        /// Constructor
        /// </summary>
        public SymbologyParms()
        {
            base.m_length = 2432;
        }
    }
    #endregion

}
</file>

<file path="Library/CSLibrary/Source/Battery/ClassBattery.cs">
using System;
using System.Text;

using CSLibrary.Barcode;
using CSLibrary.Barcode.Constants;
using CSLibrary.Barcode.Structures;

namespace CSLibrary
{
	public partial class Battery
	{
		HighLevelInterface _deviceHandler;
		uint _pollingTime = 300; // 5 second
		bool _autoBatteryLevel = false;
		DateTime _nextTime = DateTime.MaxValue;

		internal Battery(HighLevelInterface handler)
		{
			_deviceHandler = handler;
		}

		public bool GetCurrentAutoBattryStatus ()
		{
			return _autoBatteryLevel;
		}

		public void SetPollingTime (uint sec)
		{
			_pollingTime = sec; 
		}

		internal void EnableAutoBatteryLevel ()
		{
//			_autoBatteryLevel = true;
//			_deviceHandler.notification.SetAutoReport(true);
		}

		internal void DisbleAutoBatteryLevel()
		{
//			_autoBatteryLevel = false;
//			_deviceHandler.notification.SetAutoReport(false);
		}

		internal void GetBatteryLevel()
		{
			_deviceHandler.notification.GetCurrentBatteryVoltage();
		}

		internal void Timer ()
		{
			if (_deviceHandler.Status != CSLibrary.HighLevelInterface.READERSTATE.DISCONNECT && !_autoBatteryLevel && _pollingTime != 0)
			{
				if (DateTime.Now >= _nextTime)
				{
					_nextTime = DateTime.Now.AddSeconds(_pollingTime);
					GetBatteryLevel();
				}
			}
		}

	}
}

/*
using System;
using System.Collections.Generic;
using System.Text;

namespace CSLibrary.Battery
{
	class ClassBattery
	{
	}
}
*/
</file>

<file path="Library/CSLibrary/Source/BluetoothIC/ClassBluetoothIC.cs">
using System;
using System.Text;

using CSLibrary.Barcode;
using CSLibrary.Barcode.Constants;
using CSLibrary.Barcode.Structures;

namespace CSLibrary
{
    public partial class BluetoothIC
    {
        string _deviceName;
        uint _firmwareVersion;

        // RFID event code
        private class DOWNLINKCMD
        {
            public static readonly byte[] GETVERSION = { 0xC0, 0x00 };
            public static readonly byte[] SETDEVICENAME = { 0xC0, 0x03 };
            public static readonly byte[] GETDEVICENAME = { 0xC0, 0x04 };
        }

        private HighLevelInterface _deviceHandler;

        internal BluetoothIC(HighLevelInterface handler)
        {
            _deviceHandler = handler;
        }

        internal bool BluetoothICPacket(byte [] recvData)
        {
            UInt16 eventCode = (UInt16)((UInt16)recvData[8] << 8 | (UInt16)recvData[9]);

            switch (eventCode)
            {
                case 0xc000:
                    if (recvData.Length == 13)
                    {
                        _firmwareVersion = (uint)((recvData[10] << 16) | (recvData[11] << 8) | (recvData[12]));
                        return true;
                    } else if (recvData.Length == 11)
                    {
                        _firmwareVersion = 0;
                        return true;
                    }
                    CSLibrary.Debug.WriteLine("BluetoothIC Get Version error!");
                    break;

                case 0xc001:
                    break;

                case 0xc002:
                    break;

                case 0xc003:
                    if (recvData.Length == 11)
                        if (recvData[10] == 0x00)
                            return true;
                    CSLibrary.Debug.WriteLine("Set Device Name Fail!");
                    break;

                case 0xc004:
                    if (recvData[2] == 0x17)
                        _deviceName = Encoding.UTF8.GetString(recvData, 10, 21).TrimEnd((Char)0);
                    else
                        _deviceName = "";
                    return true;
            }

            return false;
        }

        internal void Connect()
        {
            // Get Firmware Version
            _deviceHandler.SendAsync(0, 4, DOWNLINKCMD.GETVERSION, null, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);

            // Get Device Name
            _deviceName = null;
            _deviceHandler.SendAsync(0, 4, DOWNLINKCMD.GETDEVICENAME, null, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
        }

        public uint GetFirmwareVersion()
        {
            return _firmwareVersion;
        }

        public string GetDeviceName ()
        {
            return _deviceName;
        }

        public bool SetDeviceName (string deviceName)
        {
            if (deviceName.Length > 20)
                return false;

            byte[] bDeviceName = Encoding.UTF8.GetBytes(deviceName + new String('\0', 21 - deviceName.Length));
            _deviceHandler.SendAsync(0, 4, DOWNLINKCMD.SETDEVICENAME, bDeviceName, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
            _deviceName = deviceName;

            return true;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/BluetoothProtocol/BTConnect.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    public class GATT
    {
        enum RESULT
        {
            SUCCESS,
            FAIL,
            READYCONNECTED,
        }


        public GATT()
        {
        }

        ~GATT ()
        {

        }

        public bool Disconnect ()
        {
            return false;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/BluetoothProtocol/BTReceive.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;



namespace CSLibrary
{
    public partial class HighLevelInterface
    {
        byte[] _recvBuffer = new byte[8 + 255 + 20]; // receive packet buffer
        int _currentRecvBufferSize = 0;
        byte[] _recvBufferBackup = new byte[8 + 255 + 20]; // backup receive packet buffer
        int _currentRecvBufferSizeBackup = 0;

        private void CharacteristicOnValueUpdated(byte[] recvData)
        {
            if (CheckSingalPacket(recvData) || FirstAssemblePacketMohod(recvData) || BackupAssemblePacketMohod(recvData))
            {
                _currentRecvBufferSize = 0;
                _currentRecvBufferSizeBackup = 0;
            }
        }

        byte _blePacketRunningNumber = 0x82;

        bool CheckAPIHeader(byte[] data)
        {
            return (data[0] == 0xa7 &&
                    data[1] == 0xb3 &&
                    //data[2] <= 120 && ignore Check Data Length
                    // data[4] == 0x82 &&
                    data[5] == 0x9e &&
                    (data[3] == 0xc2 ||
                     data[3] == 0x6a ||
                     data[3] == 0xd9 ||
                     data[3] == 0xe8 ||
                     data[3] == 0x5f)
                    );
        }

        bool CheckSingalPacket(byte[] data)
        {
            try
            {
                if (!CheckAPIHeader(data) || data[2] != (data.Length - 8))
                    return false;

                UInt16 recvCRC = (UInt16)(data[6] << 8 | data[7]);
                if (recvCRC != Tools.Crc.ComputeChecksum(data))
                    return false;

                ProcessAPIPacket(data);
            }
            catch(Exception ex)
            {
                CSLibrary.Debug.WriteLine("CheckSingalPacket error : " + ex.Message);
                return false;
            }

            return true;
        }

        bool FirstAssemblePacketMohod(byte[] recvData)
        {
            try
            {
                if (CheckAPIHeader(recvData))
                {
                    if (_currentRecvBufferSize > 0)
                    {
                        CSLibrary.Debug.WriteLine("BT1 : Packet Too small, can not process");
                    }

                    Array.Copy(recvData, 0, _recvBuffer, 0, recvData.Length);
                    _currentRecvBufferSize = recvData.Length;
                    return false;
                }

                if ((_currentRecvBufferSize + recvData.Length) > _recvBuffer[2] + 8)
                {
                    CSLibrary.Debug.WriteLine("BT1 : Current packet size too large");
                    _currentRecvBufferSize = 0;
                    return false;
                }

                Array.Copy(recvData, 0, _recvBuffer, _currentRecvBufferSize, recvData.Length);
                _currentRecvBufferSize += recvData.Length;

                if (_currentRecvBufferSize == (_recvBuffer[2] + 8))
                {
                    UInt16 recvCRC = (UInt16)(_recvBuffer[6] << 8 | _recvBuffer[7]);
                    UInt16 calCRC = Tools.Crc.ComputeChecksum(_recvBuffer);
                    if (recvCRC != calCRC)
                    {
                        CSLibrary.Debug.WriteLine("BT1 : Checksum error " + recvCRC.ToString("X4") + " " + calCRC.ToString("X4"));
                        _currentRecvBufferSize = 0;
                        return false;
                    }

                    ProcessAPIPacket(_recvBuffer);
                    return true;
                }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("FirstAssemblePacketMohod Error : " + ex.Message);                
            }

            return false;
        }

        bool BackupAssemblePacketMohod(byte[] recvData)
        {
            try
            {
            if (_currentRecvBufferSizeBackup == 0)
            {
                if (!CheckAPIHeader(recvData))
                    return false;

                Array.Copy(recvData, 0, _recvBufferBackup, 0, recvData.Length);
                _currentRecvBufferSizeBackup = recvData.Length;
                return false;
            }

            if ((_currentRecvBufferSizeBackup + recvData.Length) > _recvBuffer[2] + 8)
            {
                CSLibrary.Debug.WriteLine("BT2 : Current packet size too large");
                _currentRecvBufferSizeBackup = 0;
                return false;
            }

            Array.Copy(recvData, 0, _recvBufferBackup, _currentRecvBufferSizeBackup, recvData.Length);
            _currentRecvBufferSizeBackup += recvData.Length;

            if (_currentRecvBufferSizeBackup == (_recvBuffer[2] + 8))
            {
                UInt16 recvCRC = (UInt16)(_recvBufferBackup[6] << 8 | _recvBufferBackup[7]);
                UInt16 calCRC = Tools.Crc.ComputeChecksum(_recvBuffer);
                if (recvCRC != calCRC)
                {
                    CSLibrary.Debug.WriteLine("BT2 : Checksum error " + recvCRC.ToString("X4") + " " + calCRC.ToString("X4"));
                    _currentRecvBufferSizeBackup = 0;
                    return false;
                }

                ProcessAPIPacket(_recvBufferBackup);
                return true;
            }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("BackupAssemblePacketMohod Error : " + ex.Message);
            }

            return false;
        }

    }
}
</file>

<file path="Library/CSLibrary/Source/BluetoothProtocol/BTSend.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    public partial class HighLevelInterface
    {
        readonly byte[] destinationsID = { 0xc2, 0x6a, 0xd9, 0xe8, 0x5f };

        internal enum BTCOMMANDTYPE
        {
            Normal,         // Normanl command : send 5 times, and clear all command if send fail
            Validate,       // Validate command : for test hardhware, send 2 times
            None            // end of enum
        }

        internal enum DEVICEID : byte
        {
            RFID = 0xc2,
            Barcode = 0x6a,
            Notification = 0xd9,
            SiliconLabIC = 0xe8,
            NluetoothIC = 0x5f
        }

        [Flags]
        internal enum BTWAITCOMMANDRESPONSETYPE
        {
            NOWAIT = 0,
            BTAPIRESPONSE = 1,
            COMMANDENDRESPONSE = 2,
            DATA1 = 4,
            DATA2 = 8,
            REGISTERRETURN = 16,
            ABORTRESPONSE = 32,
            TAGACCESSPACKET = 64,
            ENDEVENTUPLINKPACKET = 128,
            CSL_OPERATION_COMPLETE = 256,
            CSL_ACCESS_COMPLETE = 512,

            WAIT_BTAPIRESPONSE = BTAPIRESPONSE,
            WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE = BTAPIRESPONSE | COMMANDENDRESPONSE,
            WAIT_BTAPIRESPONSE_DATA1 = BTAPIRESPONSE | DATA1,
            WAIT_BTAPIRESPONSE_DATA2 = BTAPIRESPONSE | DATA2,
            WAIT_BTAPIRESPONSE_DATA1_COMMANDENDRESPONSE = BTAPIRESPONSE | DATA1 | COMMANDENDRESPONSE,
            WAIT_BTAPIRESPONSE_DATA2_COMMANDENDRESPONSE = BTAPIRESPONSE | DATA2 | COMMANDENDRESPONSE,
        }

        internal class SENDBUFFER
        {
            public BTCOMMANDTYPE type = BTCOMMANDTYPE.None;     // command type
            public byte[] packetData;                           // send data packet
            public UInt32 cmdRemark;                            // reserver
            public BTWAITCOMMANDRESPONSETYPE dataRemark;        // BT command return data check
            public Action sendFailCallback = null;              // Send fail callback
        }

        private List<SENDBUFFER> _sendBuffer = new List<SENDBUFFER>();
        //private bool _PROTOCOL_HardwareDiagnosticsMode = true;
        private uint _PROTOCOL_RetryCount = 0;

        private object _bleEngineLock = new object();
        private DateTime _packetResponseTimeout;
        private DateTime _packetDelayTimeout;

        internal UInt32 _currentCmdRemark;
        private BTWAITCOMMANDRESPONSETYPE _NeedCommandResponseType;
        private BTWAITCOMMANDRESPONSETYPE _currentCommandResponse;

        #region ---- Internal function ----

        internal bool SendAsync(int connection, int destination, byte[] eventCode = null, byte[] payload = null, BTWAITCOMMANDRESPONSETYPE sendRemark = BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE, UInt32 cmdRemark = 0xffffffff)
        {
            if (eventCode == null)
                CSLibrary.Debug.WriteLine ("SendAsync : ") ;
            else
                CSLibrary.Debug.WriteLine("SendAsync : " + eventCode[0].ToString("X2") + eventCode[1].ToString("X2"));

            try
            {
                byte[] sendData;

                if (eventCode == null && payload == null)
                {
                    sendData = new byte[8];
                }
                else if (payload == null)
                {
                    if (eventCode.Length > (255 - 8))
                        return false;

                    sendData = new byte[8 + eventCode.Length];

                    Array.Copy(eventCode, 0, sendData, 8, eventCode.Length);

                    sendData[2] = (byte)eventCode.Length;
                }
                else
                {
                    if ((eventCode.Length + payload.Length) > (255 - 8))
                        return false;

                    sendData = new byte[8 + eventCode.Length + payload.Length];

                    Array.Copy(eventCode, 0, sendData, 8, eventCode.Length);
                    Array.Copy(payload, 0, sendData, 8 + eventCode.Length, payload.Length);

                    sendData[2] = (byte)(eventCode.Length + payload.Length);
                }

                sendData[0] = 0xa7;
                sendData[1] = (byte)((connection == 0) ? 0xb3 : 0xe6);
                sendData[3] = destinationsID[destination];
                sendData[4] = 0x82;
                sendData[5] = 0x37; // downlink
                sendData[6] = 0x00; // CRC Check
                sendData[7] = 0x00; // CRC Check

                SENDBUFFER sendItem = new SENDBUFFER();
                sendItem.packetData = sendData;
                sendItem.cmdRemark = cmdRemark;
                sendItem.dataRemark = sendRemark;

                _sendBuffer.Add(sendItem);
                BLERWEngineTimer();
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("SendAsync exception : " + ex.Message);
            }

            return true;
        }

        internal bool SendAsyncUrgent(int connection, int destination, byte[] eventCode = null, byte[] payload = null, BTWAITCOMMANDRESPONSETYPE sendRemark = BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE, UInt32 cmdRemark = 0xffffffff)
        {
            try
            {
                byte[] sendData;

                if (eventCode == null && payload == null)
                {
                    sendData = new byte[8];

                    sendData[6] = 0x00;
                    sendData[7] = 0x00;
                }
                else if (payload == null)
                {
                    if (eventCode.Length > (255 - 8))
                        return false;

                    sendData = new byte[8 + eventCode.Length];

                    Array.Copy(eventCode, 0, sendData, 8, eventCode.Length);

                    sendData[2] = (byte)eventCode.Length;
                }
                else
                {
                    if ((eventCode.Length + payload.Length) > (255 - 8))
                        return false;

                    sendData = new byte[8 + eventCode.Length + payload.Length];

                    Array.Copy(eventCode, 0, sendData, 8, eventCode.Length);
                    Array.Copy(payload, 0, sendData, 8 + eventCode.Length, payload.Length);

                    sendData[2] = (byte)(eventCode.Length + payload.Length);
                }

                sendData[0] = 0xa7;
                sendData[1] = (byte)((connection == 0) ? 0xb3 : 0xe6);
                sendData[3] = destinationsID[destination];
                sendData[4] = 0x82;
                sendData[5] = 0x37; // downlink
                sendData[6] = 0x00;
                sendData[7] = 0x00;

                SENDBUFFER sendItem = new SENDBUFFER();
                sendItem.packetData = sendData;
                sendItem.cmdRemark = cmdRemark;
                sendItem.dataRemark = sendRemark;

                _sendBuffer.Insert(1, sendItem);
                BLERWEngineTimer();
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("SendAsyncUrgent exception : " + ex.Message);
            }

            return true;
        }

        internal bool SendAsync(DEVICEID destination, 
                                    byte[] eventCode = null, 
                                    byte[] payload = null, 
                                    BTCOMMANDTYPE type = BTCOMMANDTYPE.Normal, 
                                    BTWAITCOMMANDRESPONSETYPE sendRemark = BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE, 
                                    UInt32 cmdRemark = 0xffffffff, 
                                    Action failCallback = null)
        {
            byte[] sendData;

            if (eventCode == null && payload == null)
            {
                sendData = new byte[8];

                sendData[6] = 0x00;
                sendData[7] = 0x00;
            }
            else 
            {
                if (eventCode.Length > (255 - 8))
                    return false;

                if (payload == null)
                {
                    sendData = new byte[8 + eventCode.Length];

                    Array.Copy(eventCode, 0, sendData, 8, eventCode.Length);

                    sendData[2] = (byte)eventCode.Length;
                }
                else
                {
                    if ((eventCode.Length + payload.Length) > (255 - 8))
                        return false;

                    sendData = new byte[8 + eventCode.Length + payload.Length];

                    Array.Copy(eventCode, 0, sendData, 8, eventCode.Length);
                    Array.Copy(payload, 0, sendData, 8 + eventCode.Length, payload.Length);

                    sendData[2] = (byte)(eventCode.Length + payload.Length);
                }
            }

            sendData[0] = 0xa7;
            sendData[1] = 0xb3; // (byte)((connection == 0) ? 0xb3 : 0xe6);
            sendData[3] = (byte)destination;
            sendData[4] = 0x82;
            sendData[5] = 0x37;
            sendData[6] = 0x00;
            sendData[7] = 0x00;

            SENDBUFFER sendItem = new SENDBUFFER();
            sendItem.type = type;
            sendItem.packetData = sendData;
            sendItem.cmdRemark = cmdRemark;
            sendItem.dataRemark = sendRemark;
            sendItem.sendFailCallback = failCallback;

            _sendBuffer.Add(sendItem);
            BLERWEngineTimer();

            return true;
        }

        static readonly byte[] RFIDCommand = new byte[] { 0xA7, 0xB3, 0x0A, 0xC2, 0x82, 0x37, 0x00, 0x00, 0x80, 0x02, 0x70, 0x01, 0x00, 0xF0 };
        bool CheckRFIDCommand()
        {
            if (_sendBuffer[0].packetData.Length != 18)
                return false;

            for (int index = 0; index < RFIDCommand.Length; index ++)
                if (_sendBuffer[0].packetData[index] != RFIDCommand[index])
                    return false;

            _handlerRFIDReader._readerMode = 1; // record reader static to command mode

            if (_sendBuffer[0].packetData[14] == 0x14 && _sendBuffer[0].packetData[15] == 0x00 && _sendBuffer[0].packetData[16] == 0x00 && _sendBuffer[0].packetData[17] == 0x00)
            {
                _handlerRFIDReader._SetRFIDToStandbyMode = false;
            }
            else
            {
                _handlerRFIDReader._SetRFIDToStandbyMode = true;
            }

            return true;
        }



        async void BLERWEngineTimer()
        {
            await Task.Delay(10);

            lock (_bleEngineLock)
            {
                try
                {
                    if (_readerState != READERSTATE.DISCONNECT)
                    {
                        if (_NeedCommandResponseType != BTWAITCOMMANDRESPONSETYPE.NOWAIT)
                        {
                            CSLibrary.Debug.WriteLine("wait response : " + _NeedCommandResponseType.ToString() + ":" + _currentCommandResponse);
                            if ((_currentCommandResponse & _NeedCommandResponseType) == _NeedCommandResponseType)
                            {
                                if (_sendBuffer.Count > 0)
                                    _sendBuffer.RemoveAt(0);

                                _NeedCommandResponseType = BTWAITCOMMANDRESPONSETYPE.NOWAIT;
                                _PROTOCOL_RetryCount = 0;
                            }
                            else if (DateTime.Now > _packetResponseTimeout)
                            {
                                switch (_sendBuffer[0].type)
                                {
                                    case BTCOMMANDTYPE.None:
                                    case BTCOMMANDTYPE.Normal:
                                        if (_PROTOCOL_RetryCount > 19) // retry 19 times (~40s)
                                        {
                                            // cancel all command and send error event

                                            CSLibrary.Debug.WriteLine("Communication retry fail!!");
                                            _NeedCommandResponseType = BTWAITCOMMANDRESPONSETYPE.NOWAIT;
                                            FireReaderStateChangedEvent(new Events.OnReaderStateChangedEventArgs(_sendBuffer[0], Constants.ReaderCallbackType.COMMUNICATION_ERROR));
                                            _sendBuffer.Clear();
                                            _PROTOCOL_RetryCount = 0;
                                        }
                                        else
                                        {
                                            _PROTOCOL_RetryCount++;
                                            CSLibrary.Debug.WriteLine("Command timeout");
                                            _NeedCommandResponseType = BTWAITCOMMANDRESPONSETYPE.NOWAIT;
                                        }
                                        break;

                                    case BTCOMMANDTYPE.Validate:
                                        if (_PROTOCOL_RetryCount > 0) // retry 1 times
                                        {
                                            // cancel all command and send error event

                                            CSLibrary.Debug.WriteLine("hardware fail!!");

                                            if (_sendBuffer[0].sendFailCallback != null)
                                                _sendBuffer[0].sendFailCallback();
                                            _NeedCommandResponseType = BTWAITCOMMANDRESPONSETYPE.NOWAIT;
                                            _sendBuffer.RemoveAt(0);
                                            _PROTOCOL_RetryCount = 0;
                                        }
                                        else
                                        {
                                            _PROTOCOL_RetryCount++;
                                            CSLibrary.Debug.WriteLine("Hardware vaildate command timeout");
                                            _NeedCommandResponseType = BTWAITCOMMANDRESPONSETYPE.NOWAIT;
                                        }
                                        break;

                                }

                            }
                        }

                        if (_NeedCommandResponseType == BTWAITCOMMANDRESPONSETYPE.NOWAIT)
                        {
                            if (_sendBuffer.Count > 0 && DateTime.Now > _packetDelayTimeout)
                            {
                                _currentCommandResponse = BTWAITCOMMANDRESPONSETYPE.NOWAIT;
                                _currentCmdRemark = _sendBuffer[0].cmdRemark;
                                _NeedCommandResponseType = _sendBuffer[0].dataRemark;
                                CheckRFIDCommand();
                                BLE_Send(_sendBuffer[0].packetData);

                                if (_NeedCommandResponseType == BTWAITCOMMANDRESPONSETYPE.NOWAIT)
                                {
                                    _sendBuffer.RemoveAt(0);
                                }
                                else
                                {
                                    _packetDelayTimeout = DateTime.Now;
                                    _packetResponseTimeout = DateTime.Now.AddSeconds(2);

                                    if (_currentCommandResponse == BTWAITCOMMANDRESPONSETYPE.NOWAIT)
                                    {
                                        if (_sendBuffer[0].packetData[2] == 0x02 && _sendBuffer[0].packetData[9] == 0x00)
                                        {
                                            switch (_sendBuffer[0].packetData[8])
                                            {
                                                case 0x80:
                                                    _packetDelayTimeout = DateTime.Now.AddSeconds(3);
                                                    break;

                                                case 0x90:
                                                    //_packetDelayTimeout = DateTime.Now.AddSeconds(1);
                                                    break;
                                            }
                                        } // barcode command delay
                                        else if (_sendBuffer[0].packetData[8] == 0x90 && _sendBuffer[0].packetData[9] == 0x03)
                                        {
                                            _packetDelayTimeout = DateTime.Now.AddMilliseconds(500);
                                        }
                                    }

                                    CSLibrary.Debug.WriteBytes("BT send data (" + _sendBuffer[0].dataRemark.ToString() + ")", _sendBuffer[0].packetData);
                                }

                            }
                        }
                    }
                    else
                    {
                        _sendBuffer.Clear();
                    }

                    if (_sendBuffer.Count == 0)
                        ExecuteFinishBLETask();

                    // battery routine
                    //_handleBattery.Timer();
                }
                catch (Exception ex)
                {
                    CSLibrary.Debug.WriteLine("BLERWEngineTimer exception : " + ex.Message);
                }
            }
        }

        #endregion

        #region ---- Public function ----

        public bool BLEBusy
        {
            get { return (_sendBuffer.Count != 0); }
        }

        #endregion

    }
}
</file>

<file path="Library/CSLibrary/Source/BluetoothProtocol/ClassBleDebug.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    static public class InventoryDebug
    {
        static public uint _inventoryPacketCount = 0;
        static public uint _inventorySkipPacketCount = 0;

        static public void Clear()
        {
            _inventoryPacketCount = 0;
            _inventorySkipPacketCount = 0;
            Print();
        }

        static public void InventoryPackerCountInc ()
        {
            _inventoryPacketCount++;
            Print();
        }

        static public void InventorySkipPackerAdd(uint cnt)
        {
            _inventorySkipPacketCount += cnt;
            Print();
        }

        static public void Print ()
        {
            CSLibrary.Debug.WriteLine("BLE stat : Total Inventory Received {0}, Skip packet {1}", _inventoryPacketCount, _inventorySkipPacketCount);
        }

    }
}
</file>

<file path="Library/CSLibrary/Source/BluetoothProtocol/CSLibrary.Private.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;

namespace CSLibrary
{
    public partial class HighLevelInterface
    {
        private void FireReaderStateChangedEvent(CSLibrary.Events.OnReaderStateChangedEventArgs args)
        {
            if (OnReaderStateChanged != null)
            {
                try
                {
                    OnReaderStateChanged(this, args);
                }
                catch (Exception ex)
                {
                    //CSLibrary.Debug.PrintLine("Communication retry fail!!");

                    //Console.WriteLine(ex);
                }
            }
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/CSLibrary.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using CSLibrary.Constants;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    public partial class HighLevelInterface
    {
        #region Constant
        // CS108 State
        public enum READERSTATE
        {
            DISCONNECT,
            IDLE,
            BUSY,
            READYFORDISCONNECT
        }

        // CS108 Command
        private class DOWNLINKCMD
        {
            // RFID event code
            public static readonly byte[] RFIDPOWERON = { 0x80, 0x00 };
            public static readonly byte[] RFIDPOWEROFF = { 0x80, 0x01 };
            public static readonly byte[] RFIDCMD = { 0x80, 0x02 };

            // Barcode event code
            public static readonly byte[] BARCODEPOWERON = { 0x90, 0x00 };
            public static readonly byte[] BARCODEPOWEROFF = { 0x90, 0x01 };
            public static readonly byte[] BARCODESCANTRIGGER = { 0x90, 0x02 };
            public static readonly byte[] BARCODERAWDATA = { 0x90, 0x03 };

            // CS108 status event code
            public static readonly byte[] GETVOLTAGE = { 0xA0, 0x00 };
            public static readonly byte[] GETTRIGGERSTATE = { 0xA0, 0x01 };
            public static readonly byte[] STARTAUTOREPORTING = { 0xA0, 0x02 };
            public static readonly byte[] STOPAUTOREPORTING = { 0xA0, 0x03 };
            public static readonly byte[] RFIDABORT = { 0xA0, 0x04 };
            public static readonly byte[] GETTRIGGER = { 0xA0, 0x05 };
            public static readonly byte[] SETFASTMODE = { 0xA0, 0x06 };
            public static readonly byte[] GETFASTMODE = { 0xA0, 0x07 };
            public static readonly byte[] STARTAUTOREIGGERREPORTING = { 0xA0, 0x08 };
            public static readonly byte[] STOPAUTOREIGGERREPORTING = { 0xA0, 0x09 };

            // Silicon Lab IC event code
            public static readonly byte[] GETSILICONVER = { 0xB0, 0x00 };
            public static readonly byte[] SLIMAGERAWDATA = { 0xB0, 0x01 };
            public static readonly byte[] SLBOOTLOADERRAWDATA = { 0xB0, 0x02 };

            // BlueTooth event code
            public static readonly byte[] GETVLUETOOTHVER = { 0xB0, 0x00 };
            public static readonly byte[] BTIMAGERAWDATA = { 0xB0, 0x01 };
            public static readonly byte[] BTBOOTLOADERRAWDATA = { 0xB0, 0x02 };
            public static readonly byte[] SETDEVICENAME = { 0xB0, 0x03 };
            public static readonly byte[] GETDEVICENAME = { 0xB0, 0x04 };
        }

        private class UPLINKCMD
        {
            public static readonly byte[] RFIDDATA = { 0x81, 0x00 };

            public static readonly byte[] BARCODEDATA = { 0x90, 0x00 };
            public static readonly byte[] BARCODEVALID = { 0x90, 0x01 };

            public static readonly byte[] BATTERYFAILED = { 0xA1, 0x00 };
            public static readonly byte[] ERRORCODE = { 0xA1, 0x01 };
            public static readonly byte[] TRIGGERPUSHED = { 0xA1, 0x02 };
            public static readonly byte[] TRIGGERRELEASED = { 0xA1, 0x03 };
        }

        // Constant
        #endregion

        #region internal variable

        private READERSTATE _readerState = READERSTATE.DISCONNECT;
        public READERSTATE Status { get { return _readerState; } }

        /// <summary>
        /// Reader Operation State Event
        /// </summary>
        public event EventHandler<CSLibrary.Events.OnReaderStateChangedEventArgs> OnReaderStateChanged;

        #endregion 

        #region public variable

        private SiliconLabIC _handleSiliconLabIC = null;
        private RFIDReader _handlerRFIDReader = null;
        private BarcodeReader _handleBarCodeReader = null;
        private Notification _handleNotification = null;
        private BluetoothIC _handleBluetoothIC = null;
        internal Battery _handleBattery = null;

        public SiliconLabIC siliconlabIC
        {
            get { return _handleSiliconLabIC; }
        }

        public RFIDReader rfid
        {
            get { return _handlerRFIDReader; }
            //set { _handlerRFIDReader = value; }
        }

        public BarcodeReader barcode
        {
            get { return _handleBarCodeReader; }
            //set { _handleBarCodeReader = value; }
        }

        public Notification notification
        {
            get { return _handleNotification; }
            //set { _handleNotification = value; }
        }

        public BluetoothIC bluetoothIC
        {
            get { return _handleBluetoothIC; }
            //set { _handleBluetoothIC = value; }
        }

        public Battery battery
        {
            get { return _handleBattery; }
        }

        public string ReaderName
        {
            get
            {
                var value = _handleBluetoothIC.GetDeviceName();

                if (value == null)
                    return _device.Name;
                else
                    return value;
            }
        }

        internal string _MacAdd = null;
        public string GetMacAddress()
        {
            return _MacAdd;
        }


        #endregion

        public HighLevelInterface()
        {
            // Basic Module
            _handleSiliconLabIC = new SiliconLabIC(this);
            _handlerRFIDReader = new RFIDReader(this);
            _handleBarCodeReader = new BarcodeReader(this);
            _handleNotification = new Notification(this);
            _handleBluetoothIC = new BluetoothIC(this);
            _handleBattery = new Battery(this);

            BLE_Init();
        }

        ~HighLevelInterface()
        {
            DisconnectAsync();
        }

        public void CancelEventOnReaderStateChanged()
        {
            OnReaderStateChanged = null;
        }


        public Version GetVersion ()
        {
            Version ver = new Version(2, 0, 10, 1);
            return ver;
        }

        CSLibrary.Timer BTTimer;
        void HardwareInit()
        {
            BARCODEPowerOn();
            RFIDPowerOff();
            RFIDPowerOn();

            // Set Low Power mode
            rfid.SetDeviceType(_deviceType);
            rfid.StopOperation();

            _handleBluetoothIC.Connect();
            _handleSiliconLabIC.Connect(_deviceType);
            _handleBarCodeReader.CheckHWValid();

            //rfid.StopOperation();
            //rfid.Connect(MODEL.CS710S);
            rfid.Connect(_deviceType);

            //rfid.ResetToDefaultPowerMode();
            //rfid.SetReaderPowerMode(false);
            //rfid.SetToStandbyMode();

            notification.SetAutoReport(true);
            //notification.SetAutoTriggerReport(0); // off auto trigger report // cancel SetAutoTriggerReport commnad to compatible with old BT firmware

            FireReaderStateChangedEvent(new Events.OnReaderStateChangedEventArgs(_sendBuffer[0], Constants.ReaderCallbackType.CONNECT_SUCESS));
        }

        Func <Task> _afterFinishBLETask = null;
        void WhenBLEFinish(Func<Task> nextTask)
        {
            _afterFinishBLETask = nextTask;
        }

        void ExecuteFinishBLETask()
        {
            if (_afterFinishBLETask == null)
                return;

            _afterFinishBLETask();
            _afterFinishBLETask = null;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="packetData"></param>
        public bool ProcessAPIPacket (byte [] recData)
        {
            byte [] data = (byte [])recData.Clone();

            //CSLibrary.Debug.WriteLine("Routine : ProcessAPIPacket");

            switch (data[3])
            {
                case 0xc2:
                    // check packet running number
                    if (data[5] == 0x9e && data[8] == 0x81 && data[9] == 0x00)
                    {
                        _blePacketRunningNumber++;
                        if (data[4] != _blePacketRunningNumber)
                        {
                            if (data[4] > _blePacketRunningNumber)
                                InventoryDebug.InventorySkipPackerAdd((uint)(data[4] - _blePacketRunningNumber));
                            else 
                                InventoryDebug.InventorySkipPackerAdd((uint)((256U + data[4]) - _blePacketRunningNumber));

                            _blePacketRunningNumber = data[4];
                        }
                    }

                    _currentCommandResponse |= RecvRFIDPacket(data);
                    break;

                case 0x6a:
                    switch (RecvBarcodePacket(data))
                    {
                        case BARCODECOMMANDRESPONSETYPE.CONTROLCOMMAND:
                            _currentCommandResponse |= BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE;
                            break;

                        case BARCODECOMMANDRESPONSETYPE.DATA:
                            _currentCommandResponse |= BTWAITCOMMANDRESPONSETYPE.DATA1;
                            break;

                        case BARCODECOMMANDRESPONSETYPE.NOTIFICATION:
                        case BARCODECOMMANDRESPONSETYPE.ERROR:
                        default:
                            return true;
                    }
                    break;

                case 0xd9:
                    if (RecvNofigicationPacket (data))
						_currentCommandResponse |= BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE;
					break;
                    //return false;

                case 0xe8:
                    _currentCommandResponse |= _handleSiliconLabIC.ProcessDataPacket(data);
                    break;

                case 0x5f:
                    if (_handleBluetoothIC.BluetoothICPacket(data))
                        _currentCommandResponse |= BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE;
                    break;
            }

            BLERWEngineTimer(); // send next packet immediately
            return true;
        }

        void TimerFunc(object o)
        {
            if (_readerState == READERSTATE.READYFORDISCONNECT || _readerState == READERSTATE.DISCONNECT)
            {
                BTTimer.Cancel();
                _sendBuffer.Clear();
                _NeedCommandResponseType = BTWAITCOMMANDRESPONSETYPE.NOWAIT;
                _readerState = READERSTATE.DISCONNECT;
                return;
            }

            BLERWEngineTimer();
            return;
        }

		internal CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE RecvRFIDPacket(byte[] recvData)
        {
            CSLibrary.Debug.WriteLine("Routine : RecvRFIDPacket");

            UInt16 eventCode = (UInt16)((UInt16)recvData[8] << 8 | (UInt16)recvData[9]);

            switch (eventCode)
            {
                case 0x8000:
                    {
                        // power on
                        var result = recvData[10];
                    }
                    break;

                case 0x8001:
                    {
                        // power off
                        var result = recvData[10];
                    }
                    break;

                case 0x8002:
                    {
                        var result = recvData[10];
                    }
                    break;

                case 0x8100:
                    //return _handlerRFIDReader.DeviceRecvData (recvData, _currentCommandResponse);
                    return rfid.DeviceRecvData(recvData, _currentCommandResponse);

                default:
                    // packet data error
                    return BTWAITCOMMANDRESPONSETYPE.NOWAIT;
            }

            return  BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE;
        }

        enum BARCODECOMMANDRESPONSETYPE
        {
            CONTROLCOMMAND,
            DATA,
            NOTIFICATION,
            ERROR
        }

		BARCODECOMMANDRESPONSETYPE RecvBarcodePacket (byte[] recvData)
        {
            UInt16 eventCode = (UInt16)((UInt16)recvData[8] << 8 | (UInt16)recvData[9]);

            switch (eventCode)
            {
                case 0x9000:
                    {
                        // power on
                        //_handleBarCodeReader.DeviceRecvState(1);
                        return BARCODECOMMANDRESPONSETYPE.CONTROLCOMMAND;
                    }

                case 0x9001:
                    {
                        // power off
                        //_handleBarCodeReader.DeviceRecvState(0);
                        return BARCODECOMMANDRESPONSETYPE.CONTROLCOMMAND;
                    }

                case 0x9002:
					//_handlerRFIDReader.DeviceRecvData(recvData, 10, recvData.Length - 10);
					return BARCODECOMMANDRESPONSETYPE.CONTROLCOMMAND;

				case 0x9003:
					//_handlerRFIDReader.DeviceRecvData(recvData, 10, recvData.Length - 10);
					return BARCODECOMMANDRESPONSETYPE.CONTROLCOMMAND;

                case 0x9004:
                    return BARCODECOMMANDRESPONSETYPE.CONTROLCOMMAND;

                case 0x9005:
                    return BARCODECOMMANDRESPONSETYPE.CONTROLCOMMAND;

                case 0x9100:    // (barcode reader data)
                    if (_handleBarCodeReader.DeviceRecvData(recvData))
                        return BARCODECOMMANDRESPONSETYPE.DATA;
                    break;

                case 0x9101:	// Good read (ignore)
                    _handleBarCodeReader.DeviceRecvGoodRead();
                    return BARCODECOMMANDRESPONSETYPE.NOTIFICATION;
            }

            return BARCODECOMMANDRESPONSETYPE.ERROR;
        }

        internal bool RecvNofigicationPacket(byte[] recvData)
        {
			UInt16 eventCode = (UInt16)((UInt16)recvData[8] << 8 | (UInt16)recvData[9]);

			switch (eventCode)
			{
				case 0xa000:    // Current battery voltage
                    {
                        UInt16 voltage = (UInt16)((UInt16)recvData[10] << 8 | (UInt16)recvData[11]);

                        // buf fix CS710S report wrong voltage 
                        if (_deviceType == RFIDDEVICE.MODEL.CS710S)
                        {
                            if (_handleSiliconLabIC.GetFirmwareVersion() <= 0x00020104) // <= version 2.1.4
                                if (voltage >= 4450) // > 4.45v
                                    voltage -= 430; // - 0.43v
                                else
                                    voltage -= 350; // - 0.35v
                        }

                        _handleNotification.DeviceRecvVoltage(voltage);
                    }
                    return false;
					break;

				case 0xa001:    // Button Status
					switch (recvData[10])
					{
						case 0x00:
							_handleNotification.DeviceRecvState(1);              // Send event to application
							break;

						case 0x01:
							_handleNotification.DeviceRecvState(0);              // Send event to application
							break;
					}
                    return false;
                    break;

                case 0xa002:
                    break;

                case 0xa006:
                    break;

                case 0xa101:        // Error Code
					CSLibrary.Debug.WriteLine("Error : CS108 Error Code : {0}", (UInt16)((UInt16)recvData[10] << 8 | (UInt16)recvData[11]));
                    return false;
                    break;

				case 0xa102:      // Button On
					_handleNotification.DeviceRecvState(0);              // Send event to application
					return false;
					break;

				case 0xa103:      // Button Off
					_handleNotification.DeviceRecvState(1);              // Send event to application
					return false;
					break;
			}

			return true;
        }

        // public RFID function
        internal void RFIDPowerOn()
        {
            SendAsync(0, 0, DOWNLINKCMD.RFIDPOWERON, null, BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
        }

		internal void RFIDPowerOff()
        {
            SendAsync(0, 0, DOWNLINKCMD.RFIDPOWEROFF, null, BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
        }

        // public barcode function
        internal void BARCODEPowerOn()
        {
			SendAsync(0, 1, DOWNLINKCMD.BARCODEPOWERON, null, BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
        }

        internal void BARCODEPowerOff()
        {
            SendAsync(0, 1, DOWNLINKCMD.BARCODEPOWEROFF, null, BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
        }

    }
}
</file>

<file path="Library/CSLibrary/Source/HAL/MvvmCross.Plugin.BLE/ClassDebug.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;

namespace CSLibrary
{
    public static class Debug
    {
        public static void WriteBytes(string header, byte[] data)
        {
            string str = "";
            for (int cnt = 0; cnt < data.Length; cnt++)
                str += data[cnt].ToString("X2") + " ";
            WriteLine ("CSLibrary : " + header + " {0}:{1}", data.Length, str);
        }

        public static void WriteLine(string format, params object[] args)
        {
            Console.WriteLine(string.Format(format, args));
            //Plugin.BLE.Abstractions.Trace.Message(string.Format(format, args));
        }

        public static void Write(string format, params object[] args)
        {
            Console.Write(string.Format(format, args));
            //Plugin.BLE.Abstractions.Trace.Message(string.Format(format, args));
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/HAL/MvvmCross.Plugin.BLE/ClassDeviceFinder.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#if __MwwmCrossPluginBLE

using System;
using System.Collections.Generic;

using Plugin.BLE.Abstractions;
using Plugin.BLE.Abstractions.Contracts;
using Plugin.BLE.Abstractions.EventArgs;

namespace CSLibrary
{
    public partial class DeviceFinder
    {
        /// <summary>
        /// DeviceFinder Argument
        /// </summary>
        public class DeviceFinderArgs : EventArgs
        {
            private DeviceInfomation _data;

            /// <summary>
            /// Device Finder 
            /// </summary>
            /// <param name="data"></param>
            public DeviceFinderArgs(DeviceInfomation data)
            {
                _data = data;
            }

            /// <summary>
            /// Device finder information
            /// </summary>
            public DeviceInfomation Found
            {
                get { return _data; }
                set { _data = value; }
            }
        }

        /// <summary>
        /// Netfinder information return from device
        /// </summary>
        public class DeviceInfomation
        {
            public uint ID;

            public string deviceName;

            public object nativeDeviceInformation;

            /*
                    /// <summary>
                    /// Reserved for future use
                    /// </summary>
                    public Mode Mode = Mode.Unknown; 
                    /// <summary>
                    /// Total time on network
                    /// </summary>
                    public TimeEvent TimeElapsedNetwork = new TimeEvent();
                    /// <summary>
                    /// Total Power on time
                    /// </summary>
                    public TimeEvent TimeElapsedPowerOn = new TimeEvent();
                    /// <summary>
                    /// MAC address
                    /// </summary>
                    public MAC MACAddress = new MAC();//[6];
                    /// <summary>
                    /// IP address
                    /// </summary>
                    public IP IPAddress = new IP();
                    /// <summary>
                    /// Subnet Mask
                    /// </summary>
                    public IP SubnetMask = new IP();
                    /// <summary>
                    /// Gateway
                    /// </summary>
                    public IP Gateway = new IP();
                    /// <summary>
                    /// Trusted hist IP
                    /// </summary>
                    public IP TrustedServer = new IP();
                    /// <summary>
                    /// Inducated trusted server enable or not.
                    /// </summary>
                    public Boolean TrustedServerEnabled = false;
                    /// <summary>
                    /// UDP Port
                    /// </summary>
                    public ushort Port; // Get port from UDP header
                    /// <summary>
                    /// Reserved for future use, Server mode ip
                    /// </summary>
                    public byte[] serverip = new byte[4];
                    /// <summary>
                    /// enable or disable DHCP
                    /// </summary>
                    public bool DHCPEnabled;
                    /// <summary>
                    /// Reserved for future use, Server mode port
                    /// </summary>
                    public ushort serverport;
                    /// <summary>
                    /// DHCP retry
                    /// </summary>
                    public byte DHCPRetry;
                    /// <summary>
                    /// Device name, user can change it.
                    /// </summary>
                    public string DeviceName;
                    /// <summary>
                    /// Mode discription
                    /// </summary>
                    public string Description;
                    /// <summary>
                    /// Connect Mode
                    /// </summary>        
                    public byte ConnectMode;
                    /// <summary>
                    /// Gateway check reset mode
                    /// </summary>
                    public int GatewayCheckResetMode;
            */
        }

        static private Windows.Devices.Enumeration.DeviceWatcher deviceWatcher;
	    static List<Windows.Devices.Enumeration.DeviceInformation> _deviceDB = new List<Windows.Devices.Enumeration.DeviceInformation>();

        static public event EventHandler<DeviceFinderArgs> OnSearchCompleted;

        static public void SearchDevice()
        {
            // Additional properties we would like about the device.
            // Property strings are documented here https://msdn.microsoft.com/en-us/library/windows/desktop/ff521659(v=vs.85).aspx
            string[] requestedProperties = { "System.Devices.Aep.DeviceAddress", "System.Devices.Aep.IsConnected", "System.Devices.Aep.Bluetooth.Le.IsConnectable", "System.Devices.Aep.AepId", "System.Devices.Aep.Category" };

            // BT_Code: Example showing paired and non-paired in a single query.
            string aqsAllBluetoothLEDevices = "(System.Devices.Aep.ProtocolId:=\"{bb7bb05e-5972-42b5-94fc-76eaa7084d49}\")";

            deviceWatcher =
                    DeviceInformation.CreateWatcher(
                        aqsAllBluetoothLEDevices,
                        requestedProperties,
                        DeviceInformationKind.AssociationEndpoint);

            // Register event handlers before starting the watcher.
            deviceWatcher.Added += DeviceWatcher_Added;
            deviceWatcher.Updated += DeviceWatcher_Updated;
            deviceWatcher.Removed += DeviceWatcher_Removed;
            deviceWatcher.EnumerationCompleted += DeviceWatcher_EnumerationCompleted;
            deviceWatcher.Stopped += DeviceWatcher_Stopped;

            // Start the watcher.
            deviceWatcher.Start();
        }


        static public void Stop()
        {
            /// <summary>
            /// Stops watching for all nearby Bluetooth devices.
            /// </summary>
            if (deviceWatcher != null)
            {
                // Unregister the event handlers.
                deviceWatcher.Added -= DeviceWatcher_Added;

                // Stop the watcher.
                deviceWatcher.Stop();
                deviceWatcher = null;
            }
        }

	    static public void ClearDeviceList()
	    {
		    _deviceDB.Clear ();
	    }

        static public DeviceInformation GetDeviceInformation(int id)
        {
            if (id < _deviceDB.Count)
                return _deviceDB[id];

            return null;
        }

        static public DeviceInformation GetDeviceInformation (string readername)
	    {
		    foreach (DeviceInformation item in _deviceDB)
		    {
			    if (item.Id == readername)
				    return item;
		    }

		    return null;		
	    }

	    static public List<DeviceInformation> GetAllDeviceInformation ()
	    {
		    return _deviceDB;
	    }

        static private async void DeviceWatcher_Added(DeviceWatcher sender, Windows.Devices.Enumeration.DeviceInformation deviceInfo)
        {
            Debug.WriteLine(String.Format("Added {0}{1}", deviceInfo.Id, deviceInfo.Name));

            // Protect against race condition if the task runs after the app stopped the deviceWatcher.
            if (sender == deviceWatcher)
            {
                CSLibrary.DeviceFinder.DeviceInfomation di = new CSLibrary.DeviceFinder.DeviceInfomation();
                di.deviceName = deviceInfo.Name;
                di.ID = (uint)_deviceDB.Count;
                di.nativeDeviceInformation = (object)deviceInfo;

                _deviceDB.Add(deviceInfo); 

                RaiseEvent<DeviceFinderArgs>(OnSearchCompleted, new DeviceFinderArgs(di));
            }
        }

        static private async void DeviceWatcher_Updated(DeviceWatcher sender, DeviceInformationUpdate deviceInfoUpdate)
        {
        }

        static private async void DeviceWatcher_Removed(DeviceWatcher sender, DeviceInformationUpdate deviceInfoUpdate)
        {
        }

        static private async void DeviceWatcher_EnumerationCompleted(DeviceWatcher sender, object e)
        {
        }

        static private async void DeviceWatcher_Stopped(DeviceWatcher sender, object e)
        {
        }

        static private void RaiseEvent<T>(EventHandler<T> eventHandler, T e)
            where T : EventArgs
        {
            if (eventHandler != null)
            {
                eventHandler(null, e);
            }
            return;
        }
    }

}

#endif
</file>

<file path="Library/CSLibrary/Source/HAL/MvvmCross.Plugin.BLE/CodeFileBLE.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using Plugin.BLE.Abstractions;
using Plugin.BLE.Abstractions.Contracts;
using Plugin.BLE.Abstractions.EventArgs;

namespace CSLibrary
{
    using static RFIDDEVICE;
    using Constants;
    using System.Linq;
    using System.Threading;

    public partial class HighLevelInterface
    {
        // for bluetooth Connection
        // for bluetooth Connectiond
        IAdapter _adapter;
        IDevice _device;
        IService _service;
        IService _serviceDeviceInfo;
        ICharacteristic _characteristicWrite;
        ICharacteristic _characteristicUpdate;
        ICharacteristic _characteristicDeviceInfoRead;
        MODEL _deviceType = MODEL.UNKNOWN;

        /// <summary>
        /// return error code
        /// </summary>
        /// <returns></returns>
        int BLE_Init()
        {
            return 0;
        }

        public async Task<bool> ConnectAsync(IAdapter adapter, IDevice device, MODEL deviceType)
        {
            if (_readerState != READERSTATE.DISCONNECT)
                return false; // reader can not reconnect

            this._deviceType = deviceType;

            try
            {
                switch (_deviceType)
                {
                    case MODEL.CS108:
                        _service = await device.GetServiceAsync(Guid.Parse("00009800-0000-1000-8000-00805f9b34fb"));
                        break;

                    case MODEL.CS710S:
                        await device.RequestMtuAsync(255); // for BLE 5.0
                        _service = await device.GetServiceAsync(Guid.Parse("00009802-0000-1000-8000-00805f9b34fb"));
                        break;
                }

                if (_service == null)
                    return false;

                _serviceDeviceInfo = await device.GetServiceAsync(Guid.Parse("0000180a-0000-1000-8000-00805f9b34fb"));
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Program execption error, please check ConnectAsync!!! error message : " + ex.Message);
            }

            _readerState = READERSTATE.IDLE;

            _adapter = adapter;
            _device = device;

            _adapter.DeviceConnectionLost -= OnDeviceConnectionLost;
            _adapter.DeviceConnectionLost += OnDeviceConnectionLost;

            try
            {
                _characteristicWrite = await _service.GetCharacteristicAsync(Guid.Parse("00009900-0000-1000-8000-00805f9b34fb"));
                _characteristicUpdate = await _service.GetCharacteristicAsync(Guid.Parse("00009901-0000-1000-8000-00805f9b34fb"));
                _characteristicWrite = await _service.GetCharacteristicAsync(Guid.Parse("00009900-0000-1000-8000-00805f9b34fb"));

                if (_serviceDeviceInfo != null)
                {
                    _characteristicDeviceInfoRead = await _serviceDeviceInfo.GetCharacteristicAsync(Guid.Parse("00002a23-0000-1000-8000-00805f9b34fb"));

                    await _characteristicDeviceInfoRead.ReadAsync();
                    
                    if (_characteristicDeviceInfoRead?.Value.Count() == 8)
                    {
                        _MacAdd = _characteristicDeviceInfoRead?.Value[7].ToString("X2") +
                            _characteristicDeviceInfoRead?.Value[6].ToString("X2") +
                            _characteristicDeviceInfoRead?.Value[5].ToString("X2") +
                            _characteristicDeviceInfoRead?.Value[2].ToString("X2") +
                            _characteristicDeviceInfoRead?.Value[1].ToString("X2") +
                            _characteristicDeviceInfoRead?.Value[0].ToString("X2");
                            ;

                        //CSLibrary.Debug.WriteLine("BLE Mac Addres : " + _MacAdd);
                    }
                }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("Can not set characters");
            }

            _characteristicUpdate.ValueUpdated -= BLE_Recv;
            _characteristicUpdate.ValueUpdated += BLE_Recv;
            //            _characteristicWrite.ValueUpdated += CharacteristicOnWriteUpdated;

            //CSLibraryv4: wait for new ble library compatibility
            BTTimer = new Timer(TimerFunc, this, 0, 1000);

            await _characteristicUpdate.StartUpdatesAsync();
            //            await _characteristicWrite.StartUpdatesAsync();

            _readerState = READERSTATE.IDLE;
            BTTimer = new Timer(TimerFunc, this, 0, 1000);

            HardwareInit();

            return true;
        }

        public async Task<bool> DisconnectAsync()
        {
            try
            {
                if (Status != READERSTATE.IDLE)
                    return false;

                if (_readerState != READERSTATE.DISCONNECT)
                {
                    BARCODEPowerOff();
                    RFIDPowerOff();
                    while (BLEBusy)
                        await Task.Delay(500);
                    //CSLibraryv4: clear connection without waiting for BLE readiness
                    //WhenBLEFinish(ClearConnection);
                    await ClearConnection();
                }
                else
                {
                    await ClearConnection();
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Disconnect error " + ex.Message.ToString());
            }

            _handlerRFIDReader.Disconnect();
            return true;
        }

        /// <summary>
        /// return error code
        /// </summary>
        /// <returns></returns>
        private async Task<bool> BLE_Send (byte[] data)
        {
            return await _characteristicWrite.WriteAsync(data);
        }

        private async void BLE_Recv(object sender, CharacteristicUpdatedEventArgs characteristicUpdatedEventArgs)
        {
            try
            {
                byte[] data = characteristicUpdatedEventArgs.Characteristic.Value;
                if (data == null)
                    return;
 
                CSLibrary.Debug.WriteBytes("BT data received", data);
                CharacteristicOnValueUpdated(data);
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Program execption error, please check BLE_Recv!!! error message : " + ex.Message);
            }
        }

        private void CharacteristicOnWriteUpdated(object sender, CharacteristicUpdatedEventArgs characteristicUpdatedEventArgs)
        {
            CSLibrary.Debug.WriteBytes("BT: Write data success updated", characteristicUpdatedEventArgs.Characteristic.Value);
        }

        private void OnStateChanged(object sender, BluetoothStateChangedArgs e)
        {
        }

        private void OnDeviceConnectionLost(object sender, DeviceErrorEventArgs e)
        {
            if (e.Device.Id == _device.Id)
            {
                //DisconnectAsync();
                ConnectLostAsync();
            }
        }

        public async void ConnectLostAsync()
        {
            _readerState = READERSTATE.READYFORDISCONNECT;

            _characteristicUpdate.ValueUpdated -= BLE_Recv;
            _adapter.DeviceConnectionLost -= OnDeviceConnectionLost;

            _characteristicUpdate = null;
            _characteristicWrite = null;
            _service = null;

            try
            {

                if (_device.State == DeviceState.Connected)
                {
                    await _adapter.DisconnectDeviceAsync(_device);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Program execption error, please check ConnectLostAsync!!! error message : " + ex.Message);
            }
            _device = null;

            _readerState = READERSTATE.DISCONNECT;

            FireReaderStateChangedEvent(new Events.OnReaderStateChangedEventArgs(null, Constants.ReaderCallbackType.CONNECTION_LOST));
        }

        async Task ClearConnection()
        {
            _readerState = READERSTATE.READYFORDISCONNECT;
            // Stop Timer;
            await _characteristicUpdate.StopUpdatesAsync();

            _characteristicUpdate.ValueUpdated -= BLE_Recv;
            _adapter.DeviceConnectionLost -= OnDeviceConnectionLost;

            _characteristicUpdate = null;
            _characteristicWrite = null;
            _service = null;

            try
            {
                if (_device.State == DeviceState.Connected)
                {
                    await _adapter.DisconnectDeviceAsync(_device);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Program execption error, please check ClearConnection!!! error message : " + ex.Message);
            }
            _device = null;

            _readerState = READERSTATE.DISCONNECT;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/HAL/Plugin.BLE/ClassDebug.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;

namespace CSLibrary
{
    public static class Debug
    {
        public static void WriteBytes(string header, byte[] data)
        {
            string str = "";
            for (int cnt = 0; cnt < data.Length; cnt++)
                str += data[cnt].ToString("X2") + " ";
            WriteLine ("CSLibrary : " + header + " {0}:{1}", data.Length, str);
        }

        public static void WriteLine(string format, params object[] args)
        {
            Console.WriteLine(string.Format(format, args));
            //Plugin.BLE.Abstractions.Trace.Message(string.Format(format, args));
        }

        public static void Write(string format, params object[] args)
        {
            Console.Write(string.Format(format, args));
            //Plugin.BLE.Abstractions.Trace.Message(string.Format(format, args));
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/HAL/Plugin.BLE/ClassDeviceFinder.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#if __MwwmCrossPluginBLE

using System;
using System.Collections.Generic;

using Plugin.BLE.Abstractions;
using Plugin.BLE.Abstractions.Contracts;
using Plugin.BLE.Abstractions.EventArgs;

namespace CSLibrary
{
    public partial class DeviceFinder
    {
        /// <summary>
        /// DeviceFinder Argument
        /// </summary>
        public class DeviceFinderArgs : EventArgs
        {
            private DeviceInfomation _data;

            /// <summary>
            /// Device Finder 
            /// </summary>
            /// <param name="data"></param>
            public DeviceFinderArgs(DeviceInfomation data)
            {
                _data = data;
            }

            /// <summary>
            /// Device finder information
            /// </summary>
            public DeviceInfomation Found
            {
                get { return _data; }
                set { _data = value; }
            }
        }

        /// <summary>
        /// Netfinder information return from device
        /// </summary>
        public class DeviceInfomation
        {
            public uint ID;

            public string deviceName;

            public object nativeDeviceInformation;

            /*
                    /// <summary>
                    /// Reserved for future use
                    /// </summary>
                    public Mode Mode = Mode.Unknown; 
                    /// <summary>
                    /// Total time on network
                    /// </summary>
                    public TimeEvent TimeElapsedNetwork = new TimeEvent();
                    /// <summary>
                    /// Total Power on time
                    /// </summary>
                    public TimeEvent TimeElapsedPowerOn = new TimeEvent();
                    /// <summary>
                    /// MAC address
                    /// </summary>
                    public MAC MACAddress = new MAC();//[6];
                    /// <summary>
                    /// IP address
                    /// </summary>
                    public IP IPAddress = new IP();
                    /// <summary>
                    /// Subnet Mask
                    /// </summary>
                    public IP SubnetMask = new IP();
                    /// <summary>
                    /// Gateway
                    /// </summary>
                    public IP Gateway = new IP();
                    /// <summary>
                    /// Trusted hist IP
                    /// </summary>
                    public IP TrustedServer = new IP();
                    /// <summary>
                    /// Inducated trusted server enable or not.
                    /// </summary>
                    public Boolean TrustedServerEnabled = false;
                    /// <summary>
                    /// UDP Port
                    /// </summary>
                    public ushort Port; // Get port from UDP header
                    /// <summary>
                    /// Reserved for future use, Server mode ip
                    /// </summary>
                    public byte[] serverip = new byte[4];
                    /// <summary>
                    /// enable or disable DHCP
                    /// </summary>
                    public bool DHCPEnabled;
                    /// <summary>
                    /// Reserved for future use, Server mode port
                    /// </summary>
                    public ushort serverport;
                    /// <summary>
                    /// DHCP retry
                    /// </summary>
                    public byte DHCPRetry;
                    /// <summary>
                    /// Device name, user can change it.
                    /// </summary>
                    public string DeviceName;
                    /// <summary>
                    /// Mode discription
                    /// </summary>
                    public string Description;
                    /// <summary>
                    /// Connect Mode
                    /// </summary>        
                    public byte ConnectMode;
                    /// <summary>
                    /// Gateway check reset mode
                    /// </summary>
                    public int GatewayCheckResetMode;
            */
        }

        static private Windows.Devices.Enumeration.DeviceWatcher deviceWatcher;
	    static List<Windows.Devices.Enumeration.DeviceInformation> _deviceDB = new List<Windows.Devices.Enumeration.DeviceInformation>();

        static public event EventHandler<DeviceFinderArgs> OnSearchCompleted;

        static public void SearchDevice()
        {
            // Additional properties we would like about the device.
            // Property strings are documented here https://msdn.microsoft.com/en-us/library/windows/desktop/ff521659(v=vs.85).aspx
            string[] requestedProperties = { "System.Devices.Aep.DeviceAddress", "System.Devices.Aep.IsConnected", "System.Devices.Aep.Bluetooth.Le.IsConnectable", "System.Devices.Aep.AepId", "System.Devices.Aep.Category" };

            // BT_Code: Example showing paired and non-paired in a single query.
            string aqsAllBluetoothLEDevices = "(System.Devices.Aep.ProtocolId:=\"{bb7bb05e-5972-42b5-94fc-76eaa7084d49}\")";

            deviceWatcher =
                    DeviceInformation.CreateWatcher(
                        aqsAllBluetoothLEDevices,
                        requestedProperties,
                        DeviceInformationKind.AssociationEndpoint);

            // Register event handlers before starting the watcher.
            deviceWatcher.Added += DeviceWatcher_Added;
            deviceWatcher.Updated += DeviceWatcher_Updated;
            deviceWatcher.Removed += DeviceWatcher_Removed;
            deviceWatcher.EnumerationCompleted += DeviceWatcher_EnumerationCompleted;
            deviceWatcher.Stopped += DeviceWatcher_Stopped;

            // Start the watcher.
            deviceWatcher.Start();
        }


        static public void Stop()
        {
            /// <summary>
            /// Stops watching for all nearby Bluetooth devices.
            /// </summary>
            if (deviceWatcher != null)
            {
                // Unregister the event handlers.
                deviceWatcher.Added -= DeviceWatcher_Added;

                // Stop the watcher.
                deviceWatcher.Stop();
                deviceWatcher = null;
            }
        }

	    static public void ClearDeviceList()
	    {
		    _deviceDB.Clear ();
	    }

        static public DeviceInformation GetDeviceInformation(int id)
        {
            if (id < _deviceDB.Count)
                return _deviceDB[id];

            return null;
        }

        static public DeviceInformation GetDeviceInformation (string readername)
	    {
		    foreach (DeviceInformation item in _deviceDB)
		    {
			    if (item.Id == readername)
				    return item;
		    }

		    return null;		
	    }

	    static public List<DeviceInformation> GetAllDeviceInformation ()
	    {
		    return _deviceDB;
	    }

        static private async void DeviceWatcher_Added(DeviceWatcher sender, Windows.Devices.Enumeration.DeviceInformation deviceInfo)
        {
            Debug.WriteLine(String.Format("Added {0}{1}", deviceInfo.Id, deviceInfo.Name));

            // Protect against race condition if the task runs after the app stopped the deviceWatcher.
            if (sender == deviceWatcher)
            {
                CSLibrary.DeviceFinder.DeviceInfomation di = new CSLibrary.DeviceFinder.DeviceInfomation();
                di.deviceName = deviceInfo.Name;
                di.ID = (uint)_deviceDB.Count;
                di.nativeDeviceInformation = (object)deviceInfo;

                _deviceDB.Add(deviceInfo); 

                RaiseEvent<DeviceFinderArgs>(OnSearchCompleted, new DeviceFinderArgs(di));
            }
        }

        static private async void DeviceWatcher_Updated(DeviceWatcher sender, DeviceInformationUpdate deviceInfoUpdate)
        {
        }

        static private async void DeviceWatcher_Removed(DeviceWatcher sender, DeviceInformationUpdate deviceInfoUpdate)
        {
        }

        static private async void DeviceWatcher_EnumerationCompleted(DeviceWatcher sender, object e)
        {
        }

        static private async void DeviceWatcher_Stopped(DeviceWatcher sender, object e)
        {
        }

        static private void RaiseEvent<T>(EventHandler<T> eventHandler, T e)
            where T : EventArgs
        {
            if (eventHandler != null)
            {
                eventHandler(null, e);
            }
            return;
        }
    }

}

#endif
</file>

<file path="Library/CSLibrary/Source/HAL/Plugin.BLE/CodeFileBLE.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using Plugin.BLE.Abstractions;
using Plugin.BLE.Abstractions.Contracts;
using Plugin.BLE.Abstractions.EventArgs;

namespace CSLibrary
{
    using static RFIDDEVICE;
    using Constants;
    using System.Linq;

    public partial class HighLevelInterface
    {
        // for bluetooth Connection
        // for bluetooth Connectiond
        IAdapter _adapter;
        IDevice _device;
        IService _service;
        IService _serviceDeviceInfo;
        ICharacteristic _characteristicWrite;
        ICharacteristic _characteristicUpdate;
        ICharacteristic _characteristicDeviceInfoRead;
        MODEL _deviceType = MODEL.UNKNOWN;

        /// <summary>
        /// return error code
        /// </summary>
        /// <returns></returns>
        int BLE_Init()
        {
            return 0;
        }

        public async Task<bool> ConnectAsync(IAdapter adapter, IDevice device, MODEL deviceType)
        {
            if (_readerState != READERSTATE.DISCONNECT)
                return false; // reader can not reconnect

            this._deviceType = deviceType;

            try
            {
                switch (_deviceType)
                {
                    case MODEL.CS108:
                        _service = await device.GetServiceAsync(Guid.Parse("00009800-0000-1000-8000-00805f9b34fb"));
                        break;

                    case MODEL.CS710S:
                        await device.RequestMtuAsync(255); // for BLE 5.0
                        _service = await device.GetServiceAsync(Guid.Parse("00009802-0000-1000-8000-00805f9b34fb"));
                        break;
                }

                if (_service == null)
                    return false;

                _serviceDeviceInfo = await device.GetServiceAsync(Guid.Parse("0000180a-0000-1000-8000-00805f9b34fb"));
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Program execption error, please check!!! error message : " + ex.Message);
            }

            _readerState = READERSTATE.IDLE;

            _adapter = adapter;
            _device = device;

            _adapter.DeviceConnectionLost -= OnDeviceConnectionLost;
            _adapter.DeviceConnectionLost += OnDeviceConnectionLost;

            try
            {
                _characteristicWrite = await _service.GetCharacteristicAsync(Guid.Parse("00009900-0000-1000-8000-00805f9b34fb"));
                _characteristicUpdate = await _service.GetCharacteristicAsync(Guid.Parse("00009901-0000-1000-8000-00805f9b34fb"));
                _characteristicWrite = await _service.GetCharacteristicAsync(Guid.Parse("00009900-0000-1000-8000-00805f9b34fb"));

                if (_serviceDeviceInfo != null)
                {
                    _characteristicDeviceInfoRead = await _serviceDeviceInfo.GetCharacteristicAsync(Guid.Parse("00002a23-0000-1000-8000-00805f9b34fb"));

                    await _characteristicDeviceInfoRead.ReadAsync();
                    
                    if (_characteristicDeviceInfoRead?.Value.Count() == 8)
                    {
                        _MacAdd = _characteristicDeviceInfoRead?.Value[7].ToString("X2") +
                            _characteristicDeviceInfoRead?.Value[6].ToString("X2") +
                            _characteristicDeviceInfoRead?.Value[5].ToString("X2") +
                            _characteristicDeviceInfoRead?.Value[2].ToString("X2") +
                            _characteristicDeviceInfoRead?.Value[1].ToString("X2") +
                            _characteristicDeviceInfoRead?.Value[0].ToString("X2");
                            ;

                        //CSLibrary.Debug.WriteLine("BLE Mac Addres : " + _MacAdd);
                    }
                }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("Can not set characters");
            }

            _characteristicUpdate.ValueUpdated -= BLE_Recv;
            _characteristicUpdate.ValueUpdated += BLE_Recv;
            //            _characteristicWrite.ValueUpdated += CharacteristicOnWriteUpdated;

            //CSLibraryv4: wait for new ble library compatibility
            BTTimer = new Timer(TimerFunc, this, 0, 1000);

            await _characteristicUpdate.StartUpdatesAsync();
            //            await _characteristicWrite.StartUpdatesAsync();

            _readerState = READERSTATE.IDLE;
            BTTimer = new Timer(TimerFunc, this, 0, 1000);

            HardwareInit();

            return true;
        }

        public async Task<bool> DisconnectAsync()
        {
            try
            {
                if (Status != READERSTATE.IDLE)
                    return false;

                if (_readerState != READERSTATE.DISCONNECT)
                {
                    BARCODEPowerOff();
                    //CSLibraryv4: clear connection without waiting for BLE readiness
                    //WhenBLEFinish(ClearConnection);
                    await ClearConnection();
                }
                else
                {
                    await ClearConnection();
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Disconnect error " + ex.Message.ToString());
            }

            return true;
        }

        /// <summary>
        /// return error code
        /// </summary>
        /// <returns></returns>
        private async Task<int> BLE_Send (byte[] data)
        {
            return await _characteristicWrite.WriteAsync(data);
        }

        private async void BLE_Recv(object sender, CharacteristicUpdatedEventArgs characteristicUpdatedEventArgs)
        {
            try
            {
                byte[] data = characteristicUpdatedEventArgs.Characteristic.Value;
                if (data == null)
                    return;
 
                CSLibrary.Debug.WriteBytes("BT data received", data);
                CharacteristicOnValueUpdated(data);
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Program execption error, please check!!! error message : " + ex.Message);
            }
        }

        private void CharacteristicOnWriteUpdated(object sender, CharacteristicUpdatedEventArgs characteristicUpdatedEventArgs)
        {
            CSLibrary.Debug.WriteBytes("BT: Write data success updated", characteristicUpdatedEventArgs.Characteristic.Value);
        }

        private void OnStateChanged(object sender, BluetoothStateChangedArgs e)
        {
        }

        private void OnDeviceConnectionLost(object sender, DeviceErrorEventArgs e)
        {
            if (e.Device.Id == _device.Id)
            {
                //DisconnectAsync();
                ConnectLostAsync();
            }
        }

        public async void ConnectLostAsync()
        {
            _readerState = READERSTATE.READYFORDISCONNECT;

            _characteristicUpdate.ValueUpdated -= BLE_Recv;
            _adapter.DeviceConnectionLost -= OnDeviceConnectionLost;

            _characteristicUpdate = null;
            _characteristicWrite = null;
            _service = null;

            try
            {

                if (_device.State == DeviceState.Connected)
                {
                    await _adapter.DisconnectDeviceAsync(_device);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Program execption error, please check!!! error message : " + ex.Message);
            }
            _device = null;

            _readerState = READERSTATE.DISCONNECT;

            FireReaderStateChangedEvent(new Events.OnReaderStateChangedEventArgs(null, Constants.ReaderCallbackType.CONNECTION_LOST));
        }

        async Task ClearConnection()
        {
            _readerState = READERSTATE.READYFORDISCONNECT;
            // Stop Timer;
            await _characteristicUpdate.StopUpdatesAsync();

            _characteristicUpdate.ValueUpdated -= BLE_Recv;
            _adapter.DeviceConnectionLost -= OnDeviceConnectionLost;

            _characteristicUpdate = null;
            _characteristicWrite = null;
            _service = null;

            try
            {
                if (_device.State == DeviceState.Connected)
                {
                    await _adapter.DisconnectDeviceAsync(_device);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Program execption error, please check!!! error message : " + ex.Message);
            }
            _device = null;

            _readerState = READERSTATE.DISCONNECT;
        }

    }
}
</file>

<file path="Library/CSLibrary/Source/HAL/Plugin.BLE/MvvmCross.Plugin.BLE/ClassDebug.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;

namespace CSLibrary
{
    public static class Debug
    {
        public static void WriteBytes(string header, byte[] data)
        {
            string str = "";
            for (int cnt = 0; cnt < data.Length; cnt++)
                str += data[cnt].ToString("X2") + " ";
            WriteLine ("CSLibrary : " + header + " {0}:{1}", data.Length, str);
        }

        public static void WriteLine(string format, params object[] args)
        {
            Console.WriteLine(string.Format(format, args));
            //Plugin.BLE.Abstractions.Trace.Message(string.Format(format, args));
        }

        public static void Write(string format, params object[] args)
        {
            Console.Write(string.Format(format, args));
            //Plugin.BLE.Abstractions.Trace.Message(string.Format(format, args));
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/HAL/Plugin.BLE/MvvmCross.Plugin.BLE/ClassDeviceFinder.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#if __MwwmCrossPluginBLE

using System;
using System.Collections.Generic;

using Plugin.BLE.Abstractions;
using Plugin.BLE.Abstractions.Contracts;
using Plugin.BLE.Abstractions.EventArgs;

namespace CSLibrary
{
    public partial class DeviceFinder
    {
        /// <summary>
        /// DeviceFinder Argument
        /// </summary>
        public class DeviceFinderArgs : EventArgs
        {
            private DeviceInfomation _data;

            /// <summary>
            /// Device Finder 
            /// </summary>
            /// <param name="data"></param>
            public DeviceFinderArgs(DeviceInfomation data)
            {
                _data = data;
            }

            /// <summary>
            /// Device finder information
            /// </summary>
            public DeviceInfomation Found
            {
                get { return _data; }
                set { _data = value; }
            }
        }

        /// <summary>
        /// Netfinder information return from device
        /// </summary>
        public class DeviceInfomation
        {
            public uint ID;

            public string deviceName;

            public object nativeDeviceInformation;

            /*
                    /// <summary>
                    /// Reserved for future use
                    /// </summary>
                    public Mode Mode = Mode.Unknown; 
                    /// <summary>
                    /// Total time on network
                    /// </summary>
                    public TimeEvent TimeElapsedNetwork = new TimeEvent();
                    /// <summary>
                    /// Total Power on time
                    /// </summary>
                    public TimeEvent TimeElapsedPowerOn = new TimeEvent();
                    /// <summary>
                    /// MAC address
                    /// </summary>
                    public MAC MACAddress = new MAC();//[6];
                    /// <summary>
                    /// IP address
                    /// </summary>
                    public IP IPAddress = new IP();
                    /// <summary>
                    /// Subnet Mask
                    /// </summary>
                    public IP SubnetMask = new IP();
                    /// <summary>
                    /// Gateway
                    /// </summary>
                    public IP Gateway = new IP();
                    /// <summary>
                    /// Trusted hist IP
                    /// </summary>
                    public IP TrustedServer = new IP();
                    /// <summary>
                    /// Inducated trusted server enable or not.
                    /// </summary>
                    public Boolean TrustedServerEnabled = false;
                    /// <summary>
                    /// UDP Port
                    /// </summary>
                    public ushort Port; // Get port from UDP header
                    /// <summary>
                    /// Reserved for future use, Server mode ip
                    /// </summary>
                    public byte[] serverip = new byte[4];
                    /// <summary>
                    /// enable or disable DHCP
                    /// </summary>
                    public bool DHCPEnabled;
                    /// <summary>
                    /// Reserved for future use, Server mode port
                    /// </summary>
                    public ushort serverport;
                    /// <summary>
                    /// DHCP retry
                    /// </summary>
                    public byte DHCPRetry;
                    /// <summary>
                    /// Device name, user can change it.
                    /// </summary>
                    public string DeviceName;
                    /// <summary>
                    /// Mode discription
                    /// </summary>
                    public string Description;
                    /// <summary>
                    /// Connect Mode
                    /// </summary>        
                    public byte ConnectMode;
                    /// <summary>
                    /// Gateway check reset mode
                    /// </summary>
                    public int GatewayCheckResetMode;
            */
        }

        static private Windows.Devices.Enumeration.DeviceWatcher deviceWatcher;
	    static List<Windows.Devices.Enumeration.DeviceInformation> _deviceDB = new List<Windows.Devices.Enumeration.DeviceInformation>();

        static public event EventHandler<DeviceFinderArgs> OnSearchCompleted;

        static public void SearchDevice()
        {
            // Additional properties we would like about the device.
            // Property strings are documented here https://msdn.microsoft.com/en-us/library/windows/desktop/ff521659(v=vs.85).aspx
            string[] requestedProperties = { "System.Devices.Aep.DeviceAddress", "System.Devices.Aep.IsConnected", "System.Devices.Aep.Bluetooth.Le.IsConnectable", "System.Devices.Aep.AepId", "System.Devices.Aep.Category" };

            // BT_Code: Example showing paired and non-paired in a single query.
            string aqsAllBluetoothLEDevices = "(System.Devices.Aep.ProtocolId:=\"{bb7bb05e-5972-42b5-94fc-76eaa7084d49}\")";

            deviceWatcher =
                    DeviceInformation.CreateWatcher(
                        aqsAllBluetoothLEDevices,
                        requestedProperties,
                        DeviceInformationKind.AssociationEndpoint);

            // Register event handlers before starting the watcher.
            deviceWatcher.Added += DeviceWatcher_Added;
            deviceWatcher.Updated += DeviceWatcher_Updated;
            deviceWatcher.Removed += DeviceWatcher_Removed;
            deviceWatcher.EnumerationCompleted += DeviceWatcher_EnumerationCompleted;
            deviceWatcher.Stopped += DeviceWatcher_Stopped;

            // Start the watcher.
            deviceWatcher.Start();
        }


        static public void Stop()
        {
            /// <summary>
            /// Stops watching for all nearby Bluetooth devices.
            /// </summary>
            if (deviceWatcher != null)
            {
                // Unregister the event handlers.
                deviceWatcher.Added -= DeviceWatcher_Added;

                // Stop the watcher.
                deviceWatcher.Stop();
                deviceWatcher = null;
            }
        }

	    static public void ClearDeviceList()
	    {
		    _deviceDB.Clear ();
	    }

        static public DeviceInformation GetDeviceInformation(int id)
        {
            if (id < _deviceDB.Count)
                return _deviceDB[id];

            return null;
        }

        static public DeviceInformation GetDeviceInformation (string readername)
	    {
		    foreach (DeviceInformation item in _deviceDB)
		    {
			    if (item.Id == readername)
				    return item;
		    }

		    return null;		
	    }

	    static public List<DeviceInformation> GetAllDeviceInformation ()
	    {
		    return _deviceDB;
	    }

        static private async void DeviceWatcher_Added(DeviceWatcher sender, Windows.Devices.Enumeration.DeviceInformation deviceInfo)
        {
            Debug.WriteLine(String.Format("Added {0}{1}", deviceInfo.Id, deviceInfo.Name));

            // Protect against race condition if the task runs after the app stopped the deviceWatcher.
            if (sender == deviceWatcher)
            {
                CSLibrary.DeviceFinder.DeviceInfomation di = new CSLibrary.DeviceFinder.DeviceInfomation();
                di.deviceName = deviceInfo.Name;
                di.ID = (uint)_deviceDB.Count;
                di.nativeDeviceInformation = (object)deviceInfo;

                _deviceDB.Add(deviceInfo); 

                RaiseEvent<DeviceFinderArgs>(OnSearchCompleted, new DeviceFinderArgs(di));
            }
        }

        static private async void DeviceWatcher_Updated(DeviceWatcher sender, DeviceInformationUpdate deviceInfoUpdate)
        {
        }

        static private async void DeviceWatcher_Removed(DeviceWatcher sender, DeviceInformationUpdate deviceInfoUpdate)
        {
        }

        static private async void DeviceWatcher_EnumerationCompleted(DeviceWatcher sender, object e)
        {
        }

        static private async void DeviceWatcher_Stopped(DeviceWatcher sender, object e)
        {
        }

        static private void RaiseEvent<T>(EventHandler<T> eventHandler, T e)
            where T : EventArgs
        {
            if (eventHandler != null)
            {
                eventHandler(null, e);
            }
            return;
        }
    }

}

#endif
</file>

<file path="Library/CSLibrary/Source/HAL/Plugin.BLE/MvvmCross.Plugin.BLE/CodeFileBLE.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using Plugin.BLE.Abstractions;
using Plugin.BLE.Abstractions.Contracts;
using Plugin.BLE.Abstractions.EventArgs;

namespace CSLibrary
{
    using static RFIDDEVICE;
    using Constants;
    using System.Linq;
    using System.Threading;

    public partial class HighLevelInterface
    {
        // for bluetooth Connection
        // for bluetooth Connectiond
        IAdapter _adapter;
        IDevice _device;
        IService _service;
        IService _serviceDeviceInfo;
        ICharacteristic _characteristicWrite;
        ICharacteristic _characteristicUpdate;
        ICharacteristic _characteristicDeviceInfoRead;
        MODEL _deviceType = MODEL.UNKNOWN;

        /// <summary>
        /// return error code
        /// </summary>
        /// <returns></returns>
        int BLE_Init()
        {
            return 0;
        }

        public async Task<bool> ConnectAsync(IAdapter adapter, IDevice device, MODEL deviceType)
        {
            if (_readerState != READERSTATE.DISCONNECT)
                return false; // reader can not reconnect

            this._deviceType = deviceType;

            try
            {
                switch (_deviceType)
                {
                    case MODEL.CS108:
                        _service = await device.GetServiceAsync(Guid.Parse("00009800-0000-1000-8000-00805f9b34fb"));
                        break;

                    case MODEL.CS710S:
                        await device.RequestMtuAsync(255); // for BLE 5.0
                        _service = await device.GetServiceAsync(Guid.Parse("00009802-0000-1000-8000-00805f9b34fb"));
                        break;
                }

                if (_service == null)
                    return false;

                _serviceDeviceInfo = await device.GetServiceAsync(Guid.Parse("0000180a-0000-1000-8000-00805f9b34fb"));
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Program execption error, please check ConnectAsync!!! error message : " + ex.Message);
            }

            _readerState = READERSTATE.IDLE;

            _adapter = adapter;
            _device = device;

            _adapter.DeviceConnectionLost -= OnDeviceConnectionLost;
            _adapter.DeviceConnectionLost += OnDeviceConnectionLost;

            try
            {
                _characteristicWrite = await _service.GetCharacteristicAsync(Guid.Parse("00009900-0000-1000-8000-00805f9b34fb"));
                _characteristicUpdate = await _service.GetCharacteristicAsync(Guid.Parse("00009901-0000-1000-8000-00805f9b34fb"));
                _characteristicWrite = await _service.GetCharacteristicAsync(Guid.Parse("00009900-0000-1000-8000-00805f9b34fb"));

                if (_serviceDeviceInfo != null)
                {
                    _characteristicDeviceInfoRead = await _serviceDeviceInfo.GetCharacteristicAsync(Guid.Parse("00002a23-0000-1000-8000-00805f9b34fb"));

                    await _characteristicDeviceInfoRead.ReadAsync();
                    
                    if (_characteristicDeviceInfoRead?.Value.Count() == 8)
                    {
                        _MacAdd = _characteristicDeviceInfoRead?.Value[7].ToString("X2") +
                            _characteristicDeviceInfoRead?.Value[6].ToString("X2") +
                            _characteristicDeviceInfoRead?.Value[5].ToString("X2") +
                            _characteristicDeviceInfoRead?.Value[2].ToString("X2") +
                            _characteristicDeviceInfoRead?.Value[1].ToString("X2") +
                            _characteristicDeviceInfoRead?.Value[0].ToString("X2");
                            ;

                        //CSLibrary.Debug.WriteLine("BLE Mac Addres : " + _MacAdd);
                    }
                }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("Can not set characters");
            }

            _characteristicUpdate.ValueUpdated -= BLE_Recv;
            _characteristicUpdate.ValueUpdated += BLE_Recv;
            //            _characteristicWrite.ValueUpdated += CharacteristicOnWriteUpdated;

            //CSLibraryv4: wait for new ble library compatibility
            BTTimer = new Timer(TimerFunc, this, 0, 1000);

            await _characteristicUpdate.StartUpdatesAsync();
            //            await _characteristicWrite.StartUpdatesAsync();

            _readerState = READERSTATE.IDLE;
            BTTimer = new Timer(TimerFunc, this, 0, 1000);

            HardwareInit();

            return true;
        }

        public async Task<bool> DisconnectAsync()
        {
            try
            {
                if (Status != READERSTATE.IDLE)
                    return false;

                if (_readerState != READERSTATE.DISCONNECT)
                {
                    BARCODEPowerOff();
                    RFIDPowerOff();
                    while (BLEBusy)
                        await Task.Delay(500);
                    //CSLibraryv4: clear connection without waiting for BLE readiness
                    //WhenBLEFinish(ClearConnection);
                    await ClearConnection();
                }
                else
                {
                    await ClearConnection();
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Disconnect error " + ex.Message.ToString());
            }

            _handlerRFIDReader.Disconnect();
            return true;
        }

        /// <summary>
        /// return error code
        /// </summary>
        /// <returns></returns>
        private async Task<bool> BLE_Send (byte[] data)
        {
            return await _characteristicWrite.WriteAsync(data);
        }

        private async void BLE_Recv(object sender, CharacteristicUpdatedEventArgs characteristicUpdatedEventArgs)
        {
            try
            {
                byte[] data = characteristicUpdatedEventArgs.Characteristic.Value;
                if (data == null)
                    return;
 
                CSLibrary.Debug.WriteBytes("BT data received", data);
                CharacteristicOnValueUpdated(data);
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Program execption error, please check BLE_Recv!!! error message : " + ex.Message);
            }
        }

        private void CharacteristicOnWriteUpdated(object sender, CharacteristicUpdatedEventArgs characteristicUpdatedEventArgs)
        {
            CSLibrary.Debug.WriteBytes("BT: Write data success updated", characteristicUpdatedEventArgs.Characteristic.Value);
        }

        private void OnStateChanged(object sender, BluetoothStateChangedArgs e)
        {
        }

        private void OnDeviceConnectionLost(object sender, DeviceErrorEventArgs e)
        {
            if (e.Device.Id == _device.Id)
            {
                //DisconnectAsync();
                ConnectLostAsync();
            }
        }

        public async void ConnectLostAsync()
        {
            _readerState = READERSTATE.READYFORDISCONNECT;

            _characteristicUpdate.ValueUpdated -= BLE_Recv;
            _adapter.DeviceConnectionLost -= OnDeviceConnectionLost;

            _characteristicUpdate = null;
            _characteristicWrite = null;
            _service = null;

            try
            {

                if (_device.State == DeviceState.Connected)
                {
                    await _adapter.DisconnectDeviceAsync(_device);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Program execption error, please check ConnectLostAsync!!! error message : " + ex.Message);
            }
            _device = null;

            _readerState = READERSTATE.DISCONNECT;

            FireReaderStateChangedEvent(new Events.OnReaderStateChangedEventArgs(null, Constants.ReaderCallbackType.CONNECTION_LOST));
        }

        async Task ClearConnection()
        {
            _readerState = READERSTATE.READYFORDISCONNECT;
            // Stop Timer;
            await _characteristicUpdate.StopUpdatesAsync();

            _characteristicUpdate.ValueUpdated -= BLE_Recv;
            _adapter.DeviceConnectionLost -= OnDeviceConnectionLost;

            _characteristicUpdate = null;
            _characteristicWrite = null;
            _service = null;

            try
            {
                if (_device.State == DeviceState.Connected)
                {
                    await _adapter.DisconnectDeviceAsync(_device);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Program execption error, please check ClearConnection!!! error message : " + ex.Message);
            }
            _device = null;

            _readerState = READERSTATE.DISCONNECT;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/Notification/ClassNotification.cs">
using System;

using CSLibrary.Barcode;
using CSLibrary.Barcode.Constants;
using CSLibrary.Barcode.Structures;

namespace CSLibrary
{
    public partial class Notification
    {
        bool _currentAutoReportStatus = false;
        uint _batteryLevel = 0;

        // RFID event code
        private class DOWNLINKCMD
        {
            public static readonly byte[] GETVOLTAGE = { 0xA0, 0x00 };
            public static readonly byte[] GETTRIGGERSTATE = { 0xA0, 0x01 };
            public static readonly byte[] STARTAUTOREPORTING = { 0xA0, 0x02 };
            public static readonly byte[] STOPAUTOREPORTING = { 0xA0, 0x03 };
            public static readonly byte[] RFIDABORT = { 0xA0, 0x04 };
            public static readonly byte[] GETTRIGGER = { 0xA0, 0x05 };
            public static readonly byte[] SETFASTMODE = { 0xA0, 0x06 };
            public static readonly byte[] GETFASTMODE = { 0xA0, 0x07 };
            public static readonly byte[] STARTAUTOREIGGERREPORTING = { 0xA0, 0x08 };
            public static readonly byte[] STOPAUTOREIGGERREPORTING = { 0xA0, 0x09 };
        }

        private HighLevelInterface _deviceHandler;

        /// <summary>
        /// HotKey Event Argument
        /// </summary>
        public class HotKeyEventArgs : EventArgs
        {
            Key m_KeyCode = Key.BUTTON;
            bool m_KeyDown = false;

            public Key KeyCode { get { return m_KeyCode; } }
            public bool KeyDown { get { return m_KeyDown; } }

            public HotKeyEventArgs(Key KeyCode, bool KeyDown)
            {
                m_KeyCode = KeyCode;
                m_KeyDown = KeyDown;
            }
        }

        public class VoltageEventArgs : EventArgs
        {
            uint m_Voltage = 0;

            public uint Voltage { get { return m_Voltage; } }

            public VoltageEventArgs(uint voltage)
            {
                m_Voltage = voltage;
            }
        }

        public event EventHandler<VoltageEventArgs> OnVoltageEvent;
        public event EventHandler<HotKeyEventArgs> OnKeyEvent;

        /// <summary>
        /// Current Supported Virtual Key
        /// </summary>
        public enum Key : uint
        {
            /// <summary>
            /// Button
            /// </summary>
            BUTTON,
        }

        internal Notification(HighLevelInterface handler)
        {
            _deviceHandler = handler;
        }

        internal void SetAutoReport(bool OnOff)
        {
            if (OnOff)
            {
//                if (!_currentAutoReportStatus)
                {
                    _deviceHandler.SendAsync(0, 2, DOWNLINKCMD.STARTAUTOREPORTING, null, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
                    _currentAutoReportStatus = true;
                }
            }
            else
            {
  //              if (_currentAutoReportStatus)
                {
                    _deviceHandler.SendAsync(0, 2, DOWNLINKCMD.STOPAUTOREPORTING, null, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
                    _currentAutoReportStatus = false;
                }
            }
        }

        internal void SetAutoTriggerReport(byte sec) // 0 = off
        {
            if (sec > 0)
            {
                {
                    _deviceHandler.SendAsync(0, 2, DOWNLINKCMD.STARTAUTOREIGGERREPORTING, new byte[1] { sec }, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
                    _currentAutoReportStatus = true;
                }
            }
            else
            {
                {
                    _deviceHandler.SendAsync(0, 2, DOWNLINKCMD.STOPAUTOREIGGERREPORTING, null, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
                    _currentAutoReportStatus = false;
                }
            }
        }


        public static readonly byte[] STARTAUTOREIGGERREPORTING = { 0xA0, 0x08 };
        public static readonly byte[] STOPAUTOREIGGERREPORTING = { 0xA0, 0x09 };



        internal void GetCurrentBatteryVoltage()
        {
            _deviceHandler.SendAsync(0, 2, DOWNLINKCMD.GETVOLTAGE, null, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.NOWAIT);
        }


        internal void DeviceRecvVoltage(uint voltagemV)
        {
            _batteryLevel = voltagemV;

            if (OnVoltageEvent == null)
                return;

            OnVoltageEvent(_deviceHandler, new Notification.VoltageEventArgs(voltagemV));
        }

        bool _receiveOffWithin1s = false;
        bool _receiveOnWithinOffcycle = false;

        internal void DeviceRecvState(int value)
        {
            if (OnKeyEvent == null)
                return;

            try
            {
                switch (value)
                {
                    case 0: // button on
                        OnKeyEvent(_deviceHandler, new Notification.HotKeyEventArgs(Key.BUTTON, true));
                        break;

                    case 1: // button off
                        OnKeyEvent(_deviceHandler, new Notification.HotKeyEventArgs(Key.BUTTON, false));
                        break;
                }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("DeviceRecvState Error : " + ex.Message);
            }
        }

        public uint GetCurrentBatteryLevel()
        {
            return _batteryLevel;
        }

        public void ClearEventHandler()
        {
            //OnVoltageEvent = delegate { };
            //OnKeyEvent = delegate { };
            OnVoltageEvent = null;
            OnKeyEvent = null;
        }

    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/Comm_Protocol/Ex10Commands/ClassRFID.AdministrationCommands.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Text;

namespace CSLibrary
{
    public partial class RFIDReader
    {

#if nouse


        internal enum RFIDPACKETCODE
        {
            csl_tag_read_epc_only_new = 0x3001,
            csl_tag_read_epc_only_recurrent = 0x3002,
            csl_tag_read_multibank_new = 0x3003,
            csl_tag_read_multibank_recurrent_index_only = 0x3004,
            csl_tag_read_compact = 0x3006,
            csl_miscellaneous_event = 0x3007,
            csl_operation_complete = 0x3008,
            csl_access_complete = 0x3009,
        }


        internal void UplinkPacketsProcess (byte[] data)
        {
            RFIDPACKETCODE packetCode = 0;
            int index = 0;


            switch (packetCode)
            {
                case RFIDPACKETCODE.csl_tag_read_epc_only_new:
                    TagReadEPCOnlyNew(index, data);
                    break;

                case RFIDPACKETCODE.csl_tag_read_epc_only_recurrent:
                    TagReadEPCOnlyRecurrent(index, data);
                    break;

                case RFIDPACKETCODE.csl_tag_read_multibank_new:
                    TagReadMultiBankNew(index, data);
                    break;

                case RFIDPACKETCODE.csl_tag_read_multibank_recurrent_index_only:
                    TagReadMultiBankRecurrentIndexOnly(index, data);
                    break;

                case RFIDPACKETCODE.csl_tag_read_compact:
                    TagReadCompact(index, data);
                    break;

                case RFIDPACKETCODE.csl_miscellaneous_event:
                    MiscellaneousEvent(index, data);
                    break;

                case RFIDPACKETCODE.csl_operation_complete:
                    OperationComplete(index, data);
                    break;

                case RFIDPACKETCODE.csl_access_complete:
                    AccessComplete(index, data);
                    break;
            }
        }

        internal void TagReadEPCOnlyNew(int index, byte[] data)
        {
            UInt32 UTCTimpStamp = BitConverter.ToUInt32(data, index);
            UInt16 RSSI = BitConverter.ToUInt16(data, index);
            UInt16 rf_phase_begin = BitConverter.ToUInt16(data, index);
            UInt16 rf_phase_end = BitConverter.ToUInt16(data, index);
            byte PortNumber = data[index];
            UInt16 TagIndex = BitConverter.ToUInt16(data, index);
            byte[] TagData;


        }

        internal void TagReadEPCOnlyRecurrent(int index, byte[] data)
        {
            UInt32 UTCTimpStamp = BitConverter.ToUInt32(data, index);
            UInt16 RSSI = BitConverter.ToUInt16(data, index);
            UInt16 rf_phase_begin = BitConverter.ToUInt16(data, index);
            UInt16 rf_phase_end = BitConverter.ToUInt16(data, index);
            byte PortNumber = data[index];
            UInt16 TagIndex = BitConverter.ToUInt16(data, index);
        }

        internal void TagReadMultiBankNew(int index, byte[] data)
        {
            UInt32 UTCTimpStamp = BitConverter.ToUInt32(data, index);
            UInt16 RSSI = BitConverter.ToUInt16(data, index);
            UInt16 rf_phase_begin = BitConverter.ToUInt16(data, index);
            UInt16 rf_phase_end = BitConverter.ToUInt16(data, index);
            byte PortNumber = data[index];
            UInt16 TagIndex = BitConverter.ToUInt16(data, index);
            byte[] EPCBankData;
            byte NumberofExtraBanks;
            byte[] ExtraBankIndex;
        }

        internal void TagReadMultiBankRecurrentIndexOnly(int index, byte[] data)
        {
            UInt32 UTCTimpStamp = BitConverter.ToUInt32(data, index);
            UInt16 RSSI = BitConverter.ToUInt16(data, index);
            UInt16 rf_phase_begin = BitConverter.ToUInt16(data, index);
            UInt16 rf_phase_end = BitConverter.ToUInt16(data, index);
            byte PortNumber = data[index];
            UInt16 TagIndex = BitConverter.ToUInt16(data, index);
        }

        internal void TagReadCompact(int index, byte[] data)
        {
            UInt32 UTCTimpStamp = BitConverter.ToUInt32(data, index);
            byte [] TagData;
        }

        internal void MiscellaneousEvent(int index, byte[] data)
        {
            UInt32 UTCTimpStamp = BitConverter.ToUInt32(data, index);
            UInt16 EventCode = BitConverter.ToUInt32(data, index);
            byte[] Data;
        }

        internal void OperationComplete(int index, byte[] data)
        {
            UInt32 UTCTimpStamp = BitConverter.ToUInt32(data, index);
            UInt16 CommandCode = BitConverter.ToUInt32(data, index);
            UInt16 Status;
        }

        internal void AccessComplete(int index, byte[] data)
        {
            UInt32 UTCTimpStamp = BitConverter.ToUInt32(data, index);
            UInt16 AccessCommand = BitConverter.ToUInt16(data, index);
            byte TagErrorCode;
            byte MacErrorCode;
            UInt16 WriteWordCount;
            byte[] Data;
        }
#endif

    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/Comm_Protocol/Ex10Commands/ClassRFID.OperationCommands.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Reflection;
using System.Text;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        internal enum SCSLRFIDCMD
        {
            SCSLRFIDStartSimpleInventory = 0x10A1,
            SCSLRFIDStartCompactInventory = 0x10A2,
            SCSLRFIDStartSelectInventory = 0x10A3,
            SCSLRFIDStartMBInventory = 0x10A4,
            SCSLRFIDStartSelectMBInventory = 0x10A5,
            SCSLRFIDStartSelectCompactInventory = 0x10A6,
            SCSLRFIDStopOperation = 0x10AE,
            SCSLRFIDReadMB = 0x10B1,
            SCSLRFIDWriteMB = 0x10B2,
            SCSLRFIDWriteMBAny = 0x10B3,
            SCSLRFIDBlockWriteMB = 0x10B5,
            SCSLRFIDBlockWriteMBAny = 0x10B6,
            SCSLRFIDLock = 0x10B7,
            SCSLRFIDKill = 0x10B8,
            SCSLRFIDAuthenticate = 0x10B9,
            SCSLClearTagCacheTable = 0x10D3,
            SCSLUploadTagCacheTableToHost = 0x10D4,
            SCSLRFIDRegisterReset = 0x10D5,
            SCSLEx10Reset = 0x10D6,
            SCSLRFIDCircuitReset = 0x10D7,
            SCSLReadRegister = 0x1471,
            SCSLWriteRegister = 0x9a06,
        }

        byte[] RfidCmdpack1(SCSLRFIDCMD cmd, byte[] payload)
        {
            byte[] datapacket = new byte[4 + payload.Length];

            datapacket[0] = 0x80;
            datapacket[1] = 0xb3;
            datapacket[2] = (byte)((int)cmd >> 8);
            datapacket[3] = (byte)cmd;

            if (payload.Length > 0)
                Array.Copy(payload, 0, datapacket, 4, payload.Length);

            return datapacket;
        }

/*        internal void RunShortOperation(SCSLRFIDCMD cmd)
        {
            byte[] payload = new byte[3];

            byte[] datapacket = RfidCmdpack1(cmd, payload);
            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, datapacket, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.ENDEVENTUPLINKPACKET, (uint)CurrentOperation);
        }
*/

        internal void RunShortOperation(SCSLRFIDCMD cmd, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE responseCode = HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE)
        {
            byte[] payload = new byte[3];

            payload[0] = _SequencedNumber++;
            byte[] datapacket = RfidCmdpack1(cmd, payload);
            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, datapacket, responseCode, (uint)CurrentOperation);
        }

        internal void RFIDStartSimpleInventory()
        {
            for (int index = 0; index < 3; index++)
                RFIDRegister.MultibankReadConfig.Enable((byte)index, false);

            RunShortOperation(SCSLRFIDCMD.SCSLRFIDStartSimpleInventory);
        }

        internal void RFIDStartCompactInventory()
        {
            for (int index = 0; index < 3; index++)
                RFIDRegister.MultibankReadConfig.Enable((byte)index, false);

            RunShortOperation(SCSLRFIDCMD.SCSLRFIDStartCompactInventory);
        }

        internal void RFIDStartSelectInventory()
        {
            for (int index = 0; index < 3; index++)
                RFIDRegister.MultibankReadConfig.Enable((byte)index, false);

            RunShortOperation(SCSLRFIDCMD.SCSLRFIDStartSelectInventory);
        }

        internal void RFIDStartMBInventory()
        {
            int index = 0;

            m_rdr_opt_parms.TagRanging.multibankswithreply = m_rdr_opt_parms.TagRanging.multibanks;
            if (m_rdr_opt_parms.TagRanging.multibanks > 0)
            {
                RFIDRegister.MultibankReadConfig.Set(0, true, (int)m_rdr_opt_parms.TagRanging.bank1, m_rdr_opt_parms.TagRanging.offset1, m_rdr_opt_parms.TagRanging.count1);
                if (m_rdr_opt_parms.TagRanging.multibanks > 1)
                    RFIDRegister.MultibankReadConfig.Set(1, true, (int)m_rdr_opt_parms.TagRanging.bank2, m_rdr_opt_parms.TagRanging.offset2, m_rdr_opt_parms.TagRanging.count2);
                if (m_rdr_opt_parms.TagRanging.multibanks > 2)
                    RFIDRegister.MultibankReadConfig.Set(2, true, (int)m_rdr_opt_parms.TagRanging.bank3, m_rdr_opt_parms.TagRanging.offset3, m_rdr_opt_parms.TagRanging.count3);
                index = (int)m_rdr_opt_parms.TagRanging.multibanks;
            }

            for (;index < 3; index ++)
                RFIDRegister.MultibankReadConfig.Enable((byte)index, false);

            RunShortOperation(SCSLRFIDCMD.SCSLRFIDStartMBInventory);
        }

        internal void RFIDStartSelectMBInventory()
        {
            int index = 0;

            m_rdr_opt_parms.TagRanging.multibankswithreply = m_rdr_opt_parms.TagRanging.multibanks;
            if (m_rdr_opt_parms.TagRanging.multibanks > 0)
            {
                RFIDRegister.MultibankReadConfig.Set(0, true, (int)m_rdr_opt_parms.TagRanging.bank1, m_rdr_opt_parms.TagRanging.offset1, m_rdr_opt_parms.TagRanging.count1);
                if (m_rdr_opt_parms.TagRanging.multibanks > 1)
                    RFIDRegister.MultibankReadConfig.Set(1, true, (int)m_rdr_opt_parms.TagRanging.bank2, m_rdr_opt_parms.TagRanging.offset2, m_rdr_opt_parms.TagRanging.count2);
                if (m_rdr_opt_parms.TagRanging.multibanks > 2)
                    RFIDRegister.MultibankReadConfig.Set(2, true, (int)m_rdr_opt_parms.TagRanging.bank3, m_rdr_opt_parms.TagRanging.offset3, m_rdr_opt_parms.TagRanging.count3);
                index = (int)m_rdr_opt_parms.TagRanging.multibanks;
            }

            for (; index < 3; index++)
                RFIDRegister.MultibankReadConfig.Enable((byte)index, false);

            RunShortOperation(SCSLRFIDCMD.SCSLRFIDStartSelectMBInventory);
        }

        internal void RFIDStartKilowayMBInventory()
        {
            int index = 0;

            m_rdr_opt_parms.TagRanging.multibankswithreply = m_rdr_opt_parms.TagRanging.multibanks;
            if (m_rdr_opt_parms.TagRanging.multibanks > 0)
            {
                RFIDRegister.MultibankReadConfig.Set(0, true, (int)m_rdr_opt_parms.TagRanging.bank1, m_rdr_opt_parms.TagRanging.offset1, m_rdr_opt_parms.TagRanging.count1);
                if (m_rdr_opt_parms.TagRanging.bank1 == CSLibrary.Constants.MemoryBank.BANK0 && m_rdr_opt_parms.TagRanging.offset1 == 4 && m_rdr_opt_parms.TagRanging.count1 == 1)
                {
                    RFIDRegister.MultibankReadConfig.SetNoReply(0);
                    m_rdr_opt_parms.TagRanging.multibankswithreply--;
                }

                if (m_rdr_opt_parms.TagRanging.multibanks > 1)
                {
                    RFIDRegister.MultibankReadConfig.Set(1, true, (int)m_rdr_opt_parms.TagRanging.bank2, m_rdr_opt_parms.TagRanging.offset2, m_rdr_opt_parms.TagRanging.count2);
                    if (m_rdr_opt_parms.TagRanging.bank2 == CSLibrary.Constants.MemoryBank.BANK0 && m_rdr_opt_parms.TagRanging.offset2 == 4 && m_rdr_opt_parms.TagRanging.count2 == 1)
                    {
                        RFIDRegister.MultibankReadConfig.SetNoReply(1);
                        m_rdr_opt_parms.TagRanging.multibankswithreply--;
                    }
                }


                if (m_rdr_opt_parms.TagRanging.multibanks > 2)
                {
                    RFIDRegister.MultibankReadConfig.Set(2, true, (int)m_rdr_opt_parms.TagRanging.bank3, m_rdr_opt_parms.TagRanging.offset3, m_rdr_opt_parms.TagRanging.count3);
                    if (m_rdr_opt_parms.TagRanging.bank3 == CSLibrary.Constants.MemoryBank.BANK0 && m_rdr_opt_parms.TagRanging.offset3 == 4 && m_rdr_opt_parms.TagRanging.count3 == 1)
                    {
                        RFIDRegister.MultibankReadConfig.SetNoReply(2);
                        m_rdr_opt_parms.TagRanging.multibankswithreply--;
                    }
                }
                index = (int)m_rdr_opt_parms.TagRanging.multibanks;
            }

            for (; index < 3; index++)
                RFIDRegister.MultibankReadConfig.Enable((byte)index, false);

            RunShortOperation(SCSLRFIDCMD.SCSLRFIDStartMBInventory);
        }

        internal void RFIDStartKilowaySelectMBInventory()
        {
            int index = 0;

            m_rdr_opt_parms.TagRanging.multibankswithreply = m_rdr_opt_parms.TagRanging.multibanks;
            if (m_rdr_opt_parms.TagRanging.multibanks > 0)
            {
                RFIDRegister.MultibankReadConfig.Set(0, true, (int)m_rdr_opt_parms.TagRanging.bank1, m_rdr_opt_parms.TagRanging.offset1, m_rdr_opt_parms.TagRanging.count1);
                if (m_rdr_opt_parms.TagRanging.bank1 == CSLibrary.Constants.MemoryBank.BANK0 && m_rdr_opt_parms.TagRanging.offset1 == 4 && m_rdr_opt_parms.TagRanging.count1 == 1)
                {
                    RFIDRegister.MultibankReadConfig.SetNoReply(0);
                    m_rdr_opt_parms.TagRanging.multibankswithreply--;
                }

                if (m_rdr_opt_parms.TagRanging.multibanks > 1)
                {
                    RFIDRegister.MultibankReadConfig.Set(1, true, (int)m_rdr_opt_parms.TagRanging.bank2, m_rdr_opt_parms.TagRanging.offset2, m_rdr_opt_parms.TagRanging.count2);
                    if (m_rdr_opt_parms.TagRanging.bank2 == CSLibrary.Constants.MemoryBank.BANK0 && m_rdr_opt_parms.TagRanging.offset2 == 4 && m_rdr_opt_parms.TagRanging.count2 == 1)
                    { 
                        RFIDRegister.MultibankReadConfig.SetNoReply(1);
                        m_rdr_opt_parms.TagRanging.multibankswithreply--;
                    }
                }

                if (m_rdr_opt_parms.TagRanging.multibanks > 2)
                {
                    RFIDRegister.MultibankReadConfig.Set(2, true, (int)m_rdr_opt_parms.TagRanging.bank3, m_rdr_opt_parms.TagRanging.offset3, m_rdr_opt_parms.TagRanging.count3);
                    if (m_rdr_opt_parms.TagRanging.bank3 == CSLibrary.Constants.MemoryBank.BANK0 && m_rdr_opt_parms.TagRanging.offset3 == 4 && m_rdr_opt_parms.TagRanging.count3 == 1)
                    {
                        RFIDRegister.MultibankReadConfig.SetNoReply(2);
                        m_rdr_opt_parms.TagRanging.multibankswithreply--;
                    }
                }

                index = (int)m_rdr_opt_parms.TagRanging.multibanks;
            }

            for (; index < 3; index++)
                RFIDRegister.MultibankReadConfig.Enable((byte)index, false);

            RunShortOperation(SCSLRFIDCMD.SCSLRFIDStartSelectMBInventory);
        }

        internal void RFIDStartSelectCompactInventory()
        {
            RunShortOperation(SCSLRFIDCMD.SCSLRFIDStartSelectCompactInventory);
        }

        internal void RFIDStopOperation()
        {
            RunShortOperation(SCSLRFIDCMD.SCSLRFIDStopOperation, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.CSL_OPERATION_COMPLETE);
        }

        internal void RFIDReadMB()
        {
            for (int index = 1; index < 3; index++)
                RFIDRegister.MultibankReadConfig.Enable((byte)index, false);

            RunShortOperation(SCSLRFIDCMD.SCSLRFIDReadMB, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.CSL_OPERATION_COMPLETE);
        }

        internal void RFIDWriteMB()
        {
            for (int index = 1; index < 3; index++)
                RFIDRegister.MultibankReadConfig.Enable((byte)index, false);

            RunShortOperation(SCSLRFIDCMD.SCSLRFIDWriteMB, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.CSL_OPERATION_COMPLETE);
        }

        internal void RFIDWriteMBAny()
        {
            for (int index = 1; index < 3; index++)
                RFIDRegister.MultibankReadConfig.Enable((byte)index, false);

            RunShortOperation(SCSLRFIDCMD.SCSLRFIDWriteMBAny);
        }

        internal void RFIDBlockWriteMB()
        {
            for (int index = 1; index < 3; index++)
                RFIDRegister.MultibankReadConfig.Enable((byte)index, false);

            RunShortOperation(SCSLRFIDCMD.SCSLRFIDBlockWriteMB);
        }

        internal void RFIDBlockWriteMBAny()
        {
            for (int index = 1; index < 3; index++)
                RFIDRegister.MultibankReadConfig.Enable((byte)index, false);

            RunShortOperation(SCSLRFIDCMD.SCSLRFIDBlockWriteMBAny);
        }

        internal void RFIDLockTag()
        {
            RunShortOperation(SCSLRFIDCMD.SCSLRFIDLock, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.CSL_OPERATION_COMPLETE);
        }

        internal void RFIDKillTag()
        {
            RunShortOperation(SCSLRFIDCMD.SCSLRFIDKill, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.CSL_OPERATION_COMPLETE);
        }

        
        internal void SCSLRFIDAuthenticate()
        {
            RunShortOperation(SCSLRFIDCMD.SCSLRFIDAuthenticate, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.CSL_OPERATION_COMPLETE);
        }

        internal void RFIDClearTagCacheTable()
        {
            RunShortOperation(SCSLRFIDCMD.SCSLClearTagCacheTable);
        }

        internal void RFIDUploadTagCacheTableToHost()
        {
            RunShortOperation(SCSLRFIDCMD.SCSLUploadTagCacheTableToHost);
        }

        internal void RFIDRegisterReset()
        {
            RunShortOperation(SCSLRFIDCMD.SCSLRFIDRegisterReset);
        }

        internal void RFIDEx10Reset()
        {
            RunShortOperation(SCSLRFIDCMD.SCSLEx10Reset);
        }

        internal void RFIDCircuitReset()
        {
            RunShortOperation(SCSLRFIDCMD.SCSLRFIDCircuitReset);
        }

        internal void RFIDReadRegister()
        {
            RunShortOperation(SCSLRFIDCMD.SCSLReadRegister);
        }

        internal void RFIDWriteRegister()
        {
            RunShortOperation(SCSLRFIDCMD.SCSLWriteRegister, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.COMMANDENDRESPONSE);
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/Comm_Protocol/Ex10Commands/ClassRFID.ReadRegister.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Text;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        internal void ReadRegister(READREGISTERSET[] readset)
        {
            int payloadlen = readset.Length * 3 + 1;
            byte[] sendpacket = new byte[7 + payloadlen];

            sendpacket[0] = 0x80;
            sendpacket[1] = 0xb3;
            sendpacket[2] = 0x14;
            sendpacket[3] = 0x71;
            sendpacket[4] = 0x00;
            sendpacket[5] = (byte)(payloadlen >> 8);
            sendpacket[6] = (byte)(payloadlen);

            int index = 8;
            sendpacket[7] = (byte)readset.Length;
            for (int cnt = 0; cnt < readset.Length; cnt++)
            {
                sendpacket[index++] = (byte)(readset[cnt].address >> 8);
                sendpacket[index++] = (byte)(readset[cnt].address);
                sendpacket[index++] = (byte)(readset[cnt].size);
            }

            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, sendpacket, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
        }

        internal bool ReadRegisterCommandReply(int index, byte[] data)
        {
            if (data.Length < index + 7)
                return false;

            UInt16 Header = BitConverter.ToUInt16(data, index);
            if (Header != 0x51e2)
                return false;

            UInt16 EcgoCommandCode = BitConverter.ToUInt16(data, index + 2);
            if (EcgoCommandCode != 0x1471)
                return false;

            byte EchoSequenceNumber = data[index + 4];

            UInt16 PayloadLength = BitConverter.ToUInt16(data, index + 5);
            if (data.Length < index + 7 + PayloadLength)
                return false;

            index += 7;
            while (data.Length < index)
            {
                
                //                reg_addr_1_data
                // pass data to Register

                index++;
            }

            return true;

        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/Comm_Protocol/Ex10Commands/ClassRFID.Registers.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using static CSLibrary.BarcodeReader;

namespace CSLibrary
{
    using static RFIDDEVICE;
    using static FrequencyBand;
    using static CSLibrary.RFIDReader;

    public partial class RFIDReader
    {
        public enum REGPRIVATE
        {
            READWRITE,
            READONLY,
            WRITEONLY
        }


        internal class Regbyte
        {
            private RFIDReader _handler;
            public UInt16 regAdd;      // register address
            public byte value;      // value
            public REGPRIVATE Private;

            public Regbyte(RFIDReader handler, UInt16 add, REGPRIVATE Private)
            {
                this._handler = handler;
                this.regAdd = add;
                this.Private = Private;
            }

            public void Set(byte value)
            {
                if (this.value == value)
                    return;

                this.value = value;

                if (Private == REGPRIVATE.READONLY)
                    return;

                _handler.WriteRegister(this.regAdd, value);
            }

            public void Default(byte value)
            {
                this.value = value;
            }

            public byte Get()
            {
                return value;
            }
        }

        internal class RegUInt16
        {
            private RFIDReader _handler;
            public UInt16 regAdd;
            public UInt16 value;
            public REGPRIVATE Private;

            public RegUInt16(RFIDReader handler, UInt16 add, REGPRIVATE Private)
            {
                this._handler = handler;
                regAdd = add;
                this.Private = Private;
            }

            public void Set(UInt16 value)
            {
                if (this.value == value)
                    return;

                this.value = value;

                if (Private == REGPRIVATE.READONLY)
                    return;

                _handler.WriteRegister(this.regAdd, value);
            }

            public void Default(UInt16 value)
            {
                this.value = value;
            }

            public UInt16 Get()
            {
                return value;
            }
        }

        internal class RegUInt24
        {
            private RFIDReader _handler;
            public UInt16 regAdd;
            public UInt32 value;
            public REGPRIVATE Private;

            public RegUInt24(RFIDReader handler, UInt16 add, REGPRIVATE Private)
            {
                this._handler = handler;
                regAdd = add;
                this.Private = Private;
            }

            public void Set(UInt32 value)
            {
                if (Private == REGPRIVATE.READONLY)
                    return;

                if (this.value == value)
                    return;

                this.value = value;

                byte[] byteValue = new byte[3];
                byteValue[2] = (byte)(value & 0xff);
                byteValue[1] = (byte)(value >> 8 & 0xff);
                byteValue[0] = (byte)(value >> 16 & 0xff);

                _handler.WriteRegister(this.regAdd, byteValue);
            }

            public void Default(UInt16 value)
            {
                this.value = value;
            }

            public UInt32 Get()
            {
                return value;
            }
        }

        internal class RegUInt32
        {
            private RFIDReader _handler;
            public UInt16 regAdd;
            public UInt32 value;
            public REGPRIVATE Private;

            public RegUInt32(RFIDReader handler, UInt16 add, REGPRIVATE Private)
            {
                this._handler = handler;
                regAdd = add;
                this.Private = Private;
            }

            public void Set(UInt32 value)
            {
                if (this.value == value)
                    return;

                this.value = value;

                if (Private == REGPRIVATE.READONLY)
                    return;

                _handler.WriteRegister(this.regAdd, value);
            }

            public void Default(UInt32 value)
            {
                this.value = value;
            }

            public UInt32 Get()
            {
                return value;
            }
        }

        internal class RegUInt64
        {
            private RFIDReader _handler;
            public UInt16 regAdd;
            public UInt64 value;
            public REGPRIVATE Private;

            public RegUInt64(RFIDReader handler, UInt16 add, REGPRIVATE Private)
            {
                this._handler = handler;
                regAdd = add;
                this.Private = Private;
            }

            public void Set(UInt64 value)
            {
                if (this.value == value)
                    return;

                this.value = value;

                if (Private == REGPRIVATE.READONLY)
                    return;

                _handler.WriteRegister(this.regAdd, value);
            }

            public void Default(UInt64 value)
            {
                this.value = value;
            }

            public UInt64 Get()
            {
                return value;
            }
        }

        internal class Regstring
        {
            private RFIDReader _handler;
            public UInt16 regAdd;
            public string value;
            public int maxlen;
            public REGPRIVATE Private;

            public Regstring(RFIDReader handler, UInt16 add, int len, REGPRIVATE Private)
            {
                this._handler = handler;
                regAdd = add;
                maxlen = len;
                this.Private = Private;
            }

            public void Set(string value)
            {
                if (this.value == value)
                    return;

                if (value.Length > maxlen)
                    return;

                this.value = value;
                
                if (Private == REGPRIVATE.READONLY)
                    return;

                byte[] bytes = Encoding.ASCII.GetBytes(this.value);
                _handler.WriteRegister(this.regAdd, bytes);
            }

            public void Default(string value)
            {
                this.value = value;
            }

            public string Get()
            {
                return value;
            }
        }

        internal class RegByteArray
        {
            private RFIDReader _handler;
            public UInt16 regAdd;
            public byte[] value;
            public REGPRIVATE Private;

            public RegByteArray(RFIDReader handler, UInt16 add, int len, REGPRIVATE Private)
            {
                this._handler = handler;
                regAdd = add;
                value = new byte[len];
                this.Private = Private;
            }

            public void Set(byte[] value)
            {
                if (Private == REGPRIVATE.READONLY)
                    return;

                if (value.Length != this.value.Length)
                    return;

                for (int i = 0; i < this.value.Length; i++)
                {
                    if (value[i] != this.value[i])
                    {
                        value.CopyTo(this.value, 0);
                        _handler.WriteRegister(this.regAdd, this.value);
                        break;
                    }
                }
            }

            public byte[] Get()
            {
                return value;
            }
        }

        internal class RegAntennaPortConfig
        {
            internal class AntennaPortConfig
            {
                public bool enable = false;
                public UInt16 dwell = 2000;
                public UInt16 power = 3000;
                public UInt32 inventoryRoundControl;
                public UInt32 inventoryRoundControl2;
                public bool toggle = true;
                public UInt16 rfMode = 5;
            }

            internal RFIDReader _handler;
            internal UInt16 regAdd;
            internal AntennaPortConfig [] data = new AntennaPortConfig[16];
            internal REGPRIVATE Private;

            internal RegAntennaPortConfig(RFIDReader handler)
            {
                this._handler = handler;
                regAdd = 0x3030;
                //data = new AntennaPortConfig[7];
                this.Private = REGPRIVATE.READWRITE;
                for (int cnt = 0; cnt < 16; cnt++)
                    data[cnt] = new AntennaPortConfig();
                data[0].enable = true;
            }

            internal void Enable(bool enable, byte port = 0)
            {
                if (Private == REGPRIVATE.READONLY)
                    return;

                if (data[port].enable == enable)
                    return;

                byte[] sendData = new byte[1];
                int dataAdd = (port * 16);

                if (data[port].enable == enable)
                    return;

                sendData[0] = (byte)(enable ? 1 : 0);
                data[port].enable = enable;

                _handler.WriteRegister((UInt16)(regAdd + dataAdd), sendData);
            }

            internal void Enable(bool enable, int startport, int endport)
            {
                if (Private == REGPRIVATE.READONLY)
                    return;

                List<UInt16> address = new List<UInt16>();
                List<byte> sendBuffer = new List<byte>();
                byte newValue = (byte)(enable ? 1 : 0);

                for (int i = startport; i < endport; i++)
                {
                    if (data[i].enable == enable)
                        continue;

                    data[i].enable = enable;
                    address.Add((UInt16)(regAdd + (i * 16)));
                    sendBuffer.Add(newValue);
                }

                if (address.Count > 0)
                    _handler.WriteRegister(address.ToArray(), sendBuffer.ToArray());
            }

            internal void SetDwell(UInt16 ms, byte port = 0)
            {
                if (Private == REGPRIVATE.READONLY)
                    return;

                if (data[port].dwell == ms)
                    return;

                int dataAdd = 1 + (port * 16);

                data[port].dwell = ms;

                _handler.WriteRegister((UInt16)(regAdd + dataAdd), ms);
            }

            internal void SetPower(UInt16 power, byte port = 0)
            {
                if (Private == REGPRIVATE.READONLY)
                    return;

                if (data[port].power == power)
                    return;

                int dataAdd = 3 + (port * 16);

                data[port].power = power;

                _handler.WriteRegister((UInt16)(regAdd + dataAdd), power);
            }

            internal UInt16 GetPower(byte port = 0)
            {
                if (Private == REGPRIVATE.WRITEONLY)
                    return 0;

                return (UInt16)data[port].power;
            }

            internal void SetTargetToggle(bool enable, byte port = 0)
            {
                if (Private == REGPRIVATE.READONLY)
                    return;

                if (data[port].toggle == enable)
                    return;

                byte[] sendData = new byte[1];
                int dataAdd = 13 + (port * 16);

                data[port].toggle = enable;

                sendData[0] = (byte)(enable ? 1 : 0);
                _handler.WriteRegister((UInt16)(regAdd + dataAdd), sendData);
            }

            // if == 0 DynamicQ, != 0 FixedQ 
            internal int GetCurrentAlgorithm(int port = 0)
            {
                if (Private == REGPRIVATE.WRITEONLY)
                    return -1;

                int dataAdd = 5 + (port * 16);

                return (int)(data[port].inventoryRoundControl & (1U << 16));
            }

            internal void EnableFixedQ(int port = 0)
            {
                if (Private == REGPRIVATE.READONLY)
                    return;

                uint sendData = data[port].inventoryRoundControl | (1U << 16);
                if (data[port].inventoryRoundControl == sendData)
                    return;

                int dataAdd = 5 + (port * 16);
                data[port].inventoryRoundControl = sendData;

                _handler.WriteRegister((UInt16)(regAdd + dataAdd), sendData);
            }

            internal void EnableFixedQ(uint InitialQ, uint QueryTarget, int port = 0)
            {
                if (InitialQ > 15 || QueryTarget > 1)
                    return;

                uint sendData = data[port].inventoryRoundControl & 0xff7ffff0;
                sendData |= InitialQ;
                sendData |= (1U << 16);
                sendData |= QueryTarget;

                if (data[port].inventoryRoundControl == sendData)
                    return;

                int dataAdd = 5 + (port * 16);

                data[port].inventoryRoundControl = sendData;

                _handler.WriteRegister((UInt16)(regAdd + dataAdd), data[port].inventoryRoundControl);
            }

            internal void EnableDynamicQ(int port = 0)
            {
                uint sendData = data[port].inventoryRoundControl & ~(1U << 16);

                if (data[port].inventoryRoundControl == sendData)
                    return;

                int dataAdd = 5 + (port * 16);

                data[port].inventoryRoundControl = sendData;

                _handler.WriteRegister((UInt16)(regAdd + dataAdd), sendData);
            }

            /// <summary>
            /// Set Dynamic Q parameters and enabled
            /// </summary>
            /// <param name="MinQ"></param>
            /// <param name="MaxQ"></param>
            /// <param name="InitialQ"></param>
            /// <param name="NumMinQCycles"></param>
            /// <param name="QDecreaseUseQuery"></param>
            /// <param name="QIncreaseUseQuery"></param>
            /// <param name="Session"></param>
            /// <param name="QueryTarget"></param>
            /// <returns></returns>
            internal int EnableDynamicQ(uint MinQ, uint MaxQ, uint InitialQ, uint NumMinQCycles, bool QDecreaseUseQuery, bool QIncreaseUseQuery, uint QueryTarget, int port = 0)
            {
                CSLibrary.Debug.WriteLine("EnableDynamicQ");

                if (MinQ > 15 || MaxQ > 15 || InitialQ > 15 || NumMinQCycles > 153 || QueryTarget > 1)
                    return -1;

                uint sendData = data[port].inventoryRoundControl & 0xff780000;
                sendData |= InitialQ << 0;
                sendData |= MaxQ << 4;
                sendData |= MinQ << 8;
                sendData |= NumMinQCycles << 12;
                sendData |= QIncreaseUseQuery ? (1U << 17) : 0;
                sendData |= QDecreaseUseQuery ? (1U << 18) : 0;
                sendData |= QueryTarget;

                if (data[port].inventoryRoundControl == sendData)
                    return 0;

                int dataAdd = 5 + (port * 16);

                data[port].inventoryRoundControl = sendData;

                _handler.WriteRegister((UInt16)(regAdd + dataAdd), sendData);
                return 0;
            }

            internal void TagGroup(uint session, uint select, uint target, int port = 0)
            {
                if (port == 0xffff)
                {
                    List<UInt16> address = new List<UInt16>();
                    List<uint> sendData = new List<uint>();

                    for (int i = 0; i < 16; i++)
                    {
                        if (!data[i].enable)
                            continue;

                        uint newvalue = (data[i].inventoryRoundControl & 0xff07ffff);
                        newvalue |= (session & 0x03) << 19;
                        newvalue |= (select & 0x03) << 21;
                        newvalue |= (target & 0x01) << 23;

                        if (data[i].inventoryRoundControl == newvalue)
                            continue;

                        data[i].inventoryRoundControl = newvalue;
                        address.Add((UInt16)(regAdd + 5 + (i * 16)));
                        sendData.Add(newvalue);
                    }

                    _handler.WriteRegister(address.ToArray(), sendData.ToArray());
                }
                else
                {
                    uint sendData = data[port].inventoryRoundControl & 0xff07ffff;
                    sendData |= (session & 0x03) << 19;
                    sendData |= (select & 0x03) << 21;
                    sendData |= (target & 0x01) << 23;

                    if (data[port].inventoryRoundControl == sendData)
                        return;

                    int dataAdd = 5 + (port * 16);

                    data[port].inventoryRoundControl = sendData;

                    _handler.WriteRegister((UInt16)(regAdd + dataAdd), sendData);
                }
            }

            internal void Select(uint select, int port = 0)
            {
                if (port == 0xffff)
                {
                    List<UInt16> address = new List<UInt16>();
                    List<uint> sendData = new List<uint>();

                    for (int i = 0; i < 16; i++)
                    {
                        if (!data[i].enable)
                            continue;

                        uint newvalue = data[i].inventoryRoundControl & 0xff9fffff;
                        newvalue |= (select & 0x03) << 21;

                        if (data[i].inventoryRoundControl == newvalue)
                            continue;

                        data[i].inventoryRoundControl = newvalue;
                        address.Add((UInt16)(regAdd + 5 + (i * 16)));
                        sendData.Add(newvalue);
                    }

                    _handler.WriteRegister(address.ToArray(), sendData.ToArray());
                }
                else
                {
                    uint sendData = data[port].inventoryRoundControl & 0xff9fffff;
                    sendData |= (select & 0x03) << 21;

                    if (data[port].inventoryRoundControl == sendData)
                        return;

                    int dataAdd = 5 + (port * 16);

                    data[port].inventoryRoundControl = sendData;

                    _handler.WriteRegister((UInt16)(regAdd + dataAdd), sendData);
                }
            }

            internal void FastIdEnable(bool enable, int port = 0)
            {
                UInt32 newValue = data[port].inventoryRoundControl & 0xfdffffff;

                if (enable)
                    newValue |= 1 << 25;

                if (data[port].inventoryRoundControl == newValue)
                    return;

                int dataAdd = 5 + (port * 16);

                data[port].inventoryRoundControl = newValue;

                _handler.WriteRegister((UInt16)(regAdd + dataAdd), newValue);
                return;
            }

            internal bool FastId(int port = 0)
            {
                UInt32 Value = data[port].inventoryRoundControl | ~(0xfdffffff);

                if (Value == 0)
                    return false;

                return true;
            }

            internal void TagFocusEnable(bool enable, int port = 0)
            {
                UInt32 newValue = data[port].inventoryRoundControl & 0xfbffffff;

                if (enable)
                    newValue |= 1 << 26;

                if (data[port].inventoryRoundControl == newValue)
                    return;

                int dataAdd = 5 + (port * 16);

                data[port].inventoryRoundControl = newValue;

                _handler.WriteRegister((UInt16)(regAdd + dataAdd), newValue);
                return;
            }

            internal void MaxQSinceValidEpc(UInt32 Q, int port = 0)
            {
                if (data[port].inventoryRoundControl2 == Q)
                    return;

                int dataAdd = 9 + (port * 16);

                data[port].inventoryRoundControl2 = Q;

                _handler.WriteRegister((UInt16)(regAdd + dataAdd), data[port].inventoryRoundControl2);
            }

            internal void RfMode(UInt16 mode, int port = 0)
            {
                if (data[port].rfMode == mode)
                    return;

                int dataAdd = 14 + (port * 16);
                data[port].rfMode = mode;

                _handler.WriteRegister((UInt16)(regAdd + dataAdd), data[port].rfMode);
            }

            internal void SetInventoryRoundControl(int port, UInt32 value)
            {
                if (Private == REGPRIVATE.READONLY)
                    return;

                if (data[port].inventoryRoundControl == value)
                    return;

                int dataAdd = 5 + (port * 16);
                data[port].inventoryRoundControl = value;

                _handler.WriteRegister((UInt16)(regAdd + dataAdd), value);
            }

            internal bool CloneAntenna0Setting()
            {
                List<UInt16> address = new List<UInt16>();
                List<byte[]> sendData = new List<byte[]>();
                byte[] newValue = new byte[11];

                Tools.Hex.MSBArrayCopy(data[0].inventoryRoundControl, newValue, 0);
                Tools.Hex.MSBArrayCopy(data[0].inventoryRoundControl2, newValue, 4);
                newValue[8] = (byte)(data[0].toggle ? 1 : 0);
                Tools.Hex.MSBArrayCopy(data[0].rfMode, newValue, 9);

                for (int i = 1; i < 16; i++)
                {
                    if (!data[i].enable)
                        continue;

                    if (data[i].inventoryRoundControl == data[0].inventoryRoundControl &&
                        data[i].inventoryRoundControl2 == data[0].inventoryRoundControl2 &&
                        data[i].toggle == data[0].toggle &&
                        data[i].rfMode == data[0].rfMode)
                        continue;

                    data[i].inventoryRoundControl = data[0].inventoryRoundControl;
                    data[i].inventoryRoundControl2 = data[0].inventoryRoundControl2;
                    data[i].toggle = data[0].toggle;
                    data[i].rfMode = data[0].rfMode;
                    address.Add((UInt16)(regAdd + 5 + (i * 16)));
                    sendData.Add(newValue);
                }

                _handler.WriteRegister(address.ToArray(), sendData.ToArray());
                return true;
            }
        }

        /*
                internal class RegAntennaPortConfig
                {
                    internal RFIDReader _handler;
                    internal UInt16 regAdd;
                    internal byte[] data;
                    internal REGPRIVATE Private;

                    internal RegAntennaPortConfig(RFIDReader handler)
                    {
                        this._handler = handler;
                        regAdd = 0x3030;
                        data = new byte[256];
                        this.Private = REGPRIVATE.READWRITE;
                    }

                    internal void Enable(bool enable, byte port = 0)
                    {
                        if (Private == REGPRIVATE.READONLY)
                            return;

                        byte[] sendData = new byte[1];
                        int dataAdd = (port * 16);

                        if (enable)
                            data[dataAdd] = 1;
                        else
                            data[dataAdd] = 0;

                        sendData[0] = data[dataAdd];
                        _handler.WriteRegister((UInt16)(regAdd + dataAdd), sendData);
                    }

                    internal void SetDwell(UInt16 ms, byte port = 0)
                    {
                        if (Private == REGPRIVATE.READONLY)
                            return;

                        byte[] sendData = new byte[2];
                        int dataAdd = 1 + (port * 16);

                        data[dataAdd] = (byte)(ms >> 8);
                        data[dataAdd + 1] = (byte)(ms);

                        Array.Copy(data, dataAdd, sendData, 0, 2);
                        _handler.WriteRegister((UInt16)(regAdd + dataAdd), sendData);
                    }

                    internal void SetPower(UInt16 power, byte port = 0)
                    {
                        power *= 10;

                        if (Private == REGPRIVATE.READONLY)
                            return;

                        byte[] sendData = new byte[2];
                        int dataAdd = 3 + (port * 16);

                        data[dataAdd] = (byte)(power >> 8);
                        data[dataAdd + 1] = (byte)(power);

                        Array.Copy(data, dataAdd, sendData, 0, 2);
                        _handler.WriteRegister((UInt16)(regAdd + dataAdd), sendData);
                    }

                    internal UInt16 GetPower(byte port = 0)
                    {
                        if (Private == REGPRIVATE.WRITEONLY)
                            return 0;

                        byte[] sendData = new byte[2];
                        int dataAdd = 3 + (port * 16);
                        int power;

                        power = (data[dataAdd] << 8 | data[dataAdd + 1]);

                        return (UInt16)power;
                    }

                    internal void SetTargetToggle(bool enable, byte port = 0)
                    {
                        if (Private == REGPRIVATE.READONLY)
                            return;

                        byte[] sendData = new byte[1];
                        int dataAdd = 13 + (port * 16);

                        if (enable)
                            data[dataAdd] = 1;
                        else
                            data[dataAdd] = 0;

                        sendData[0] = data[dataAdd];
                        _handler.WriteRegister((UInt16)(regAdd + dataAdd), sendData);
                    }

                    // if == 0 DynamicQ, != 0 FixedQ 
                    internal int GetCurrentAlgorithm(int port = 0)
                    {
                        if (Private == REGPRIVATE.READONLY)
                            return -1;

                        int dataAdd = 5 + (port * 16);

                        return (int)(data[dataAdd] & (1U << 16));
                    }

                    internal void EnableFixedQ(int port = 0)
                    {
                        if (Private == REGPRIVATE.READONLY)
                            return;

                        int dataAdd = 5 + (port * 16);

                        data[dataAdd] = data[dataAdd] | (1U << 16);

                        Set(data);
                    }

                    internal void EnableFixedQ(uint InitialQ, uint QueryTarget)
                    {
                        if (InitialQ > 15 || QueryTarget > 1)
                            return;

                        UInt32 data = _data & 0xff7ffff0;

                        data |= InitialQ;
                        data |= (1U << 16);
                        data |= QueryTarget;

                        Set(data);
                    }

                    internal void EnableDynamicQ()
                    {
                        var data = _data & ~(1U << 16);

                        Set(data);
                    }

                    /// <summary>
                    /// Set Dynamic Q parameters and enabled
                    /// </summary>
                    /// <param name="MinQ"></param>
                    /// <param name="MaxQ"></param>
                    /// <param name="InitialQ"></param>
                    /// <param name="NumMinQCycles"></param>
                    /// <param name="QDecreaseUseQuery"></param>
                    /// <param name="QIncreaseUseQuery"></param>
                    /// <param name="Session"></param>
                    /// <param name="QueryTarget"></param>
                    /// <returns></returns>
                    internal int EnableDynamicQ(uint MinQ, uint MaxQ, uint InitialQ, uint NumMinQCycles, bool QDecreaseUseQuery, bool QIncreaseUseQuery, uint QueryTarget)
                    {
                        if (MinQ > 15 || MaxQ > 15 || InitialQ > 15 || NumMinQCycles > 153 || QueryTarget > 1)
                            return -1;

                        UInt32 data = _data & 0xff780000;

                        data |= InitialQ << 0;
                        data |= MaxQ << 4;
                        data |= MinQ << 8;
                        data |= NumMinQCycles << 12;
                        data |= QIncreaseUseQuery ? (1U << 17) : 0;
                        data |= QDecreaseUseQuery ? (1U << 18) : 0;
                        data |= QueryTarget;

                        Set(data);

                        return 0;
                    }

                    internal void SetFastID(bool enable)
                    {
                        var data = _data;

                        if (enable)
                            data |= (1U << 25);
                        else
                            data &= ~(1U << 25);

                        Set(data);
                    }

                    internal void SetTagFocus(bool enable)
                    {
                        var data = _data;

                        if (enable)
                            data |= (1U << 26);
                        else
                            data &= ~(1U << 26);

                        Set(data);
                    }
                }
        */

        internal class RegSelectConfiguration
        {
            internal RFIDReader _handler;
            internal UInt16 regAdd;
            internal byte[] data;
            internal REGPRIVATE Private;

            internal RegSelectConfiguration(RFIDReader handler)
            {
                this._handler = handler;
                regAdd = 0x3140;
                data = new byte[294];
                this.Private = REGPRIVATE.READWRITE;
            }

            internal void Enable(uint index, bool enable)
            {
                if (Private == REGPRIVATE.READONLY)
                    return;

                if (index >= 7)
                    return;

                byte sendData;
                uint dataAdd = (index * 42);

                sendData = (byte)(enable ? 1 : 0);

                if (data[dataAdd] == sendData)
                    return;

                data[dataAdd] = sendData;
                _handler.WriteRegister((UInt16)(regAdd + dataAdd), sendData);
            }

            internal void Enable(int startIndex, int endIndex, bool enable)
            {
                if (Private == REGPRIVATE.READONLY)
                    return;

                if (startIndex < 0 || startIndex > endIndex || endIndex >= 7)
                    return;

                List<UInt16> address = new List<UInt16>();
                List<byte> sendbuffer = new List<byte>();
                byte newvalue = (byte)(enable ? 1 : 0);

                for (int i = startIndex; i <= endIndex; i++)
                {
                    uint dataAdd = (uint)(i * 42);

                    if (data[dataAdd] == newvalue)
                        continue;

                    data[dataAdd] = newvalue;
                    address.Add((UInt16)(regAdd + dataAdd));
                    sendbuffer.Add(newvalue);
                }

                if (address.Count > 0)
                    _handler.WriteRegister(address.ToArray(), sendbuffer.ToArray());
            }

            internal bool IsEnable(uint index)
            {
                if (index >= 7)
                    return false;

                uint dataAdd = (index * 42);

                return (data[dataAdd] != 0);
            }

            internal void SetPostConfigurationDelay(uint index, int ms)
            {
                if (Private == REGPRIVATE.READONLY)
                    return;

                if (index >= 7 || ms > 255)
                    return;

                byte[] sendData = new byte[1];
                uint add = 41 + (index * 42);

                sendData[0] = (byte)ms;

                if (data[add] == sendData[0])
                    return;

                data[add] = sendData[0];
                _handler.WriteRegister((UInt16)(regAdd + add), sendData);
            }

            internal void Set(int index, bool enable, byte bank, UInt32 offset, byte len, byte[] mask, byte target, byte action, byte delay)
            {
                if (Private == REGPRIVATE.READONLY)
                    return;

                if (index >= 7)
                    return;

                byte[] sendData = new byte[42];
                int add = (index * 42);
                int maskbytelen = (len + 7) / 8;

                if (mask.Length < maskbytelen)
                {
                    Debug.WriteLine("Set selected mask length error");
                    return;
                }

                if (enable)
                    sendData[0] = 1;
                else
                    sendData[0] = 0;

                sendData[1] = bank;
                sendData[2] = (byte)(offset >> 24);
                sendData[3] = (byte)(offset >> 16);
                sendData[4] = (byte)(offset >> 8);
                sendData[5] = (byte)(offset);
                sendData[6] = len;
                Array.Copy(mask, 0, sendData, 7, maskbytelen);
                sendData[39] = target;
                sendData[40] = action;
                sendData[41] = delay;

                for (int i = 0; i < sendData.Length; i++)
                {
                    if (data[add + i] != sendData[i])
                    {
                        Array.Copy(sendData, 0, data, add, sendData.Length);
                        _handler.WriteRegister((UInt16)(regAdd + add), sendData);
                        break;
                    }
                }
            }
        }

        internal class RegMultibankReadConfig
        {
            internal RFIDReader _handler;
            internal UInt16 regAdd;
            internal byte[] data;
            internal REGPRIVATE Private;

            internal RegMultibankReadConfig(RFIDReader handler)
            {
                this._handler = handler;
                regAdd = 0x3270;
                data = new byte[21];
                this.Private = REGPRIVATE.READWRITE;
            }

            internal void Enable(byte index, bool enable)
            {
                if (Private == REGPRIVATE.READONLY)
                    return;

                byte[] sendData = new byte[1];
                int add = (index * 7);

                byte newValue = enable ? (byte)1 : (byte)0;

                if (data[add] == newValue)
                    return;

                data[add] = newValue;

                sendData[0] = data[add];
                _handler.WriteRegister((UInt16)(regAdd + add), sendData);
            }

            internal void Set(int index, bool enable, int bank, int address, int len)
            {
                if (Private == REGPRIVATE.READONLY)
                    return;

                byte[] sendData = new byte[7];
                int add = (index * 7);


                sendData[0] = enable ? (byte)1 : (byte)0;
                sendData[1] = (byte)bank;
                sendData[2] = (byte)(address >> 24);
                sendData[3] = (byte)(address >> 16);
                sendData[4] = (byte)(address >> 8);
                sendData[5] = (byte)(address);
                sendData[6] = (byte)len;


                for (int i = 0; i < sendData.Length; i++)
                {
                    if (data[add + i] != sendData[i])
                    {
                        Array.Copy(sendData, 0, data, add, sendData.Length);
                        _handler.WriteRegister((UInt16)(regAdd + add), sendData);
                        break;
                    }
                }

            }

            internal void SetNoReply(byte index)
            {
                if (Private == REGPRIVATE.READONLY)
                    return;

                byte[] sendData = new byte[1];
                int add = (index * 7);

                byte newValue = 2;

                if (data[add] == newValue)
                    return;

                data[add] = newValue;

                sendData[0] = data[add];
                _handler.WriteRegister((UInt16)(regAdd + add), sendData);
            }
        }
        internal class RegMultibankWriteConfig
        {
            internal RFIDReader _RFIDhandler;
            internal UInt16 _address;
            internal byte[] _data;
            internal REGPRIVATE _private;

            internal RegMultibankWriteConfig(RFIDReader handler)
            {
                this._RFIDhandler = handler;
                _address = 0x3290;
                _data = new byte[1557];
                this._private = REGPRIVATE.READWRITE;
            }

            internal void Enable(byte index, bool enable)
            {
                if (_private == REGPRIVATE.READONLY)
                    return;

                byte[] sendData = new byte[1];
                int add = (index * 519);

                if (enable)
                    _data[add] = 1;
                else
                    _data[add] = 0;

                sendData[0] = _data[add];
                _RFIDhandler.WriteRegister((UInt16)(_address + add), sendData);

            }

            internal void Set(int index, bool enable, byte bank, UInt32 offset, byte len, byte[] data)
            {
                if (_private == REGPRIVATE.READONLY)
                    return;

                byte[] sendData = new byte[7 + data.Length];
                int add = (index * 519);

                if (enable)
                    _data[add] = 1;
                else
                    _data[add] = 0;

                _data[add + 1] = (byte)bank;
                _data[add + 2] = (byte)(offset >> 24);
                _data[add + 3] = (byte)(offset >> 16);
                _data[add + 4] = (byte)(offset >> 8);
                _data[add + 5] = (byte)(offset);
                _data[add + 6] = (byte)len;
                Array.Copy(data, 0, _data, add + 7, data.Length);

                Array.Copy(_data, add, sendData, 0, 7 + data.Length);
                _RFIDhandler.WriteRegister((UInt16)(_address + add), sendData);
            }
        }

        internal class RegInventoryRoundControl
        {
            internal RFIDReader _RFIDhandler;
            internal UInt16 _address;
            internal UInt32 _data;
            internal REGPRIVATE _private;

            internal RegInventoryRoundControl(RFIDReader handler)
            {
                this._RFIDhandler = handler;
                _address = 0x1000;
                _data = 0;
                this._private = REGPRIVATE.READWRITE;
            }

            internal void Set(UInt32 value)
            {
                if (value == _data)
                    return;

                _data = value;
                _RFIDhandler.WriteRegister((UInt16)_address, _data);
            }

            internal UInt32 Get()
            {
                return _data;
            }

            // if == 0 DynamicQ, != 0 FixedQ 
            internal uint GetCurrentAlgorithm()
            {
                return _data & (1U << 16);
            }

            internal void EnableFixedQ()
            {
                var data = _data | (1U << 16);
                Set(data);
            }

            internal void EnableFixedQ(uint InitialQ, uint QueryTarget)
            {
                if (InitialQ > 15 || QueryTarget > 1)
                    return;

                UInt32 data = _data & 0xff7ffff0;

                data |= InitialQ;
                data |= (1U << 16);
                data |= QueryTarget;

                Set(data);
            }

            internal void EnableDynamicQ()
            {
                var data = _data & ~(1U << 16);

                Set(data);
            }

            /// <summary>
            /// Set Dynamic Q parameters and enabled
            /// </summary>
            /// <param name="MinQ"></param>
            /// <param name="MaxQ"></param>
            /// <param name="InitialQ"></param>
            /// <param name="NumMinQCycles"></param>
            /// <param name="QDecreaseUseQuery"></param>
            /// <param name="QIncreaseUseQuery"></param>
            /// <param name="Session"></param>
            /// <param name="QueryTarget"></param>
            /// <returns></returns>
            internal int EnableDynamicQ(uint MinQ, uint MaxQ, uint InitialQ, uint NumMinQCycles, bool QDecreaseUseQuery, bool QIncreaseUseQuery, uint QueryTarget)
            {
                if (MinQ > 15 || MaxQ > 15 || InitialQ > 15 || NumMinQCycles > 153 || QueryTarget > 1)
                    return -1;

                UInt32 data = _data & 0xff780000;

                data |= InitialQ << 0;
                data |= MaxQ << 4;
                data |= MinQ << 8;
                data |= NumMinQCycles << 12;
                data |= QIncreaseUseQuery ? (1U << 17) : 0;
                data |= QDecreaseUseQuery ? (1U << 18) : 0;
                data |= QueryTarget;

                Set(data);

                return 0;
            }

            internal void SetFastID(bool enable)
            {
                var data = _data;

                if (enable)
                    data |= (1U << 25);
                else
                    data &= ~(1U << 25);

                Set(data);
            }

            internal void SetTagFocus(bool enable)
            {
                var data = _data;

                if (enable)
                    data |= (1U << 26);
                else
                    data &= ~(1U << 26);

                Set(data);
            }
        }

        internal class CSLRFIDREGISTER
        {
            internal RFIDReader _handler;

            //internal RegUInt32 CommandResult;
            //internal RegUInt16 ResetCause;
            //internal RegUInt16 Status;
            internal Regstring VersionString;
            internal Regstring BuildNumber;
            //internal RegUInt32 Githash;
            //internal Regstring SerialNumber;
            //internal RegUInt32 FrefFreq;
            //internal RegUInt64 ProductSku;
            //internal RegUInt32 DeviceInfo;
            //internal RegUInt32 DeviceBuild;
            //internal RegUInt32 RtlRevision;
            //internal Regbyte InterruptMask;
            //internal RegUInt32 InterruptMaskSet;
            //internal RegUInt32 InterruptMaskClear;
            //internal Regbyte InterruptStatus;
            //internal RegUInt16 EventFifoNumBytes;
            //internal RegUInt16 EventFifoIntLevel;
            //internal RegUInt32 GpioOutputEnable;
            //internal RegUInt32 GpioOutputLevel;
            //internal Regbyte OpsControl;
            //internal RegUInt32 OpsStatus;
            //internal RegUInt32 HaltedControl;
            //internal RegUInt32 HaltedStatus;
            //internal RegUInt32 LogTestPeriod;
            //internal RegUInt32 LogTestWordRepeat;
            //internal RegUInt32 EventFifoTestPeriod;
            //internal RegUInt32 EventFifoTestPayloadNumWords;
            //internal RegUInt16 LogSpeed;
            //internal RegUInt16 LogEnables;
            //internal RegUInt32 BerControl;
            //internal Regbyte BerMode;
            //internal RegUInt16 AuxAdcControl;
            //internal RegUInt16 AuxAdcResults;
            //internal RegUInt32 RfSynthesizerControl;
            //internal RegUInt32 TxFineGain;
            //internal RegUInt32 RxGainControl;
            //internal RegUInt32 TxCoarseGain;
            //internal RegUInt32 RfMode;
            //internal RegUInt32 DcOffset;
            //internal RegUInt32 CwOffTime;
            //internal Regbyte SjcControl;
            //internal RegUInt32 SjcGainControl;
            //internal RegUInt32 SjcSettlingTime;
            //internal RegUInt32 SjcCdacI;
            //internal RegUInt32 SjcCdacQ;
            //internal RegUInt32 SjcResultI;
            //internal RegUInt32 SjcResultQ;
            //internal RegUInt32 AnalogEnable;
            //internal RegInventoryRoundControl InventoryRoundControl;
            //internal RegUInt32 InventoryRoundControl_2;
            //internal RegUInt16 NominalStopTime;
            //internal RegUInt16 ExtendedStopTime;
            //internal RegUInt16 RegulatoryStopTime;
            //internal RegUInt16 Gen2SelectEnable;
            //internal RegUInt16 Gen2AccessEnable;
            //internal Regbyte Gen2Offsets;
            //internal RegUInt16 Gen2Lengths;
            //internal Regbyte Gen2TransactionIds;
            //internal RegUInt32 Gen2TxnControls;
            //internal RegByteArray Gen2TxBuffer;
            internal RegUInt32 LoopStyle;
            internal Regbyte HopStyle;
            internal RegUInt16 RegulatoryNoEmissionTime;
            internal RegUInt16 CountryEnum;
            internal Regbyte FrequencyChannelIndex;
            internal RegAntennaPortConfig AntennaPortConfig;
            internal RegSelectConfiguration SelectConfiguration;
            internal RegMultibankReadConfig MultibankReadConfig;
            internal RegMultibankWriteConfig MultibankWriteConfig;
            internal RegUInt32 AccessPassword;
            internal RegUInt32 KillPassword;
            internal RegUInt16 LockMask;
            internal RegUInt16 LockAction;
            internal Regbyte DuplicateEliminationRollingWindow;
            internal RegUInt16 TagCacheTableCurrentSize;
            internal Regbyte TagCacheStatus;
            internal RegUInt16 EventPacketUplinkEnable;
            internal Regbyte IntraPacketDelay;
            internal Regbyte RssiFilteringConfig;
            internal RegUInt16 RssiThreshold;
            internal RegUInt24 AuthenticateConfig;
            internal RegByteArray AuthenticateMessage;
            internal RegUInt16 AuthenticateResponseLen;
            internal RegUInt16 ReversePowerADC;
            internal Regbyte CurrentPort;
            internal Regstring ModelName;
            internal Regstring SerialNumber_1;
            internal RegUInt16 CountryEnum_1;
            internal RegUInt32 EF98;
            internal Regstring EF9C;
            internal RegUInt32 EFAC;
            internal RegUInt32 EFB0;

            public CSLRFIDREGISTER(RFIDReader _deviceHandler)
            {

                this._handler = _deviceHandler;

                //CommandResult = new RegUInt32(_deviceHandler, 0x0000, REGPRIVATE.READONLY);
                //ResetCause = new RegUInt16(_deviceHandler, 0x0004, REGPRIVATE.READONLY);
                //Status = new RegUInt16(_deviceHandler, 0x0006, REGPRIVATE.READONLY);
                VersionString = new Regstring(_deviceHandler, 0x0008, 32, REGPRIVATE.READONLY);
                BuildNumber = new Regstring(_deviceHandler, 00028, 4, REGPRIVATE.READONLY);
                //Githash = new RegUInt32(_deviceHandler, 0x002c, REGPRIVATE.READONLY);
                //SerialNumber = new Regstring(_deviceHandler, 0x0070, 32, REGPRIVATE.READONLY);
                //FrefFreq = new RegUInt32(_deviceHandler, 0x0034, REGPRIVATE.READONLY);
                //ProductSku = new RegUInt64(_deviceHandler, 0x0068, REGPRIVATE.READONLY);
                //DeviceInfo = new RegUInt32(_deviceHandler, 0x0090, REGPRIVATE.READONLY);
                //DeviceBuild = new RegUInt32(_deviceHandler, 0x0094, REGPRIVATE.READONLY);
                //RtlRevision = new RegUInt32(_deviceHandler, 0x0098, REGPRIVATE.READONLY);
                //InterruptMask = new Regbyte(_deviceHandler, 0x00a0, REGPRIVATE.READWRITE);
                //InterruptMaskSet = new RegUInt32(_deviceHandler, 0x00a4, REGPRIVATE.WRITEONLY);
                //InterruptMaskClear = new RegUInt32(_deviceHandler, 0x00a8, REGPRIVATE.WRITEONLY);
                //InterruptStatus = new Regbyte(_deviceHandler, 0x00ac, REGPRIVATE.READONLY);
                //EventFifoNumBytes = new RegUInt16(_deviceHandler, 0x00b0, REGPRIVATE.READONLY);
                //EventFifoIntLevel = new RegUInt16(_deviceHandler, 0x00b2, REGPRIVATE.READWRITE);
                //GpioOutputEnable = new RegUInt32(_deviceHandler, 0x00b4, REGPRIVATE.READWRITE);
                //GpioOutputLevel = new RegUInt32(_deviceHandler, 0x00b8, REGPRIVATE.READWRITE);
                //OpsControl = new Regbyte(_deviceHandler, 0x0300, REGPRIVATE.READWRITE);
                //OpsStatus = new RegUInt32(_deviceHandler, 0x0304, REGPRIVATE.READONLY);
                //HaltedControl = new RegUInt32(_deviceHandler, 0x0308, REGPRIVATE.READWRITE);
                //HaltedStatus = new RegUInt32(_deviceHandler, 0x030c, REGPRIVATE.READONLY);
                //LogTestPeriod = new RegUInt32(_deviceHandler, 0x0320, REGPRIVATE.READWRITE);
                //LogTestWordRepeat = new RegUInt32(_deviceHandler, 0x0324, REGPRIVATE.READWRITE);
                //EventFifoTestPeriod = new RegUInt32(_deviceHandler, 0x0328, REGPRIVATE.READWRITE);
                //EventFifoTestPayloadNumWords = new RegUInt32(_deviceHandler, 0x032c, REGPRIVATE.READWRITE);
                //LogSpeed = new RegUInt16(_deviceHandler, 0x0330, REGPRIVATE.READWRITE);
                //LogEnables = new RegUInt16(_deviceHandler, 0x0334, REGPRIVATE.READWRITE);
                //BerControl = new RegUInt32(_deviceHandler, 0x0338, REGPRIVATE.READWRITE);
                //BerMode = new Regbyte(_deviceHandler, 0x033c, REGPRIVATE.READWRITE);
                //AuxAdcControl = new RegUInt16(_deviceHandler, 0x0400, REGPRIVATE.READWRITE);
                //AuxAdcResults = new RegUInt16(_deviceHandler, 0x0404, REGPRIVATE.READONLY);
                //RfSynthesizerControl = new RegUInt32(_deviceHandler, 0x0500, REGPRIVATE.READWRITE);
                //TxFineGain = new RegUInt32(_deviceHandler, 0x504, REGPRIVATE.READWRITE);
                //RxGainControl = new RegUInt32(_deviceHandler, 0x0508, REGPRIVATE.READWRITE);
                //TxCoarseGain = new RegUInt32(_deviceHandler, 0x050c, REGPRIVATE.READWRITE);
                //RfMode = new RegUInt32(_deviceHandler, 0x0514, REGPRIVATE.READWRITE);
                //DcOffset = new RegUInt32(_deviceHandler, 0x0518, REGPRIVATE.READWRITE);
                //CwOffTime = new RegUInt32(_deviceHandler, 0x051c, REGPRIVATE.READWRITE);
                //SjcControl = new Regbyte(_deviceHandler, 0x0600, REGPRIVATE.READWRITE);
                //SjcGainControl = new RegUInt32(_deviceHandler, 0x0604, REGPRIVATE.READWRITE);
                //SjcSettlingTime = new RegUInt32(_deviceHandler, 0x0608, REGPRIVATE.READWRITE);
                //SjcCdacI = new RegUInt32(_deviceHandler, 0x060c, REGPRIVATE.READWRITE);
                //SjcCdacQ = new RegUInt32(_deviceHandler, 0x0610, REGPRIVATE.READWRITE);
                //SjcResultI = new RegUInt32(_deviceHandler, 0x0614, REGPRIVATE.READONLY);
                //SjcResultQ = new RegUInt32(_deviceHandler, 0x0618, REGPRIVATE.READONLY);
                //AnalogEnable = new RegUInt32(_deviceHandler, 0x0700, REGPRIVATE.READWRITE);
                //InventoryRoundControl = new RegInventoryRoundControl(_deviceHandler); // for E710 only
                //InventoryRoundControl_2 = new RegUInt32(_deviceHandler, 0x1004, REGPRIVATE.READWRITE); // for E710 only
                //NominalStopTime = new RegUInt16(_deviceHandler, 0x1008, REGPRIVATE.READWRITE);
                //ExtendedStopTime = new RegUInt16(_deviceHandler, 0x100c, REGPRIVATE.READWRITE);
                //RegulatoryStopTime = new RegUInt16(_deviceHandler, 0x1010, REGPRIVATE.READWRITE);
                //Gen2SelectEnable = new RegUInt16(_deviceHandler, 0x1014, REGPRIVATE.READWRITE);
                //Gen2AccessEnable = new RegUInt16(_deviceHandler, 0x1018, REGPRIVATE.READWRITE);
                //Gen2Offsets = new Regbyte(_deviceHandler, 0x1020, REGPRIVATE.READWRITE);
                //Gen2Lengths = new RegUInt16(_deviceHandler, 0x1030, REGPRIVATE.READWRITE);
                //Gen2TransactionIds = new Regbyte(_deviceHandler, 0x1050, REGPRIVATE.READWRITE);
                //Gen2TxnControls = new RegUInt32(_deviceHandler, 0x1060, REGPRIVATE.READWRITE);
                //Gen2TxBuffer = new RegByteArray(_deviceHandler, 0x1100, 128, REGPRIVATE.READWRITE);
                LoopStyle = new RegUInt32(_deviceHandler, 0x3000, REGPRIVATE.READWRITE);
                HopStyle = new Regbyte(_deviceHandler, 0x3008, REGPRIVATE.READWRITE);
                RegulatoryNoEmissionTime = new RegUInt16(_deviceHandler, 0x3010, REGPRIVATE.READWRITE);
                CountryEnum = new RegUInt16(_deviceHandler, 0x3014, REGPRIVATE.READWRITE);
                FrequencyChannelIndex = new Regbyte(_deviceHandler, 0x3018, REGPRIVATE.READWRITE);
                AntennaPortConfig = new RegAntennaPortConfig(_deviceHandler);
                SelectConfiguration = new RegSelectConfiguration(_deviceHandler);
                MultibankReadConfig = new RegMultibankReadConfig(_deviceHandler);
                MultibankWriteConfig = new RegMultibankWriteConfig(_deviceHandler);
                AccessPassword = new RegUInt32(_deviceHandler, 0x38a6, REGPRIVATE.READWRITE);
                KillPassword = new RegUInt32(_deviceHandler, 0x38aa, REGPRIVATE.READWRITE);
                LockMask = new RegUInt16(_deviceHandler, 0x38ae, REGPRIVATE.READWRITE);
                LockAction = new RegUInt16(_deviceHandler, 0x38b0, REGPRIVATE.READWRITE);
                DuplicateEliminationRollingWindow = new Regbyte(_deviceHandler, 0x3900, REGPRIVATE.READWRITE);
                TagCacheTableCurrentSize = new RegUInt16(_deviceHandler, 0x3902, REGPRIVATE.READWRITE);
                TagCacheStatus = new Regbyte(_deviceHandler, 0x3904, REGPRIVATE.READWRITE);
                EventPacketUplinkEnable = new RegUInt16(_deviceHandler, 0x3906, REGPRIVATE.READWRITE);
                IntraPacketDelay = new Regbyte(_deviceHandler, 0x3908, REGPRIVATE.READWRITE);
                RssiFilteringConfig = new Regbyte(_deviceHandler, 0x390a, REGPRIVATE.READWRITE);
                RssiThreshold = new RegUInt16(_deviceHandler, 0x390c, REGPRIVATE.READWRITE);
                AuthenticateConfig = new RegUInt24(_deviceHandler, 0x390e, REGPRIVATE.READWRITE);
                AuthenticateMessage = new RegByteArray(_deviceHandler, 0x3912, 32, REGPRIVATE.READWRITE);
                AuthenticateResponseLen = new RegUInt16(_deviceHandler, 0x3944, REGPRIVATE.READWRITE);
                ReversePowerADC = new RegUInt16(_deviceHandler, 0x3946, REGPRIVATE.READWRITE);
                CurrentPort = new Regbyte(_deviceHandler, 0x3948, REGPRIVATE.READWRITE);
                ModelName = new Regstring(_deviceHandler, 0x5000, 32, REGPRIVATE.READONLY);
                SerialNumber_1 = new Regstring(_deviceHandler, 0x5020, 32, REGPRIVATE.READONLY);
                CountryEnum_1 = new RegUInt16(_deviceHandler, 0x5040, REGPRIVATE.READONLY);
                EF98 = new RegUInt32(_deviceHandler, 0xef98, REGPRIVATE.READONLY);
                EF9C = new Regstring(_deviceHandler, 0xef9c, 16, REGPRIVATE.READONLY);
                EFAC = new RegUInt32(_deviceHandler, 0xefac, REGPRIVATE.READONLY);
                EFB0 = new RegUInt32(_deviceHandler, 0xefb0, REGPRIVATE.READONLY);
            }
        }

        CSLRFIDREGISTER RFIDRegister;
        /*
                VersionString 8, 32
                BuildNumber 28, 4
                Githash 2c, 4
                FrefFreq 34, 4
                ProductSku 68, 8
                SerialNumber 70, 32
                DeviceInfo 90, 4
                DeviceBuild 94, 4
                RtlRevision 98, 4
                Model Name 5000, 32
                Serial Number 5020, 32
                Country Enum 5040, 2
        */
        /*
                int[,] ReaderOEMDDataAddress = new int[,] { { 0x0008, 32 },
                                                            { 0x0028, 4 },
        //                                                    { 0x002c, 4 },
        //                                                    { 0x0034, 4 },
        //                                                    { 0x0068, 8 },
        //                                                    { 0x0070, 32 },
        //                                                    { 0x0090, 4 },
        //                                                    { 0x0094, 4 },
        //                                                    { 0x0098, 4 },
                                                            { 0x5000, 32 },
                                                            { 0x5020, 32 },
                                                            { 0x5040, 2 },
        //                                                    { 0xef98, 4 },
        //                                                    { 0xefac, 4 },
        //                                                    { 0xefb0, 4 },
                                                            { 0x3014, 2 },
                                                            { 0x3018, 1 }
        */
        int[,] ReaderOEMDDataAddress = new int[,] { { 0x0008, 32 },
                                                    { 0x0028, 4 },
                                                    { 0x3014, 2 },
                                                    { 0x3018, 1 },
                                                    { 0x5000, 32 },
                                                    { 0x5040, 2 },
                                                    { 0xef98, 4 },
                                                    { 0xef9c, 16 },
                                                    { 0xefac, 4 },
                                                    { 0xefb0, 4 }
    };

        public bool RegisterInitialize_CS710S()
        {
            RFIDRegister = new CSLRFIDREGISTER(this);

            READREGISTERSET[] OEMDataAddress = new READREGISTERSET[ReaderOEMDDataAddress.GetLength(0)]; 

            for (int cnt = 0; cnt < ReaderOEMDDataAddress.GetLength(0); cnt++)
                OEMDataAddress[cnt] = new READREGISTERSET(ReaderOEMDDataAddress[cnt, 0], ReaderOEMDDataAddress[cnt, 1]);

            ReadRegister(OEMDataAddress);
            return true;
		}

        internal class READREGISTERSET
        {
            public int address;
            public int size;

            public READREGISTERSET (int address, int size)
            {
                this.address = address;
                this.size = size;
            }
            public READREGISTERSET(Regbyte reg)
            {
                this.address = reg.regAdd;
                this.size = 1;
            }
            public READREGISTERSET(RegUInt16 reg)
            {
                this.address = reg.regAdd;
                this.size = 2;
            }
            public READREGISTERSET(RegUInt32 reg)
            {
                this.address = reg.regAdd;
                this.size = 4;
            }
            public READREGISTERSET(RegUInt64 reg)
            {
                this.address = reg.regAdd;
                this.size = 8;
            }
            public READREGISTERSET(Regstring reg)
            {
                this.address = reg.regAdd;
                this.size = reg.maxlen;
            }
            public READREGISTERSET(RegByteArray reg)
            {
                this.address = reg.regAdd;
                this.size = reg.value.Length;
            }
        }

        byte[] RfidCmdpack(SCSLRFIDCMD cmd, byte[] payload)
		{
            byte[] datapacket = new byte[7 + payload.Length];

            datapacket[0] = 0x80;
            datapacket[1] = 0xb3;
            datapacket[2] = (byte)((int)cmd >> 8);
            datapacket[3] = (byte)cmd;
            datapacket[4] = 0x00;
            datapacket[5] = (byte)(payload.Length >> 8);
            datapacket[6] = (byte)payload.Length;

            if (payload.Length > 0)
                Array.Copy(payload, 0, datapacket, 7, payload.Length);

            return datapacket;
        }

        void SaveInitRegisters(int index, byte[]data, int size)
        {
            /*
                        RFIDRegister.VersionString.Set(System.Text.Encoding.Default.GetString(data, index, RFIDRegister.VersionString.maxlen));
                        RFIDRegister.BuildNumber.Set(System.Text.Encoding.Default.GetString(data, index + 32, RFIDRegister.BuildNumber.maxlen));
                        RFIDRegister.Githash.Set(Tools.Hex.MSBToUInt32(data, index + 36));
                        RFIDRegister.FrefFreq.Set(Tools.Hex.MSBToUInt32(data, index + 40));
                        RFIDRegister.ProductSku.Set(Tools.Hex.MSBToUInt64(data, index + 44));
                        RFIDRegister.SerialNumber.Set(System.Text.Encoding.Default.GetString(data, index + 52, RFIDRegister.BuildNumber.maxlen));
                        RFIDRegister.DeviceInfo.Set(Tools.Hex.MSBToUInt32(data, index + 84));
                        RFIDRegister.DeviceBuild.Set(Tools.Hex.MSBToUInt32(data, index + 88));
                        RFIDRegister.RtlRevision.Set(Tools.Hex.MSBToUInt32(data, index + 92));
                        RFIDRegister.ModelName.Set(System.Text.Encoding.Default.GetString(data, index + 96, RFIDRegister.ModelName.maxlen));
                        RFIDRegister.SerialNumber_1.Set(System.Text.Encoding.Default.GetString(data, index + 128, RFIDRegister.SerialNumber_1.maxlen));
                        RFIDRegister.CountryEnum_1.Set(Tools.Hex.MSBToUInt16(data, index + 160));
                        RFIDRegister.EF98.Set(Tools.Hex.MSBToUInt32(data, index + 162));
                        RFIDRegister.EFAC.Set(Tools.Hex.MSBToUInt32(data, index + 166));
                        RFIDRegister.EFB0.Set(Tools.Hex.MSBToUInt32(data, index + 170));
                        RFIDRegister.CountryEnum.Set(Tools.Hex.MSBToUInt16(data, index + 174));
                        RFIDRegister.FrequencyChannelIndex.Set(data[index + 176]);
            */

            RFIDRegister.VersionString.Set(System.Text.Encoding.Default.GetString(data, index, RFIDRegister.VersionString.maxlen));
            RFIDRegister.BuildNumber.Set(System.Text.Encoding.Default.GetString(data, index + 32, RFIDRegister.BuildNumber.maxlen));
            RFIDRegister.CountryEnum.Set(Tools.Hex.MSBToUInt16(data, index + 36));
            RFIDRegister.FrequencyChannelIndex.Set(data[index + 38]);
            RFIDRegister.ModelName.Set(System.Text.Encoding.Default.GetString(data, index + 39, RFIDRegister.ModelName.maxlen));
            RFIDRegister.CountryEnum_1.Set(Tools.Hex.MSBToUInt16(data, index + 71));
            RFIDRegister.EF98.Set(Tools.Hex.MSBToUInt32(data, index + 73));
            RFIDRegister.EF9C.Set(System.Text.Encoding.Default.GetString(data, index + 77, RFIDRegister.EF9C.maxlen));
            RFIDRegister.EFAC.Set(Tools.Hex.MSBToUInt32(data, index + 93));
            RFIDRegister.EFB0.Set(Tools.Hex.MSBToUInt32(data, index + 97));

            m_oem_machine = MODEL.CS710S;
            m_oem_country_code = RFIDRegister.EF98.Get();
            m_oem_special_country_version = RFIDRegister.EFAC.Get();
            m_oem_freq_modification_flag = (uint)RFIDRegister.EFB0.Get();
            
            switch (m_oem_country_code)
            {
                case 0x01:
                    m_save_region_code = RegionCode.ETSI;
                    break;

                case 0x02:
                    m_save_region_code = RegionCode.FCC;
                    break;
            }
        }


        /// <summary>
        /// return : data length
        /// </summary>
        /// <param name="add"></param>
        /// <param name="data"></param>
        /// <param name="index"></param>
        /// <returns></returns>
/*
        int SaveRegister(int add, byte[] data, int index)
        {
            switch (add)
            {
                case 0x0008:
                    RFIDRegister.VersionString.value = System.Text.Encoding.Default.GetString(data, index, 32);
                    return 32;

                case 0x0028:
                    RFIDRegister.BuildNumber.value = System.Text.Encoding.Default.GetString(data, index, 32);
                    return 32;

                case 0x002c:
                    RFIDRegister.Githash.value = BitConverter.ToUInt32(data, index);
                    return 1;

                case 0x5000:
                    RFIDRegister.ModelName.value = System.Text.Encoding.Default.GetString(data, index, 32);
                    return 32;

                case 0x5020:
                    RFIDRegister.SerialNumber_1.value = System.Text.Encoding.Default.GetString(data, index, 32);
                    return 32;

                case 0x5040:
                    RFIDRegister.CountryEnum_1.value = BitConverter.ToUInt16(data, index);
                    return 2;
            }

            return 0;
        }
*/
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/Comm_Protocol/Ex10Commands/ClassRFID.UplinkPackets.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;

using CSLibrary;
using CSLibrary.Structures;
using CSLibrary.Constants;
using System.Net.Sockets;
using CSLibrary.Barcode.Constants;
using System.Linq.Expressions;


namespace CSLibrary
{
    public partial class RFIDReader
    {
        internal enum RFIDPACKETCODE
        {
            csl_tag_read_epc_only_new = 0x3001,
            csl_tag_read_epc_only_recurrent = 0x3002,
            csl_tag_read_multibank_new = 0x3003,
            csl_tag_read_multibank_recurrent_index_only = 0x3004,
            csl_tag_read_compact = 0x3006,
            csl_miscellaneous_event = 0x3007,
            csl_operation_complete = 0x3008,
            csl_access_complete = 0x3009,
        }


        internal void UplinkPacketsProcess (byte[] data, int index)
        {
            UInt16 fixedHeader  = BitConverter.ToUInt16(data, index);
            RFIDPACKETCODE packetCode = (RFIDPACKETCODE)BitConverter.ToUInt16(data, index);
            byte sequenceNumber = data[index + 4];
            UInt16 payloadLen = BitConverter.ToUInt16(data, index + 5);

            if ((payloadLen + 7 - 1) > data.Length)
                return;

            switch (packetCode)
            {
                case RFIDPACKETCODE.csl_tag_read_epc_only_new:
                    csl_tag_read_epc_only_new_packet_proc(data, index);
                    break;

                case RFIDPACKETCODE.csl_tag_read_epc_only_recurrent:
                    TagReadEPCOnlyRecurrent(data, index);
                    break;

                case RFIDPACKETCODE.csl_tag_read_multibank_new:
                    TagReadMultiBankNew(data, index);
                    break;

                case RFIDPACKETCODE.csl_tag_read_multibank_recurrent_index_only:
                    TagReadMultiBankRecurrentIndexOnly(data, index);
                    break;

                case RFIDPACKETCODE.csl_tag_read_compact:
                    csl_tag_read_epc_only_new_packet_proc(data, 8);
                    break;

                case RFIDPACKETCODE.csl_miscellaneous_event:
                    MiscellaneousEvent(data, index);
                    break;

                case RFIDPACKETCODE.csl_operation_complete:
                    OperationComplete(data, index);
                    break;

                case RFIDPACKETCODE.csl_access_complete:
                    AccessComplete(data, index);
                    break;
            }
        }

        internal void TagReadEPCOnlyRecurrent(byte[] data, int index)
        {
            UInt32 UTCTimpStamp = BitConverter.ToUInt32(data, index);
            UInt16 RSSI = BitConverter.ToUInt16(data, index);
            UInt16 rf_phase_begin = BitConverter.ToUInt16(data, index);
            UInt16 rf_phase_end = BitConverter.ToUInt16(data, index);
            byte PortNumber = data[index];
            UInt16 TagIndex = BitConverter.ToUInt16(data, index);
        }

        internal void TagReadMultiBankNew(byte[] data, int index)
        {
            UInt32 UTCTimpStamp = BitConverter.ToUInt32(data, index);
            UInt16 RSSI = BitConverter.ToUInt16(data, index);
            UInt16 rf_phase_begin = BitConverter.ToUInt16(data, index);
            UInt16 rf_phase_end = BitConverter.ToUInt16(data, index);
            byte PortNumber = data[index];
            UInt16 TagIndex = BitConverter.ToUInt16(data, index);
            byte[] EPCBankData;
            byte NumberofExtraBanks;
            byte[] ExtraBankIndex;
        }

        internal void TagReadMultiBankRecurrentIndexOnly(byte[] data, int index)
        {
            UInt32 UTCTimpStamp = BitConverter.ToUInt32(data, index);
            UInt16 RSSI = BitConverter.ToUInt16(data, index);
            UInt16 rf_phase_begin = BitConverter.ToUInt16(data, index);
            UInt16 rf_phase_end = BitConverter.ToUInt16(data, index);
            byte PortNumber = data[index];
            UInt16 TagIndex = BitConverter.ToUInt16(data, index);
        }

        internal void MiscellaneousEvent(byte[] data, int index)
        {
            UInt32 UTCTimpStamp = BitConverter.ToUInt32(data, index);
            UInt16 EventCode = BitConverter.ToUInt16(data, index);
            byte[] Data;
        }

        internal void OperationComplete(byte[] data, int index)
        {
            UInt32 UTCTimpStamp = BitConverter.ToUInt32(data, index);
            UInt16 CommandCode = BitConverter.ToUInt16(data, index);
            UInt16 Status;
        }

        // 0x3001 packet
        void csl_tag_read_epc_only_new_packet_proc(byte[] data, int index)
        {
            try
            {

                UInt32 UTCTimeStamp = Tools.Hex.MSBToUInt32(data, index);
                UInt16 rf_phase_begin = Tools.Hex.MSBToUInt16(data, index + 6);
                UInt16 rf_phase_end = Tools.Hex.MSBToUInt16(data, index + 8);
                byte PortNumber = data[index + 10];
                UInt16 Tag_Index = Tools.Hex.MSBToUInt16(data, index + 13);

                int rssidBm100;
                {
                    byte hiByte = data[index + 4];
                    rssidBm100 = Tools.Hex.MSBToUInt16 (data, index + 4);

                    if (hiByte > 0x7f)
                        rssidBm100 -= 0x10000;
                }

                index += 15;
                //while (index < data.Length)
                {
                    CSLibrary.Constants.CallbackType type = CSLibrary.Constants.CallbackType.TAG_RANGING;
                    CSLibrary.Structures.TagCallbackInfo info = new CSLibrary.Structures.TagCallbackInfo();

                    info.pc = new S_PC(Tools.Hex.MSBToUInt16(data, index));
                    index += 2;

                    if (info.pc.XI) // Check XPC W1
                    {
                        info.xpc_w1 = new S_XPC_W1(Tools.Hex.MSBToUInt16(data, index));
                        index += 2;

                        if (info.xpc_w1.XEB) // Check XPC W2
                        {
                            info.xpc_w2 = new S_XPC_W2(Tools.Hex.MSBToUInt16(data, index));
                            index += 2;
                        }
                    }

                    int epcbytelen = ((info.pc >> 11) << 1);
                    byte[] epc = new byte[epcbytelen];
                    Array.Copy(data, index, epc, 0, epcbytelen);
                    info.epc = new S_EPC(epc);
                    index += epcbytelen;

                    info.antennaPort = PortNumber;
                    info.rssidBm = rssidBm100 / 100;
                    info.rssi = Tools.dBConverion.dBm2dBuV(info.rssidBm) ;

                    info.Bank1Data = new ushort[0];
                    info.Bank2Data = new ushort[0];
                    info.Bank3Data = new ushort[0];

                    if (OnAsyncCallback != null)
                    {
                        try
                        {
                            CSLibrary.Events.OnAsyncCallbackEventArgs callBackData = new Events.OnAsyncCallbackEventArgs(info, type);

                            OnAsyncCallback(_deviceHandler, callBackData);
                        }
                        catch (Exception ex)
                        {
                            CSLibrary.Debug.WriteLine("OnAsyncCallback Error : " + ex.Message);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("csl_tag_read_epc_only_new_packet_proc Error : " + ex.Message);
            }
        }

        bool checkmultibankzero(UInt16[] multibankdata)
        {
            foreach (var data in multibankdata)
                if (data != 0)
                    return false;

            return true;
        }

        // 0x3003 packet
        void csl_tag_read_multibank_new_packet_proc(byte[] data, int index)
        {
            try
            {
                UInt32 UTCTimeStamp = Tools.Hex.MSBToUInt32(data, index);
                UInt16 rf_phase_begin = Tools.Hex.MSBToUInt16(data, index + 6);
                UInt16 rf_phase_end = Tools.Hex.MSBToUInt16(data, index + 8);
                byte PortNumber = data[index + 10];
                UInt16 Tag_Index = Tools.Hex.MSBToUInt16(data, index + 13);

                int rssidBm100;
                {
                    byte hiByte = data[index + 4];
                    rssidBm100 = Tools.Hex.MSBToUInt16(data, index + 4);

                    if (hiByte > 0x7f)
                        rssidBm100 -= 0x10000;
                }

                index += 15;
                //while (index < data.Length)
                {
                    CSLibrary.Constants.CallbackType type = CSLibrary.Constants.CallbackType.TAG_RANGING;
                    CSLibrary.Structures.TagCallbackInfo info = new CSLibrary.Structures.TagCallbackInfo();

                    info.pc = new S_PC(Tools.Hex.MSBToUInt16(data, index));
                    index += 2;

                    if (info.pc.XI) // Check XPC W1
                    {
                        info.xpc_w1 = new S_XPC_W1(Tools.Hex.MSBToUInt16(data, index));
                        index += 2;

                        if (info.xpc_w1.XEB) // Check XPC W2
                        {
                            info.xpc_w2 = new S_XPC_W2(Tools.Hex.MSBToUInt16(data, index));
                            index += 2;
                        }
                    }

                    int epcbytelen = ((info.pc >> 11) << 1);
                    byte[] epc = new byte[epcbytelen];
                    Array.Copy(data, index, epc, 0, epcbytelen);
                    info.epc = new S_EPC(epc);
                    index += epcbytelen;

                    info.antennaPort = PortNumber;
                    info.rssidBm = rssidBm100 / 100;
                    info.rssi = Tools.dBConverion.dBm2dBuV(info.rssidBm);

                    info.Bank1Data = new ushort[0];
                    info.Bank2Data = new ushort[0];
                    info.Bank3Data = new ushort[0];
                    if (data[index] == m_rdr_opt_parms.TagRanging.multibankswithreply)
                    {
                        index++;
                        if (m_rdr_opt_parms.TagRanging.multibanks > 0)
                            info.Bank1Data = Tools.Hex.MSBToUInt16Array(data, index, m_rdr_opt_parms.TagRanging.count1);
                        if (m_rdr_opt_parms.TagRanging.multibanks > 1)
                            info.Bank2Data = Tools.Hex.MSBToUInt16Array(data, index + (m_rdr_opt_parms.TagRanging.count1 * 2), m_rdr_opt_parms.TagRanging.count2);
                        if (m_rdr_opt_parms.TagRanging.multibanks > 2)
                            info.Bank3Data = Tools.Hex.MSBToUInt16Array(data, index + ((m_rdr_opt_parms.TagRanging.count1 + m_rdr_opt_parms.TagRanging.count2) * 2), m_rdr_opt_parms.TagRanging.count3);
                    }

                    if (_currentTagRanging.multibankswithreply >= 3)
                    {
                        if (_currentTagRanging.bank3 == MemoryBank.TID)
                            if (checkmultibankzero(info.Bank3Data))
                                return;
                    }

                    if (_currentTagRanging.multibankswithreply >= 2)
                    {
                        if (_currentTagRanging.bank2 == MemoryBank.TID)
                            if (checkmultibankzero(info.Bank2Data))
                                return;
                    }

                    if (_currentTagRanging.multibankswithreply >= 1)
                    {
                        if (_currentTagRanging.bank1 == MemoryBank.TID)
                            if (checkmultibankzero(info.Bank1Data))
                                return;
                    }

                    CSLibrary.Events.OnAsyncCallbackEventArgs callBackData = new Events.OnAsyncCallbackEventArgs(info, type);

                    if (OnAsyncCallback != null)
                        try
                        {
                            OnAsyncCallback(_deviceHandler, callBackData);
                        }
                        catch (Exception ex)
                        {
                            CSLibrary.Debug.WriteLine("OnAsyncCallback Error : " + ex.Message);
                        }
                }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("csl_tag_read_multibank_new_packet_proc Error : " + ex.Message);
            }
        }

        // 0x3006 packet
        internal void csl_tag_read_compact_packet_proc(byte[] data, int index)
        {
            try
            {
                UInt32 UTCTimeStamp = Tools.Hex.MSBToUInt32(data, index);

                index += 6;
                while (index < data.Length)
                {
                    CSLibrary.Constants.CallbackType type = CSLibrary.Constants.CallbackType.TAG_RANGING;
                    CSLibrary.Structures.TagCallbackInfo info = new CSLibrary.Structures.TagCallbackInfo();

                    //var PC = BitConverter.ToUInt16(data, index);
                    //info.pc = new S_PC(PC);
                    info.pc = new S_PC((UInt16)(data[index] << 8 | data[index + 1]));
                    index += 2;

                    if (info.pc.XI) // Check XPC W1
                    {
                        info.xpc_w1 = new S_XPC_W1((UInt16)(data[index] << 8 | data[index + 1]));
                        index += 2;

                        if (info.xpc_w1.XEB) // Check XPC W2
                        {
                            info.xpc_w2 = new S_XPC_W2((UInt16)(data[index] << 8 | data[index + 1]));
                            index += 2;
                        }
                    }

                    int epcbytelen = ((info.pc >> 11) << 1);
                    byte[] epc = new byte[epcbytelen];
                    Array.Copy(data, index, epc, 0, epcbytelen);
                    info.epc = new S_EPC(epc);
                    index += epcbytelen;


                    int rssidBm100;
                    {
                        byte hiByte = data[index];
                        rssidBm100 = ((int)(data[index] << 8 | data[index + 1]));

                        if (hiByte > 0x7f)
                            rssidBm100 -= 0x10000;
                    }
                    info.rssidBm = rssidBm100 / 100;
                    info.rssi = Tools.dBConverion.dBm2dBuV(info.rssidBm);

                    index += 2;

                    info.Bank1Data = new ushort[0];
                    info.Bank2Data = new ushort[0];
                    info.Bank3Data = new ushort[0];

                    /*
                                    if (RFIDRegister.AntennaPortConfig.FastId() && info.pc.EPCLength >= 6 && epc[epcbytelen - 12] == 0xe2 && epc[epcbytelen - 11] == 0x80 && epc[epcbytelen - 10] == 0x11)
                                    {
                                        byte[] newbyteEpc = new byte[epcbytelen - 12];
                                        UInt16[] newbyteTid = new UInt16[6];

                                        Array.Copy(epc, 0, newbyteEpc, 0, newbyteEpc.Length);
                                        ArrayCopy(epc, epcbytelen - 12, newbyteTid, 0, 12);

                                        info.FastTid = newbyteTid;
                                        epc = newbyteEpc;
                                    }
                                    else
                                        info.FastTid = new UInt16[0];
                    */

                    CSLibrary.Events.OnAsyncCallbackEventArgs callBackData = new Events.OnAsyncCallbackEventArgs(info, type);

                    if (OnAsyncCallback != null)
                        try
                        {
                            OnAsyncCallback(_deviceHandler, callBackData);
                        }
                        catch (Exception ex)
                        {
                            CSLibrary.Debug.WriteLine("OnAsyncCallback Error : " + ex.Message);
                        }
                }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("csl_tag_read_compact_packet_proc Error : " + ex.Message);
            }
        }

        // 0x3007 packet
        void csl_miscellaneous_event_packet_proc(byte[] data, int index, int len)
        {
            try
            {
            UInt32 UTCTimeStamp = Tools.Hex.MSBToUInt32(data, index);
            UInt16 eventCode = Tools.Hex.MSBToUInt16(data, index + 4);

            Debug.WriteLine("{0:X4} : 0x3007, {1:X2}", UTCTimeStamp, eventCode);

            switch (eventCode)
            {
                case 0x0001: // keep alive
                    break;

                case 0x0002: // inventory round end
                    break;

                case 0x0003: // CRC error rate (2 bytes Data)
                    break;

                case 0x0004: // tag rate value (2 bytes Data)
                    {
                        uint tagRate = Tools.Hex.MSBToUInt16(data, index + 6);

                        if (OnInventoryTagRateCallback != null)
                        {
                            try
                            {
                                OnInventoryTagRateCallback(this, new Events.OnInventoryTagRateCallbackEventArgs(tagRate));
                            }
                            catch (Exception ex)
                            {
                                CSLibrary.Debug.WriteLine("csl_miscellaneous_event call back error : " + ex.Message);
                            }
                        }
                    }
                    break;

                default:
                    CSLibrary.Debug.WriteLine("csl_miscellaneous_event Event Code : " + eventCode.ToString());
                    break;
            }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("csl_miscellaneous_event_packet_proc Error : " + ex.Message);
            }
        }

        // 0x3009 packet
        void csl_access_complete_packet_proc(byte[] data, int index, int size)
        {
            UInt32 UTCTimeStamp = Tools.Hex.MSBToUInt32(data, index);
            UInt16 accessCommand = Tools.Hex.MSBToUInt16(data, index + 4);
            byte tagErrorCode = data[index + 6];
            byte macErrorCode = data[index + 7];
            UInt16 writeWordCount = Tools.Hex.MSBToUInt16(data, index + 8);

            Operation RealCurrentOperation = (Operation)(_deviceHandler._currentCmdRemark);

            if (tagErrorCode != 0x10 || macErrorCode != 0x00)
                Debug.WriteLine("Tag Access Error, {0:2X}, {1:2X}", tagErrorCode, macErrorCode);

            switch (accessCommand)
            {
                case 0xC2: // Read
                    switch (RealCurrentOperation)
                    {
                        case CSLibrary.Constants.Operation.TAG_READ:
                            if (tagErrorCode == 0x10 && macErrorCode == 0x00)
                                ArrayCopy(data, index + 12, m_rdr_opt_parms.TagRead.m_pData, 0, m_rdr_opt_parms.TagRead.count * 2);
                            FireAccessCompletedEvent(
                            new CSLibrary.Events.OnAccessCompletedEventArgs(
                                (tagErrorCode == 0x10 && macErrorCode == 0x00),
                                CSLibrary.Constants.Bank.SPECIFIC,
                                TagAccess.READ,
                                m_rdr_opt_parms.TagRead.pData));
                            break;

                        case CSLibrary.Constants.Operation.TAG_READ_PC:
                            if (tagErrorCode == 0x10 && macErrorCode == 0x00)
                                m_rdr_opt_parms.TagReadPC.m_pc = Tools.Hex.MSBToUInt16(data, index + 12);
                            FireAccessCompletedEvent(
                                new CSLibrary.Events.OnAccessCompletedEventArgs(
                                (tagErrorCode == 0x10 && macErrorCode == 0x00),
                                CSLibrary.Constants.Bank.PC,
                                CSLibrary.Constants.TagAccess.READ,
                                m_rdr_opt_parms.TagReadPC.pc));
                            break;

                        case CSLibrary.Constants.Operation.TAG_READ_EPC:
                            if (tagErrorCode == 0x10 && macErrorCode == 0x00)
                                ArrayCopy(data, index + 12, m_rdr_opt_parms.TagReadEPC.m_epc, 0, m_rdr_opt_parms.TagReadEPC.count * 2);
                            FireAccessCompletedEvent(
                                new CSLibrary.Events.OnAccessCompletedEventArgs(
                                (tagErrorCode == 0x10 && macErrorCode == 0x00),
                                Bank.EPC,
                                TagAccess.READ,
                                m_rdr_opt_parms.TagReadEPC.epc));
                            break;

                        case CSLibrary.Constants.Operation.TAG_READ_ACC_PWD:
                            if (tagErrorCode == 0x10 && macErrorCode == 0x00)
                                m_rdr_opt_parms.TagReadAccPwd.m_password = Tools.Hex.MSBToUInt32(data, index + 12);
                            FireAccessCompletedEvent(
                                new CSLibrary.Events.OnAccessCompletedEventArgs(
                                (tagErrorCode == 0x10 && macErrorCode == 0x00),
                                CSLibrary.Constants.Bank.ACC_PWD,
                                CSLibrary.Constants.TagAccess.READ,
                                m_rdr_opt_parms.TagReadAccPwd.password));
                            break;

                        case CSLibrary.Constants.Operation.TAG_READ_KILL_PWD:
                            if (tagErrorCode == 0x10 && macErrorCode == 0x00)
                                m_rdr_opt_parms.TagReadKillPwd.m_password = Tools.Hex.MSBToUInt32(data, index + 12);
                            FireAccessCompletedEvent(
                                new CSLibrary.Events.OnAccessCompletedEventArgs(
                                (tagErrorCode == 0x10 && macErrorCode == 0x00),
                                CSLibrary.Constants.Bank.KILL_PWD,
                                CSLibrary.Constants.TagAccess.READ,
                                m_rdr_opt_parms.TagReadKillPwd.password));
                            break;

                        case CSLibrary.Constants.Operation.TAG_READ_TID:
                            if (tagErrorCode == 0x10 && macErrorCode == 0x00)
                                ArrayCopy(data, index + 12, m_rdr_opt_parms.TagReadTid.pData, 0, m_rdr_opt_parms.TagReadTid.count * 2);
                            FireAccessCompletedEvent(
                                new CSLibrary.Events.OnAccessCompletedEventArgs(
                                (tagErrorCode == 0x10 && macErrorCode == 0x00),
                                CSLibrary.Constants.Bank.TID,
                                CSLibrary.Constants.TagAccess.READ,
                                m_rdr_opt_parms.TagReadTid.tid));
                            break;

                        case CSLibrary.Constants.Operation.TAG_READ_USER:
                            if (tagErrorCode == 0x10 && macErrorCode == 0x00)
                                ArrayCopy(data, index + 12, m_rdr_opt_parms.TagReadUser.m_pData, 0, m_rdr_opt_parms.TagReadUser.count * 2);
                            FireAccessCompletedEvent(
                                new CSLibrary.Events.OnAccessCompletedEventArgs(
                                (tagErrorCode == 0x10 && macErrorCode == 0x00),
                                Bank.USER,
                                TagAccess.READ,
                                m_rdr_opt_parms.TagReadUser.pData));
                            break;

                        case CSLibrary.Constants.Operation.TAG_AUTHENTICATE:
/*
                            {
                                int pkt_len = recvData[5] << 8 | recvData[4];
                                int flags = recvData[1];
                                int len = ((pkt_len - 3) * 4) - ((flags >> 6) & 3);
                                byte[] response = new byte[len];
                                Array.Copy(recvData, offset + 20, response, 0, len);
                                m_rdr_opt_parms.TagAuthenticate.pData = new S_DATA(response);
                                //Array.Copy(recvData, offset + 20, m_rdr_opt_parms.TagAuthenticate.pData, 0, len);
                            }
*/
                            break;
                    }
                    break;

                case 0xC3: // Write
                    switch (RealCurrentOperation)
                    {
                        case CSLibrary.Constants.Operation.TAG_WRITE:
                            if (m_rdr_opt_parms.TagWrite.bank == MemoryBank.USER)
                            {
                                FireAccessCompletedEvent(
                                new CSLibrary.Events.OnAccessCompletedEventArgs(
                                    (tagErrorCode == 0x10 && macErrorCode == 0x00 && writeWordCount != 0),
                                    CSLibrary.Constants.Bank.SPECIFIC,
                                    TagAccess.WRITE,
                                    m_rdr_opt_parms.TagRead.pData));
                            }
                            else
                            {
                                FireAccessCompletedEvent(
                                new CSLibrary.Events.OnAccessCompletedEventArgs(
                                    (tagErrorCode == 0x10 && macErrorCode == 0x00 && writeWordCount != 0),
                                    CSLibrary.Constants.Bank.SPECIFIC,
                                    TagAccess.WRITE,
                                    m_rdr_opt_parms.TagRead.pData));
                            }
                            break;

                        case CSLibrary.Constants.Operation.TAG_WRITE_PC:
                            FireAccessCompletedEvent(
                                new CSLibrary.Events.OnAccessCompletedEventArgs(
                                (tagErrorCode == 0x10 && macErrorCode == 0x00 && writeWordCount != 0),
                                CSLibrary.Constants.Bank.PC,
                                CSLibrary.Constants.TagAccess.WRITE,
                                m_rdr_opt_parms.TagReadPC.pc));
                            break;

                        case CSLibrary.Constants.Operation.TAG_WRITE_EPC:
                            FireAccessCompletedEvent(
                                new CSLibrary.Events.OnAccessCompletedEventArgs(
                                (tagErrorCode == 0x10 && macErrorCode == 0x00 && writeWordCount != 0),
                                Bank.EPC,
                                TagAccess.WRITE,
                                m_rdr_opt_parms.TagReadEPC.epc));
                            break;

                        case CSLibrary.Constants.Operation.TAG_WRITE_ACC_PWD:
                            FireAccessCompletedEvent(
                                new CSLibrary.Events.OnAccessCompletedEventArgs(
                                (tagErrorCode == 0x10 && macErrorCode == 0x00 && writeWordCount != 0),
                                CSLibrary.Constants.Bank.ACC_PWD,
                                CSLibrary.Constants.TagAccess.WRITE,
                                m_rdr_opt_parms.TagReadAccPwd.password));
                            break;

                        case CSLibrary.Constants.Operation.TAG_WRITE_KILL_PWD:
                            FireAccessCompletedEvent(
                                new CSLibrary.Events.OnAccessCompletedEventArgs(
                                (tagErrorCode == 0x10 && macErrorCode == 0x00 && writeWordCount != 0),
                                CSLibrary.Constants.Bank.KILL_PWD,
                                CSLibrary.Constants.TagAccess.WRITE,
                                m_rdr_opt_parms.TagReadKillPwd.password));
                            break;

                        case CSLibrary.Constants.Operation.TAG_WRITE_USER:
                            FireAccessCompletedEvent(
                                new CSLibrary.Events.OnAccessCompletedEventArgs(
                                (tagErrorCode == 0x10 && macErrorCode == 0x00 && writeWordCount != 0),
                                Bank.USER,
                                TagAccess.WRITE,
                                m_rdr_opt_parms.TagReadUser.pData));
                            break;
                    }
                    break;

                    /*
                case 0xC4: // Kill
                    {
                        FireAccessCompletedEvent(
                        new CSLibrary.Events.OnAccessCompletedEventArgs(
                        (tagErrorCode == 0x10 && macErrorCode == 0x00),
                            Bank.UNKNOWN,
                            TagAccess.KILL,
                            null));
                    }
                    break;
                    */
                case 0xC5: // Lock
                    {
                        FireAccessCompletedEvent(
                        new CSLibrary.Events.OnAccessCompletedEventArgs(
                        (tagErrorCode == 0x10 && macErrorCode == 0x00),
                            Bank.UNKNOWN,
                            TagAccess.LOCK,
                            null));
                    }
                    break;

                case 0xC6: // Access
                    break;

                case 0xC7: // Block Write
                    break;

                case 0xC9: // Block Permalock
                    break;

                case 0xD5: // Authenticate
                    {
                        byte[] response = new byte[size];
                        Array.Copy(data, index + 12, response, 0, size);
                        m_rdr_opt_parms.TagAuthenticate.pData = new S_DATA(response);

                        FireAccessCompletedEvent(
                        new CSLibrary.Events.OnAccessCompletedEventArgs(
                        (tagErrorCode == 0x10 && macErrorCode == 0x00),
                            Bank.UNKNOWN,
                            TagAccess.AUTHENTICATE,
                            null));
                    }
                    break;

                default:
                    Debug.WriteLine("Tag Access Command Error, {0:2X}, {1:2X}", accessCommand);
                    break;
            }

#if oldcode


                                        switch (RealCurrentOperation)
                                        {
                                            case CSLibrary.Constants.Operation.TAG_READ:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        CSLibrary.Constants.Bank.SPECIFIC,
                                                        TagAccess.READ,
                                                        m_rdr_opt_parms.TagRead.pData));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_READ_PC:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        CSLibrary.Constants.Bank.PC,
                                                        CSLibrary.Constants.TagAccess.READ,
                                                        m_rdr_opt_parms.TagReadPC.pc));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_READ_EPC:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.EPC,
                                                        TagAccess.READ,
                                                        m_rdr_opt_parms.TagReadEPC.epc));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_READ_ACC_PWD:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        CSLibrary.Constants.Bank.ACC_PWD,
                                                        CSLibrary.Constants.TagAccess.READ,
                                                        m_rdr_opt_parms.TagReadAccPwd.password));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_READ_KILL_PWD:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        CSLibrary.Constants.Bank.KILL_PWD,
                                                        CSLibrary.Constants.TagAccess.READ,
                                                        m_rdr_opt_parms.TagReadKillPwd.password));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_READ_TID:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        CSLibrary.Constants.Bank.TID,
                                                        CSLibrary.Constants.TagAccess.READ,
                                                        m_rdr_opt_parms.TagReadTid.tid));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_READ_USER:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.USER,
                                                        TagAccess.READ,
                                                        m_rdr_opt_parms.TagReadUser.pData));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_AUTHENTICATE:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.UNKNOWN,
                                                        TagAccess.AUTHENTICATE,
                                                        m_rdr_opt_parms.TagAuthenticate.pData));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_UNTRACEABLE:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.UNKNOWN,
                                                        TagAccess.UNTRACEABLE,
                                                        m_rdr_opt_parms.TagAuthenticate.pData));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_WRITE:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.SPECIFIC,
                                                        CSLibrary.Constants.TagAccess.WRITE,
                                                        m_rdr_opt_parms.TagReadUser.pData));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_WRITE_PC:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        CSLibrary.Constants.Bank.PC,
                                                        CSLibrary.Constants.TagAccess.WRITE,
                                                        m_rdr_opt_parms.TagReadPC.pc));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_WRITE_EPC:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.EPC,
                                                        CSLibrary.Constants.TagAccess.WRITE,
                                                        m_rdr_opt_parms.TagReadEPC.epc));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_WRITE_ACC_PWD:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        CSLibrary.Constants.Bank.ACC_PWD,
                                                        CSLibrary.Constants.TagAccess.WRITE,
                                                        m_rdr_opt_parms.TagReadAccPwd.password));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_WRITE_KILL_PWD:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        CSLibrary.Constants.Bank.KILL_PWD,
                                                        CSLibrary.Constants.TagAccess.WRITE,
                                                        m_rdr_opt_parms.TagReadKillPwd.password));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_WRITE_USER:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.USER,
                                                        CSLibrary.Constants.TagAccess.WRITE,
                                                        m_rdr_opt_parms.TagReadUser.pData));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_BLOCK_WRITE:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.SPECIFIC,
                                                        CSLibrary.Constants.TagAccess.WRITE,
                                                        m_rdr_opt_parms.TagReadUser.pData));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_LOCK:
                                                {
                                                    CSLibrary.Debug.WriteLine("Tag lock end {0}", currentCommandResponse);

                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.UNKNOWN,
                                                        TagAccess.LOCK,
                                                        null));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_KILL:
                                                {
                                                    CSLibrary.Debug.WriteLine("Tag Kill end {0}", currentCommandResponse);

                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.UNKNOWN,
                                                        TagAccess.KILL,
                                                        null));
                                                }
                                                break;

                                            default:
                                                if (_deviceHandler.rfid.EM4325.CommandEndProc(RealCurrentOperation, ((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0))
                                                    break;

                                                if (_deviceHandler.rfid.FM13DT160.CommandEndPProc(RealCurrentOperation, ((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0))
                                                    break;

                                                break;

                                                /*
                                                                                            case CSLibrary.Constants.Operation.TAG_UNTRACEABLE:
                                                                                                {
                                                                                                    CSLibrary.Debug.WriteLine("Tag untraceable end {0}", currentCommandResponse);

                                                                                                    FireAccessCompletedEvent(
                                                                                                        new OnAccessCompletedEventArgs(
                                                                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                                                                        Bank.UNTRACEABLE,
                                                                                                        TagAccess.WRITE,
                                                                                                        null));
                                                                                                }
                                                                                                break;
                                                                                                */

                                        }
                                    }

                                    FireStateChangedEvent(CSLibrary.Constants.RFState.IDLE);







            switch (accessCommand)
            {
                case 0xc2:  // Read
                    switch (RealCurrentOperation)
                    {
                        case CSLibrary.Constants.Operation.TAG_READ:
                            //ArrayCopy(recvData, offset + 20, m_rdr_opt_parms.TagRead.m_pData, 0, m_rdr_opt_parms.TagRead.count * 2);
                            if (size > 12)
                            {
                                int datalen = size - 12;
                                recData = new byte[datalen];
                                Array.Copy(data, 12, recData, 0, datalen);
                            }
                            break;

                        case CSLibrary.Constants.Operation.TAG_READ_PC:
                            m_rdr_opt_parms.TagReadPC.m_pc = (ushort)((recvData[offset + 20] << 8) | (recvData[offset + 21]));
                            break;

                        case CSLibrary.Constants.Operation.TAG_READ_EPC:
                            ArrayCopy(recvData, offset + 20, m_rdr_opt_parms.TagReadEPC.m_epc, 0, m_rdr_opt_parms.TagReadEPC.count * 2);
                            break;

                        case CSLibrary.Constants.Operation.TAG_READ_ACC_PWD:
                            m_rdr_opt_parms.TagReadAccPwd.m_password = (UInt32)((recvData[offset + 20] << 24) | (recvData[offset + 21] << 16) | (recvData[offset + 22] << 8) | (recvData[offset + 23]));
                            break;

                        case CSLibrary.Constants.Operation.TAG_READ_KILL_PWD:
                            m_rdr_opt_parms.TagReadKillPwd.m_password = (UInt32)((recvData[offset + 20] << 24) | (recvData[offset + 21] << 16) | (recvData[offset + 22] << 8) | (recvData[offset + 23]));
                            break;

                        case CSLibrary.Constants.Operation.TAG_READ_TID:
                            ArrayCopy(recvData, offset + 20, m_rdr_opt_parms.TagReadTid.pData, 0, m_rdr_opt_parms.TagReadTid.count * 2);
                            break;

                        case CSLibrary.Constants.Operation.TAG_READ_USER:
                            ArrayCopy(recvData, offset + 20, m_rdr_opt_parms.TagReadUser.m_pData, 0, m_rdr_opt_parms.TagReadUser.count * 2);
                            break;

                        case CSLibrary.Constants.Operation.TAG_AUTHENTICATE:
                            {
                                int pkt_len = recvData[5] << 8 | recvData[4];
                                int flags = recvData[1];
                                int len = ((pkt_len - 3) * 4) - ((flags >> 6) & 3);
                                byte[] response = new byte[len];
                                Array.Copy(recvData, offset + 20, response, 0, len);
                                m_rdr_opt_parms.TagAuthenticate.pData = new S_DATA(response);
                                //Array.Copy(recvData, offset + 20, m_rdr_opt_parms.TagAuthenticate.pData, 0, len);
                            }
                            break;
                    }
                    break;

                case 0xc3:  // Write
                    switch (RealCurrentOperation)
                    {
                        case CSLibrary.Constants.Operation.TAG_WRITE:
                            //ArrayCopy(recvData, offset + 20, m_rdr_opt_parms.TagReadUser.m_pData, 0, m_rdr_opt_parms.TagReadEPC.count * 2);
                            break;

                        case CSLibrary.Constants.Operation.TAG_WRITE_PC:
                            //m_rdr_opt_parms.TagReadPC.m_pc = (ushort)((recvData[offset + 20] << 8) | (recvData[offset + 21]));
                            break;

                        case CSLibrary.Constants.Operation.TAG_WRITE_EPC:
                            //ArrayCopy(recvData, offset + 20, m_rdr_opt_parms.TagReadEPC.m_epc, 0, m_rdr_opt_parms.TagReadEPC.count * 2);
                            break;

                        case CSLibrary.Constants.Operation.TAG_WRITE_ACC_PWD:
                            //m_rdr_opt_parms.TagReadAccPwd.m_password = (UInt32)((recvData[offset + 20] << 24) | (recvData[offset + 21] << 16) | (recvData[offset + 22] << 8) | (recvData[offset + 23]));
                            break;

                        case CSLibrary.Constants.Operation.TAG_WRITE_KILL_PWD:
                            //m_rdr_opt_parms.TagReadKillPwd.m_password = (UInt32)((recvData[offset + 20] << 24) | (recvData[offset + 21] << 16) | (recvData[offset + 22] << 8) | (recvData[offset + 23]));
                            break;

                        case CSLibrary.Constants.Operation.TAG_WRITE_USER:
                            //ArrayCopy(recvData, offset + 20, m_rdr_opt_parms.TagReadUser.m_pData, 0, m_rdr_opt_parms.TagReadEPC.count * 2);
                            break;
                    }
                    break;

                case 0xc4:  // Kill
                    break;

                case 0xc5:  // Lock
                    break;

                case 0xc7:  // Block Write
                    break;

                case 0x04:  // EAS
                    break;

                case 0xe2: // Untraceable
                    break;

                case 0xd5: // Authenticate
                    break;

                case 0xe0: // FM13DT160 & EM4325
                    return false;

                default:
                    return false;
            }
#endif


        }

        internal void AccessComplete(byte[] data, int index)
        {
            UInt32 UTCTimpStamp = BitConverter.ToUInt32(data, index);
            UInt16 AccessCommand = BitConverter.ToUInt16(data, index);
            byte TagErrorCode;
            byte MacErrorCode;
            UInt16 WriteWordCount;
            byte[] Data;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/Comm_Protocol/Ex10Commands/ClassRFID.WriteRegister.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Text;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        byte _sequencedNumber = 0;

        public void WriteRegister(UInt16 address, byte value)
        {
            byte[] data = new byte[1];

            data[0] = (byte)(value);

            WriteRegister(address, data);
        }

        public void WriteRegister(UInt16 [] address, byte [] value)
        {
            byte[][] data = new byte[value.Length][];

            for (int i = 0; i < address.Length; i++)
            {
                data[i] = new byte[1];
                data[i][0] = (byte)(value[i]);
            }

            WriteRegister(address, data);
        }

        public void WriteRegister(UInt16 address, UInt16 value)
        {
            byte[] data = new byte[2];

            data[0] = (byte)(value >> 8);
            data[1] = (byte)(value);

            WriteRegister (address, data);
        }

        public void WriteRegister(UInt16 address, UInt32 value)
        {
            byte[] data = new byte[4];

            data[0] = (byte)(value >> 24);
            data[1] = (byte)(value >> 16);
            data[2] = (byte)(value >> 8);
            data[3] = (byte)(value);

            WriteRegister(address, data);
        }

        public void WriteRegister(UInt16[] address, UInt32[] value)
        {
            byte[][] data = new byte[value.Length][];

            for (int i = 0; i < address.Length; i++)
            {
                data[i] = new byte[4];
                data[i][0] = (byte)(value[i] >> 24);
                data[i][1] = (byte)(value[i] >> 16);
                data[i][2] = (byte)(value[i] >> 8);
                data[i][3] = (byte)(value[i]);
            }

            WriteRegister(address, data);
        }

        public void WriteRegister(UInt16 address, UInt64 value)
        {
            byte[] data = new byte[8];

            data[0] = (byte)(value >> 56);
            data[1] = (byte)(value >> 48);
            data[2] = (byte)(value >> 40);
            data[3] = (byte)(value >> 32);
            data[4] = (byte)(value >> 24);
            data[5] = (byte)(value >> 16);
            data[6] = (byte)(value >> 8);
            data[7] = (byte)(value);

            WriteRegister(address, data);
        }

        byte _SequencedNumber = 0;

        public void WriteRegister(UInt16 address, byte[] data)
        {
            if (data == null)
                return;

            SCSLRFIDCMD cmd = SCSLRFIDCMD.SCSLWriteRegister;
            byte[] payload = new byte[11 + data.Length];
            int datapayloadlen = 4 + data.Length;

            payload[0] = 0x80;
            payload[1] = 0xb3;
            payload[2] = (byte)((int)cmd >> 8);
            payload[3] = (byte)cmd;
            payload[4] = _SequencedNumber++;  // Sequenced number
            payload[5] = (byte)(datapayloadlen >> 8);
            payload[6] = (byte)datapayloadlen;
            payload[7] = 1;
            payload[8] = (byte)(address >> 8);
            payload[9] = (byte)address;
            payload[10] = (byte)data.Length;
            Array.Copy(data, 0, payload, 11, data.Length);

            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, payload, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.COMMANDENDRESPONSE);
        }

        public void WriteRegister(UInt16 [] address, byte[][] data)
        {
            if (address == null || data == null || address.Length > data.Length)
                return;

            SCSLRFIDCMD cmd = SCSLRFIDCMD.SCSLWriteRegister;
            int totallen = 0;
            for (int i = 0; i< address.Length; i++)
                totallen += data[i].Length;
            totallen += (address.Length * 3);

            if (totallen > 247)
                throw new OutOfMemoryException("out of BLE buffer");

            byte[] payload = new byte[8 + totallen];
            int datapayloadlen = 1 + totallen;

            payload[0] = 0x80;
            payload[1] = 0xb3;
            payload[2] = (byte)((int)cmd >> 8);
            payload[3] = (byte)cmd;
            payload[4] = _SequencedNumber++;  // Sequenced number
            payload[5] = (byte)(datapayloadlen >> 8);
            payload[6] = (byte)datapayloadlen;
            payload[7] = (byte)address.Length;

            int index = 8;
            for (int i = 0; i < address.Length; i++)
            {
                payload[index++] = (byte)(address[i] >> 8);
                payload[index++] = (byte)address[i];
                payload[index++] = (byte)data[i].Length;
                Array.Copy(data[i], 0, payload, index, data[i].Length);
                index += data[i].Length;
            }

            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, payload, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.COMMANDENDRESPONSE);
        }

        internal bool WriteRegisterCommandReply(int index, byte[] data)
        {
            if (data == null)
                return false;

            if (data.Length < index + 7)
                return false;

            UInt16 Header = BitConverter.ToUInt16(data, index);
            if (Header != 0x51e2)
                return false;

            UInt16 EcgoCommandCode = BitConverter.ToUInt16(data, index + 2);
            if (EcgoCommandCode != 0x9a06)
                return false;

            byte EchoSequenceNumber = data[index + 4];

            UInt16 PayloadLength = BitConverter.ToUInt16(data, index + 5);
            if (PayloadLength != 1)
                return false;

            byte WriteStatus = data[index + 7];

            return true;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/Comm_Protocol/RX000Commands/ClassRFID.Private.ByPassRegister.cs">
using System;
using System.Collections.Generic;
using System.Text;

using CSLibrary.Constants;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        /// <summary>
        /// Writes directly to a radio-module hardware register.  The radio 
        /// module's hardware registers may not be written while a radio 
        /// module is executing a tag-protocol operation. 
        /// </summary>
        /// <param name="address">The 16-bit address of the radio-module hardware 
        /// register to be written.  An address that is beyond the 
        /// end of the radio module's register set Results in an 
        /// invalid-parameter return status. </param>
        /// <param name="value">The 16-bit value to write to the radio-module 
        /// hardware register specified by address. </param>
        /// <returns></returns>
        private Result MacBypassWriteRegister(ushort address, ushort value)
        {
            try
            {
                MacWriteRegister(MACREGISTER.HST_MBP_ADDR, address);

                MacWriteRegister(MACREGISTER.HST_MBP_DATA, value);

                //COMM_HostCommand(HST_CMD.MBPWRREG);
                // Issue read OEM command
                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.MBPWRREG), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (UInt32)0xffffffff);
            }
            catch (Exception ex)
            {
            }
            catch
            {
                m_Result = Result.SYSTEM_CATCH_EXCEPTION;
            }

            return m_Result;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/Comm_Protocol/RX000Commands/ClassRFID.Private.MacRegister.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        UInt32[] _0000 = null;             // 0X0000~0X0002
        UInt32[] _0100 = null;              // 0x0100 ~ 0x010d
        UInt32[] _0117 = null;              // 0x117 ~ 0x11f
        UInt32[] _0200 = null;
        UInt32[] _0300 = null;
        UInt32[] _0400 = null;
        UInt32[] _0500 = null;             // 0x0500 ~ 0x0501
        UInt32[] _0600 = null;             // 0x0600 ~ 0x0603
        UInt32[] _0700 = null;             // 0x0700
        UInt32[] _0701 = null;             // 0x0701
        UInt32[,] _0702_707 = null;     // 0x0702 ~ 0x0707
        UInt32[] _0800 = null;             // 0x0800
        UInt32[,] _0801_80c = null;    // 0x0800 ~ 0x080c
        UInt32[] _0900 = null;             // 0X0900 ~ 0X0901
        UInt32[] _0902 = null;             // 0X0902
        UInt32[,] _0903_906 = null;     // 0X0903 ~ 0X0906
        UInt32[] _0907_908 = null;        // 0X0907 ~ 0X0908
        UInt32[] _0910_921 = null;        // 0X0910 ~ 0X0921
        UInt32[] _0a00_a07 = null;            // 0X0a00 ~ 0x0a0f
        UInt32[] _0a08 = null;            // 0X0a08
        UInt32[,] _0a09_a18 = null;          // 0X0a09 ~ 0x0a18
        UInt32[] _0b00 = null;          // 0x0b00 ~ 0x0b84
        UInt32[] _0c01 = null;             // 0X0c01
        UInt32[,] _0c02_c07 = null;    // 0X0c02 ~ 0x0c07
        UInt32[] _0c08 = null;             // 0X0c08
        UInt32[] _0d00 = null;
        UInt32[] _0e00 = null;
        UInt32[] _0f00_f05 = null;
        UInt32[] _0f0f = null;

        public bool MacRegisterInitialize()
        {
            /*
            _0000 = new UInt32[3];             // 0X0000~0X0002
            _0100 = new UInt32[0];
            _0200 = new UInt32[0];
            _0300 = new UInt32[0];              // 302, 304, 308 (Selector?)
            _0400 = new UInt32[0];              // 408 (Selector?)
            _0500 = new UInt32[2];             // 0x0500 ~ 0x0501
            _0600 = new UInt32[4];             // 0x0600 ~ 0x0603
            _0700 = new UInt32[2];             // 0x0700 ~ 0x0701 (Selector)
            _0702_707 = new UInt32[16, 6];     // 0x0702 ~ 0x0707
            _0800 = new UInt32[1];             // 0x0800 (Selector)
            _0801_80c = new UInt32[8, 12];     // 0x0800 ~ 0x080c
            _0900 = new UInt32[3];             // 0X0900 ~ 0X0902 (Selector)
            _0903_906 = new UInt32[4, 4];      // 0X0903 ~ 0X0906
            _0910_921 = new UInt32[12];        // 0X0910 ~ 0X0921 (Selector)
            _0a00 = new UInt32[16];            // 0X0a00 ~ 0x0a0f (Selector)
            _0b00 = new UInt32[0x85];          // 0x0b00 ~ 0x0b84
            _0c01 = new UInt32[2];             // 0X0c01 (Selector)
            _0c02_c07 = new UInt32[50, 6];     // 0X0c02 ~ 0x0c07
            _0c08 = new UInt32[1];             // 0X0c08
            _0d00 = new UInt32[0];
            _0e00 = new UInt32[0];
            _0f00 = new UInt32[0];

            _0700[0x00] = 0xffff;
            //_0700[0x02] = 0x0001;
            //_0700[0x05] = 0x07d0;
            //_0700[0x06] = 0x012c;
            _0900[0x00] = 0x00c0;
            _0900[0x01] = 0x0003;
            _0900[0x02] = 0x0003;
            //_0900[0x03] = 0x40f4;
            //_0900[0x05] = 0x0001;
            _0a00[0x01] = 0x0006;
            _0a00[0x02] = 0x0001;
            _0a00[0x03] = 0x0002;
            _0a00[0x04] = 0x0001;

            ReadReaderRegister(0x0000); // Get RFID Reader Firmware version
            //ReadReaderRegister(0x0800);
            */



            _0000 = new UInt32[3];             // 0X0000~0X0002
            _0100 = new UInt32[14];             // 0x0100 ~ 0x010d
            _0117 = new UInt32[9];              // 117 ~ 11f
            _0200 = new UInt32[4];
            _0300 = new UInt32[0];

            //_0302 = new UInt32[2];              // (Selector)
            //_0303 = new UInt32[11];

            //_0304 = new UInt32[2];              // (Selector)

            //_0305 = new UInt32[2];              // (Selector)

            //_0308 = new UInt32[2];              // (Selector)

            //_0309 = new UInt32[8];              

            _0400 = new UInt32[11];              // 0x0400-0x040A

            //_0408 = new UInt32[2];              // (Selector)


            _0500 = new UInt32[2];             // 0x0500 ~ 0x0501
            _0600 = new UInt32[4];             // 0x0600 ~ 0x0603
            _0700 = new UInt32[1];             // 0x0700 

            _0701 = new UInt32[2];              // (Selector)
            _0702_707 = new UInt32[16, 6];     // 0x0702 ~ 0x0707

            _0800 = new UInt32[2];             // (Selector)
            _0801_80c = new UInt32[8, 12];     // 0x0800 ~ 0x080c

            _0900 = new UInt32[3];             // 0X0900 ~ 0X0901

            _0902 = new UInt32[2];              // Selector
            _0903_906 = new UInt32[4, 4];      // 0X0903 ~ 0X0906

            _0907_908 = new UInt32[2];        // 0X0907 ~ 0X0908
            _0910_921 = new UInt32[12];        // 0X0910 ~ 0X0921

            _0a00_a07 = new UInt32[8];            // 0X0a00 ~ 0x0a07

            _0a08 = new UInt32[2];              // Selector
            _0a09_a18 = new UInt32[8, 16];      // 0X0a09 ~ 0X0a18

            _0b00 = new UInt32[0x85];          // 0x0b00 ~ 0x0b84

            //_0b61 = new UInt32[2];              // Selector
            //_0b62_b

            _0c01 = new UInt32[2];             // 0X0c01 (Selector)
            _0c02_c07 = new UInt32[50, 6];     // 0X0c02 ~ 0x0c07

            _0c08 = new UInt32[1];             // 0X0c08

            _0d00 = new UInt32[0];
            _0e00 = new UInt32[0];

            _0f00_f05 = new UInt32[6];          // 0x0f00 ~ 0x0f05
            _0f0f = new UInt32[1];



            _0200[0x00] = 0x0000;
            _0200[0x01] = 0x0000;
            _0200[0x03] = 0x0000;
            _0700[0x00] = 0xffff;

            _0702_707[0, 0] = 0x01;
            _0702_707[1, 2] = 0x10001;
            _0702_707[2, 2] = 0x20002;
            _0702_707[3, 2] = 0x30003;
            for (int cnt = 0; cnt < 16; cnt++)
            {
                _0702_707[cnt, 3] = 0x7d0;
                _0702_707[cnt, 4] = 0x12c;
                _0702_707[cnt, 5] = 0x2000;
            }
            _0900[0x00] = 0x00c0;
            _0900[0x01] = 0x0001;
            _0900[0x02] = 0x0003;
            _0903_906[0x00, 0x00] = 0x04;
            _0903_906[0x03, 0x00] = 0x40F4;
            _0903_906[0x00, 0x02] = 0x03;
            _0903_906[0x0, 0x02] = 0x01;
            _0903_906[0x02, 0x02] = 0x01;
            _0903_906[0x03, 0x02] = 0x01;

            //_0900[0x03] = 0x40f4;
            //_0900[0x05] = 0x0001;
            _0a00_a07[0x01] = 0x0006;
            _0a00_a07[0x02] = 0x0001;
            _0a00_a07[0x03] = 0x0002;
            _0a00_a07[0x04] = 0x0001;

            for (int cnt = 0; cnt < 50; cnt++)
                for (int cnt1 = 0; cnt1 < 6; cnt1++)
                    _0c02_c07[cnt, cnt1] = 0xffffff;

            ReadReaderRegister(0x0000); // Get RFID Reader Firmware version
            //ReadReaderRegister(0x0800);
            WriteMacRegister(0x201, 0x010);

            return true;
        }

        /*            public bool MacRegisterInitialize (uint model, uint country, uint specialVersion, uint oemVersion)
                {
                    switch (model)
                    {
                        case 1:
                            break;
                        case 2:
                            break;
                        case 4:
                            break;
                        case 7:
                            break;
                        case 8:
                            break;
                        case 9:
                            break;

                        default:
                            break;
                    }

                    ReadReaderRegister(0x000);                                          // Get RFID Reader Firmware version

                    //ReadReaderRegister((UInt16)MACREGISTER.HST_ANT_DESC_RFPOWER);      // Get Antenna 0 Power Level            
                    // ReadReaderRegister((UInt16)MACREGISTER.HST_ANT_CYCLES);
                    // MacWriteRegister(MACREGISTER.HST_ANT_DESC_SEL, 0);  // Set Antenna 0 
                    // ReadReaderRegister((UInt16)MACREGISTER.HST_ANT_DESC_RFPOWER);   // Get Antenna 0 Power Level
                    // ReadReaderRegister((UInt16)MACREGISTER.HST_ANT_DESC_DWELL);
                    // ReadReaderRegister((UInt16)MACREGISTER.HST_QUERY_CFG);
                    // ReadReaderRegister((UInt16)MACREGISTER.HST_INV_CFG);
                    // ReadReaderRegister((UInt16)MACREGISTER.HST_INV_EPC_MATCH_CFG);
                    // ReadReaderRegister((UInt16)MACREGISTER.HST_TAGACC_DESC_CFG);
                    // ReadReaderRegister(0x005); // reader mac error register

                    return false;
                }
        */

        private void ReadReaderRegister(UInt16 add)
        {
            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(add), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1);
        }

        /// <summary>
        /// for compatible with old library
        /// </summary>
        /// <param name="add"></param>
        /// <param name="value"></param>
        internal void MacWriteRegister(MACREGISTER add, UInt32 value)
        {
            CSLibrary.Debug.WriteLine("MAC Write {0:X}:{1:X}", add, value);
            WriteMacRegister((UInt16)add, value);
            //MacWriteRegister((UInt16)add, value);
        }

        private bool MacReadRegister(MACREGISTER add, ref UInt32 data)
        {
            data = ReadMacRegister((UInt16)add);
            CSLibrary.Debug.WriteLine("MAC Read {0:X}:{1:X}", add, data);
            return true;
        }

        bool SendRegisterAsync (UInt16 address, UInt32 data)
        {
            return _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
        }

        internal UInt32 ReadMacRegister(UInt16 address)
        {
            UInt16 addressBench = (UInt16)(address & 0x0f00U);
            UInt16 addressoffset = (UInt16)(address & 0x00ffU);

            try
            {   switch (addressBench)
                {
                    case 0x0000:
                        if (addressoffset == 0x0000)
                        {
                            return _0000[addressoffset];
                        }
                        else
                        {
                            ReadReaderRegister(address);
                        }
                        break;

                    case 0x0100:
                        if (addressoffset >= 0x0017 && addressoffset  <= 0x001f)
                            return _0117[addressoffset - 0x17];

                        return _0100[addressoffset];
                        break;

                    case 0x0200:
                        return _0200[addressoffset];
/*                        if (addressoffset == 0x0001)
                            return _0201[0];
                        else if (addressoffset == 0x0003)
                            return _0203[0];*/
                        break;

                    case 0x0300:
                        return _0300[addressoffset];
                        break;

                    case 0x0400:
                        return _0400[addressoffset];
                        break;

                    case 0x0500:
                        return _0500[addressoffset];
                        break;

                    case 0x0600:
                        return _0600[addressoffset];
                        break;

                    case 0x0700:
                        if (addressoffset == 0x0000)
                            return _0700[0];
                        else if (addressoffset == 0x01)
                            return _0701[1];
                        else if (addressoffset >= 0x0002 && addressoffset <= 0x0007)
                            return _0702_707[_0701[1], addressoffset - 2];
                        break;

                    case 0x0800:
                        if (addressoffset == 0x0000)
                            return _0800[1];
                        else if (addressoffset >= 0x0001 && addressoffset <= 0x000c)
                            return _0801_80c[_0800[1], addressoffset - 1];
                        break;

                    case 0x0900:
                        if (addressoffset >= 0x0000 && addressoffset <= 0x0001)
                            return _0900[addressoffset];
                        else if (addressoffset == 0x02)
                            return _0902[1];
                        else if (addressoffset >= 0x0003 && addressoffset <= 0x006)
                            return _0903_906[_0902[1], addressoffset - 3];
                        else if (addressoffset >= 0x0007 && addressoffset <= 0x008)
                            return _0907_908[addressoffset - 0x07];
                        else if (addressoffset >= 0x0010 && addressoffset <= 0x021)
                            return _0910_921[addressoffset - 0x10];
                        break;

                    case 0x0a00:
                        if (addressoffset >= 0x0000 && addressoffset <= 0x0007)
                            return _0a00_a07[addressoffset];
                        else if (addressoffset == 0x08)
                            return _0a08[1];
                        else if (addressoffset >= 0x0009 && addressoffset <= 0x0018)
                            return _0a09_a18[_0a08[1], addressoffset - 9];
                        break;

                    case 0x0b00:
                        return _0b00[addressoffset];
                        break;

                    case 0x0c00:
                        if (addressoffset == 0x0001)
                            return _0c01[1];
                        else if (addressoffset >= 0x0002 && addressoffset <= 0x0007)
                            return _0c02_c07[_0c01[1], addressoffset - 2];
                        if (addressoffset == 0x0008)
                            return _0c08[0];
                        break;

                    case 0x0d00:
                        return _0d00[addressoffset];
                        break;

                    case 0x0e00:
                        return _0e00[addressoffset];
                        break;

                    case 0x0f00:
                        if (addressoffset == 0x000f)
                            return _0f0f[0];
                        else if (addressoffset >= 0x0000 && addressoffset <= 0x0005)
                            return _0f00_f05[addressoffset];
                        break;

                    default:
                        break;
                }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine(ex.Message);
            }

            return 0;
        }

        public bool SaveMacRegister (UInt16 address, UInt32 data)
        {
            if (address > 0x0001)
                return false;

            UInt16 addressoffset = (UInt16)(address & 0x00ffU);

            _0000[addressoffset] = data;
            return true;
        }

        public void WriteMacRegister(UInt16 address, UInt32 data)
        {
            UInt16 addressBench = (UInt16)(address & 0x0f00U);
            UInt16 addressoffset = (UInt16)(address & 0x00ffU);

            try
            {
                switch (addressBench)
                {
                    case 0x0000:
                        if (data != _0000[addressoffset])
                        {
                            _0000[addressoffset] = data;
                            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                        }
                        break;

                    case 0x0100:
                        if (addressoffset >= 0x0017 && addressoffset <= 0x001f)
                        {
                            int location = addressoffset - 0x17;
                            if (data != _0117[location])
                            {
                                _0117[location] = data;
                                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                            }
                        }
                        else if (data != _0100[addressoffset])
                        {
                            _0100[addressoffset] = data;
                            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                        }
                        break;

                    case 0x0200:
                        if (data != _0200[addressoffset])
                        {
                            _0200[addressoffset] = data;
                            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                        }

                        /*                        if (addressoffset == 0x01)
                                                {
                                                    if (data != _0201[0])
                                                    {
                                                        _0201[0] = data;
                                                        _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                                                    }
                                                }
                                                else if (addressoffset == 0x03)
                                                {
                                                    if (data != _0203[0])
                                                    {
                                                        _0203[0] = data;
                                                        _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                                                    }
                                                }*/
                        /*if (data != _0200[addressoffset])
                        {
                            _0200[addressoffset] = data;
                            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                        }*/
                        break;

                    case 0x0300:
                        if (data != _0300[addressoffset])
                        {
                            _0300[addressoffset] = data;
                            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                        }
                        break;

                    case 0x0400:
                        if (data != _0400[addressoffset])
                        {
                            _0400[addressoffset] = data;
                            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                        }
                        break;

                    case 0x0500:
                        if (data != _0500[addressoffset])
                        {
                            _0500[addressoffset] = data;
                            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                        }
                        break;

                    case 0x0600:
                        if (data != _0600[addressoffset])
                        {
                            _0600[addressoffset] = data;
                            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                        }
                        break;

                    case 0x0700:
                        if (addressoffset == 0x0000)
                        {
                            if (data != _0700[addressoffset])
                            {
                                _0700[addressoffset] = data;
                                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                            }
                        }
                        else if (addressoffset == 0x01)
                        {
                            _0701[1] = data;
                        }
                        else if (addressoffset >= 0x0002 && addressoffset <= 0x0007)
                        {
                            addressoffset -= 2;
                            if (data != _0702_707[_0701[0x0001], addressoffset])
                            {
                                if (_0701[0] != _0701[1])
                                {
                                    _0701[0] = _0701[1];
                                    _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0x701, _0701[0]), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                                }

                                _0702_707[_0701[1], addressoffset] = data;
                                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                            }
                        }
                        break;

                    case 0x0800:
                        if (addressoffset == 0x0000)
                        {
                            _0800[1] = data;
                        }
                        else if (addressoffset >= 0x0001 && addressoffset <= 0x000c)
                        {
                            addressoffset -= 1;
                            if (data != _0801_80c[_0800[1], addressoffset])
                            {
                                if (_0800[0] != _0800[1])
                                {
                                    _0800[0] = _0800[1];
                                    _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0x800, _0800[0]), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                                }

                                _0801_80c[_0800[1], addressoffset] = data;
                                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                            }
                        }
                        break;

                    case 0x0900:
                        if (addressoffset >= 0x0000 && addressoffset <= 0x0001)
                        {
                            if (data != _0900[addressoffset])
                            { 
                                _0900[addressoffset] = data;
                                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                            }
                        }
                        else if (addressoffset == 0x0002)
                        {
                            _0902[1] = data;
                        }
                        else if (addressoffset >= 0x0003 && addressoffset <= 0x0006)
                        {
                            addressoffset -= 3;
                            if (data != _0903_906[_0902[1], addressoffset])
                            {
                                if (_0902[0] != _0902[1])
                                {
                                    _0902[0] = _0902[1];
                                    _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0x902, _0902[0]), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                                }

                                _0903_906[_0902[1], addressoffset] = data;
                                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                            }
                        }
                        else if (addressoffset >= 0x0007 && addressoffset <= 0x0008)
                        {
                            addressoffset -= 0x0007;
                            if (data != _0907_908[addressoffset])
                            {
                                _0907_908[addressoffset] = data;
                                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                            }
                        }
                        else if (addressoffset >= 0x0010 && addressoffset <= 0x0021)
                        {
                            addressoffset -= 0x0010;
                            if (data != _0910_921[addressoffset])
                            {
                                _0910_921[addressoffset] = data;
                                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                            }
                        }
                        break;

                    case 0x0a00:
                        if (addressoffset >= 0x0000 && addressoffset <= 0x0007)
                        {
                            if (data != _0a00_a07[addressoffset])
                            {
                                _0a00_a07[addressoffset] = data;
                                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                            }
                        }
                        else if (addressoffset == 0x08)
                        {
                            _0a08[1] = data;
                        }
                        else if (addressoffset >= 0x0009 && addressoffset <= 0x0018)
                        {
                            addressoffset -= 0x0009;
                            if (data != _0a09_a18[_0a08[1], addressoffset])
                            {
                                if (_0a08[0] != _0a08[1])
                                {
                                    _0a08[0] = _0a08[1];
                                    _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0x0a08, _0a08[0]), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                                }

                                _0a09_a18[_0a08[1], addressoffset] = data;
                                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                            }


                        }
                        break;

                    case 0x0b00:
                        if (data != _0b00[addressoffset])
                        {
                            _0b00[addressoffset] = data;
                            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                        }
                        break;

                    case 0x0c00:
                        if (addressoffset == 0x0001)
                        {
                            _0c01[1] = data;
                        }
                        else if (addressoffset >= 0x0002 && addressoffset <= 0x0007)
                        {
                            addressoffset -= 2;
                            if (data != _0c02_c07[_0c01[1], addressoffset])
                            {
                                if (_0c01[0] != _0c01[1])
                                {
                                    _0c01[0] = _0c01[1];
                                    _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xc01, _0c01[0]), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                                }

                                _0c02_c07[_0c01[1], addressoffset] = data;
                                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                            }
                        }
                        if (addressoffset == 0x0008)
                        {
                            if (data != _0c08[0x00])
                            {
                                _0c08[0x00] = data;
                                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                            }
                        }
                        break;

                    case 0x0d00:
                        if (data != _0d00[addressoffset])
                        {
                            _0d00[addressoffset] = data;
                            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                        }
                        break;

                    case 0x0e00:
                        if (data != _0e00[addressoffset])
                        {
                            _0e00[addressoffset] = data;
                            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                        }
                        break;

                    case 0x0f00:
                        if (addressoffset == 0x000f)
                        {
                            if (data != _0f0f[0])
                            {
                                _0f0f[0] = data;
                                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                            }
                        } else if (addressoffset >= 0x0000 && addressoffset <= 0x0005)
                        {
                            if (data != _0f00_f05[addressoffset])
                            {
                                _0f00_f05[addressoffset] = data;
                                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(address, data), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE);
                            }
                        }
                        break;

                    default:
                        break;
                }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine(ex.Message);
            }
        }


    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reflection;

namespace CSLibrary
{
    using static RFIDDEVICE;
    using Constants;
    using Structures;
    using Events;
    using Tools;


    public partial class RFIDReader
    {
        #region public variable

        internal int _readerMode = 0;
        internal MODEL _deviceType = MODEL.UNKNOWN;

        #region ====================== Callback Event Handler ======================
        /// <summary>
        /// Reader Operation State Event
        /// </summary>
        public event EventHandler<CSLibrary.Events.OnStateChangedEventArgs> OnStateChanged;

        /// <summary>
        /// Tag Inventory(including Inventory and search) callback event
        /// </summary>
        public event EventHandler<CSLibrary.Events.OnAsyncCallbackEventArgs> OnAsyncCallback;

        /// <summary>
        /// Tag Access (including Tag read/write/kill/lock) completed event
        /// </summary>
        public event EventHandler<CSLibrary.Events.OnAccessCompletedEventArgs> OnAccessCompleted;

        /// <summary>
        /// Tag Access (including Tag read/write/kill/lock) completed event
        /// </summary>
        public event EventHandler<CSLibrary.Events.OnInventoryTagRateCallbackEventArgs> OnInventoryTagRateCallback;
        #endregion
        #endregion

        /// <summary>
        /// CSLibrary Operation parameters
        /// Notes : you must config this parameters before perform any operation
        /// </summary>
        public CSLibraryOperationParms Options
        {
            get { return m_rdr_opt_parms; }
            set { m_rdr_opt_parms = value; }
        }
        //public UInt32 LastMacErrorCode;
        //public UInt16 LastResultCode = 0;

        internal HighLevelInterface _deviceHandler;
        private RFState m_state = RFState.IDLE;
        private Result m_Result;
        internal MODEL m_oem_machine;
        private string m_PCBAssemblyCode;

        /// <summary>
        /// Current Operation State
        /// </summary>
        public RFState State
        {
            get { { return m_state; } }
            private set { { m_state = value; } }
        }

        public void ClearEventHandler()
        {
            OnStateChanged = null;
            OnAsyncCallback = null;
            OnAccessCompleted = null;
            OnInventoryTagRateCallback = null;
            //OnFM13DTAccessCompleted = null;
        }

        public void ClearOnAsyncCallback()
        {
            OnAsyncCallback = null;
        }


        public MODEL GetModel()
        {
            return m_oem_machine;
        }

        public uint GetCountry()
        {
            return m_oem_country_code;
        }
        
        /*
                public string GetCountryCode()
                {
                    m_save_country_code = 2;
                    m_oem_freq_modification_flag = 0;
                    string country = "-" + m_save_country_code.ToString();

                    switch (m_save_country_code)
                    {
                        case 2:
                            if (m_oem_freq_modification_flag == 0)
                            {
                                country += " RW";
                            }
                            else
                            {
                                switch (m_oem_special_country_version)
                                {
                                    case 0x4f464341:
                                        country += " OFCA";
                                        break;
                                    case 0x2a2a4153:
                                        country += " AS";
                                        break;
                                    case 0x2a2a4e5a:
                                        country += " NZ";
                                        break;
                                    case 0x20937846: 
                                        country += " ZA";
                                        break;
                                    case 0x2A2A5347:
                                        country += " SG";
                                        break;
                                }
                            }
                            break;

                        case 8:
                            switch (m_oem_special_country_version)
                            {
                                case 0x2A4A5036:
                                    country += " JP6";
                                    break;
                            }
                            break;
                    }
                    return country;
                }
        */

        public string GetPCBAssemblyCode()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return m_PCBAssemblyCode;

                case MODEL.CS710S:
                    return RFIDRegister.EF9C.value;
            }

            return "";
        }

        internal static void ArrayCopy(byte[] src, int srcOffset, UInt16[] dest, int destOffset, int byteSize)
        {
            int len = byteSize / 2;

            if ((byteSize % 2) != 0 || (src.Length - srcOffset) < byteSize || (dest.Length - destOffset) < len)
            {
                return;
                //throw new ArgumentException();
            }

            for (int cnt = 0; cnt < len; cnt++)
                dest[destOffset + cnt] = (UInt16)(src[srcOffset + cnt * 2] << 8 | src[srcOffset + cnt * 2 + 1]);
        }

        private String uint32ArrayToString(UInt32[] source)
        {
            StringBuilder sb = new StringBuilder();

            // Byte at offset is total byte len, 2nd byte is always 3

            for (int index = 0; index < source.Length; index++)
            {
                sb.Append((Char)(source[index] >> 24 & 0x000000FF));
                sb.Append((Char)(source[index] >> 16 & 0x000000FF));
                sb.Append((Char)(source[index] >> 8 & 0x000000FF));
                sb.Append((Char)(source[index] >> 0 & 0x000000FF));
            }

            return sb.ToString();
        }

        internal CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE DeviceRecvData(byte[] recvData, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE currentCommandResponse)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return DeviceRecvData_CS108(recvData, currentCommandResponse);

                case MODEL.CS710S:
                    return DeviceRecvData_CS710S(recvData, currentCommandResponse);
            }

            return HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.ENDEVENTUPLINKPACKET;
        }

        public Result CancelAllSelectCriteria()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return CancelAllSelectCriteria_CS108();

                case MODEL.CS710S:
                    return CancelAllSelectCriteria_CS710S();
            }

            return Result.FAILURE;
        }


#region ====================== Set Tag Group ======================
        /// <summary>
        /// Get Tag Group
        /// </summary>
        /// <param name="gpSelect"></param>
        /// <returns></returns>
        public Result SetTagGroup(Selected gpSelect)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetTagGroup_CS108 (gpSelect);

                case MODEL.CS710S:
                    return SetTagGroup_CS710S(gpSelect);
            }

            return (m_Result = Result.FAILURE);
        }

        /// <summary>
        /// Once the tag population has been partitioned into disjoint groups, a subsequent 
        /// tag-protocol operation (i.e., an inventory operation or access command) is then 
        /// applied to one of the tag groups. 
        /// </summary>
        /// <param name="gpSelect">Specifies the state of the selected (SL) flag for tags that will have 
        /// the operation applied to them. </param>
        /// <param name="gpSession">Specifies which inventory session flag (i.e., S0, S1, S2, or S3) 
        /// will be matched against the inventory state specified by target. </param>
        /// <param name="gpSessionTarget">Specifies the state of the inventory session flag (i.e., A or B),
        /// specified by session, for tags that will have the operation 
        /// applied to them. </param>
        public Result SetTagGroup(Selected gpSelect, Session gpSession, SessionTarget gpSessionTarget)
		{
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetTagGroup_CS108(gpSelect, gpSession, gpSessionTarget);

                case MODEL.CS710S:
                    return SetTagGroup_CS710S(gpSelect, gpSession, gpSessionTarget);
            }

            return (m_Result = Result.FAILURE);
        }

        /// <summary>
        /// Once the tag population has been partitioned into disjoint groups, a subsequent 
        /// tag-protocol operation (i.e., an inventory operation or access command) is then 
        /// applied to one of the tag groups. 
        /// </summary>
        /// <param name="tagGroup"><see cref="TagGroup"/></param>
        /// <returns></returns>
        public Result SetTagGroup(TagGroup tagGroup)
		{
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetTagGroup_CS108(tagGroup);

                case MODEL.CS710S:
                    return SetTagGroup_CS710S(tagGroup);
            }

            return (m_Result = Result.FAILURE);
        }
        /// <summary>
        /// Get Tag Group
        /// </summary>
        /// <param name="tagGroup"></param>
        /// <returns></returns>
        public Result GetTagGroup(ref TagGroup tagGroup)
		{
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return GetTagGroup_CS108(ref tagGroup);

                case MODEL.CS710S:
                    return GetTagGroup_CS710S(ref tagGroup);
            }

            return (m_Result = Result.FAILURE);
        }
        #endregion


        // public RFID function
        internal void PowerOn()
		{
			CSLibrary.Debug.WriteLine("DateTime {0}", DateTime.Now);

			_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDPOWERON);
		}

		internal void PowerOff()
		{
			CSLibrary.Debug.WriteLine("DateTime {0}", DateTime.Now);

			_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDPOWEROFF);
		}

        internal UInt32 _InventoryCycleDelay = 0x00;


        /// <summary>
        /// Set Compact Inventory Delay Time (for CS108 only) 
        /// </summary>
        /// <param name="ms"></param>
        /// <returns></returns>
        public bool SetTagDelayTime(UInt32 ms)
        {
            switch(_deviceType)
            {
                case MODEL.CS108:
                    return SetTagDelayTime_CS108(ms);
            }

            return false;
        }


        /// <summary>
        /// Set Intra Packet Delay Time (for CS710S only)
        /// </summary>
        /// <param name="ms"></param>
        /// <returns></returns>        
        public bool SetIntraPacketDelayTime(UInt32 ms)
        {
            switch (_deviceType)
            {
                case MODEL.CS710S:
                    return SetTagDelayTime_CS710S(ms);
            }

            return false;
        }



        #region Public Functions

        public ClassEM4325 EM4325 = null;
        public ClassFM13DT160 FM13DT160 = null;

        internal RFIDReader(HighLevelInterface deviceHandler)
		{
			_deviceHandler = deviceHandler;

            // Special Module
            EM4325 = new ClassEM4325(deviceHandler);
            FM13DT160 = new ClassFM13DT160(deviceHandler);
        }

        ~RFIDReader()
		{
		}

        internal void SetDeviceType(MODEL deviceType)
        {
            this._deviceType = deviceType;
        }

        internal void Connect(MODEL deviceType)
		{
            this._deviceType = deviceType;

            switch (_deviceType)
            {
                case MODEL.CS108:
                    Connect_CS108();
                    break;

                case MODEL.CS710S:
                    Connect_CS710S();
                    break;
            }

            return;
        }

        internal void Reconnect()
		{
            switch (_deviceType)
            {
                case MODEL.CS108:
                    Reconnect_CS108();
                    break;

                case MODEL.CS710S:
                    //Reconnect_CS710S();
                    break;
            }

            return;
        }

        internal void Disconnect()
        {
            _deviceType = MODEL.UNKNOWN;
        }

        public string GetFirmwareVersionString()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return GetFirmwareVersionString_CS108();

                case MODEL.CS710S:
                    return GetFirmwareVersionString_CS710S();
            }

            return "";
        }

        /// <summary>
        /// Retrieves the operation mode for the RFID radio module.  The 
        /// operation mode cannot be retrieved while a radio module is 
        /// executing a tag-protocol operation. 
        /// </summary>
        /// <param name="cycles">The number of antenna cycles to be completed for command execution.
        /// <para>0x0001 = once cycle through</para>
        /// <para>0xFFFF = cycle forever until a CANCEL is received.</para></param>
        /// <param name="mode">Antenna Sequence mode.</param>
        /// <param name="sequenceSize">Sequence size. Maximum value is 48</param>
        /// <returns></returns>
        public Result GetOperationMode(ref ushort cycles, ref AntennaSequenceMode mode, ref uint sequenceSize)
		{
            switch (_deviceType)
            {
                case MODEL.CS710S:
                    return GetOperationMode(ref cycles, ref mode, ref sequenceSize);
            }

            return Result.FAILURE;
        }

        /// <summary>
        /// Retrieves the operation mode for the RFID radio module.  The 
        /// operation mode cannot be retrieved while a radio module is 
        /// executing a tag-protocol operation. 
        /// </summary>
        /// <param name="mode"> return will receive the current operation mode.</param>
        /// <returns></returns>
        public void GetOperationMode(ref RadioOperationMode mode)
		{
            switch (_deviceType)
            {
                case MODEL.CS710S:
                    break;
            }

            return;
		}

		/// <summary>
		/// Sets the operation mode of RFID radio module.  By default, when 
		/// an application opens a radio, the RFID Reader Library sets the 
		/// reporting mode to non-continuous.  An RFID radio module's 
		/// operation mode will remain in effect until it is explicitly changed 
		/// via RFID_RadioSetOperationMode, or the radio is closed and re-
		/// opened (at which point it will be set to non-continuous mode).  
		/// The operation mode may not be changed while a radio module is 
		/// executing a tag-protocol operation. 
		/// </summary>
		/// <param name="mode">The operation mode for the radio module.</param>
		/// <returns></returns>
		public Result SetOperationMode(RadioOperationMode mode)
		{
            switch (_deviceType)
            {
                case MODEL.CS710S:
                    return SetOperationMode_CS710S(mode);
            }

            return Result.FAILURE;
        }

        /// <summary>
        /// This is used to set inventory duration
        /// </summary>
        /// <param name="duration"></param>
        /// <returns></returns>
        public Result SetInventoryDuration(uint duration, uint antennaPort = 0)
		{
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetInventoryDuration_CS108(duration, antennaPort);

                case MODEL.CS710S:
                    return SetInventoryDuration_CS710S(duration, antennaPort);
            }

            return Result.FAILURE;
		}

        public Result SetInventoryDuration(uint [] duration)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetInventoryDuration_CS108(duration);

                case MODEL.CS710S:
                    return SetInventoryDuration_CS710S(duration);
            }

            return Result.FAILURE;
        }

        /// <summary>
        /// Configures the tag-selection criteria for the ISO 18000-6C select 
        /// command.  The supplied tag-selection criteria will be used for any 
        /// tag-protocol operations (i.e., Inventory, etc.) in 
        /// which the application specifies that an ISO 18000-6C select 
        /// command should be issued prior to executing the tag-protocol 
        /// operation (i.e., the SelectFlags.SELECT flag is provided to 
        /// the appropriate RFID_18K6CTag* function).  The tag-selection 
        /// criteria will stay in effect until the next call to 
        /// SetSelectCriteria.  Tag-selection criteria may not 
        /// be changed while a radio module is executing a tag-protocol 
        /// operation. 
        /// </summary>
        /// <param name="critlist">
        /// SelectCriteria array, containing countCriteria entries, of selection 
        /// criterion structures that are to be applied sequentially, beginning with 
        /// pCriteria[0], to the tag population.  If this field is NULL, 
        /// countCriteria must be zero. 
        ///</param>
        /// <returns></returns>
        public Result SetSelectCriteria(SelectCriterion[] critlist)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetSelectCriteria_CS108(critlist);

                case MODEL.CS710S:
                    return SetSelectCriteria_CS710S(critlist);
            }

            return Result.FAILURE;
        }

        public Result SetSelectCriteria(uint index, SelectCriterion crit)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetSelectCriteria_CS108(index, crit);

                case MODEL.CS710S:
                    return SetSelectCriteria_CS710S(index, crit);
            }

            return Result.FAILURE;
        }

        public Result SetPostMatchCriteria(SingulationCriterion[] postmatch)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetPostMatchCriteria_CS108(postmatch);

                    //                case MODEL.CS710S:
                    //                    return SetSelectCriteria_CS710S(critlist);
            }

            return Result.FAILURE;
        }


        #endregion

    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Private.Country.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;

namespace CSLibrary
{
    using static FrequencyBand;

    public partial class RFIDReader
    {
        private uint m_oem_country_code = 0;
        private uint m_oem_special_country_version;
        private uint m_oem_freq_modification_flag;
        private List<RegionCode> m_save_country_list = new List<RegionCode>();  // for CS108 API only
        private List<string> m_save_country_list_name = new List<string>();

        private uint GetOEMCountryCode
        {
            get
            {
                uint dataBuf = 0xff;

                //m_Result = MacReadOemData(0x2, ref dataBuf);
                if (m_Result != Result.OK)
                    return 0;

                return dataBuf;
            }
        }


        private void GenCountryList()
        {
            m_save_country_list.Clear();
            m_save_country_list_name.Clear();

            string Model = GetModelCountry();

            switch (Model)
            {
                case "-1":
                    m_save_country_list.Add(RegionCode.ETSI);
                    m_save_country_list.Add(RegionCode.IN);
                    m_save_country_list.Add(RegionCode.G800);
                    break;

                case "-2":
                    m_save_country_list.Add(RegionCode.FCC);
                    break;

                case "-2 RW":
                    m_save_country_list.Add(RegionCode.AR);
                    m_save_country_list.Add(RegionCode.AU);
                    m_save_country_list.Add(RegionCode.BA);
                    m_save_country_list.Add(RegionCode.BR1);
                    m_save_country_list.Add(RegionCode.BR2);
                    m_save_country_list.Add(RegionCode.BR3);
                    m_save_country_list.Add(RegionCode.BR4);
                    m_save_country_list.Add(RegionCode.BR5);
                    m_save_country_list.Add(RegionCode.CL);
                    m_save_country_list.Add(RegionCode.CO);
                    m_save_country_list.Add(RegionCode.CR);
                    m_save_country_list.Add(RegionCode.DO);
                    m_save_country_list.Add(RegionCode.FCC);
                    m_save_country_list.Add(RegionCode.HK);
                    m_save_country_list.Add(RegionCode.ID);
                    m_save_country_list.Add(RegionCode.JE);  // 915-917 MHz
                    m_save_country_list.Add(RegionCode.KR);
                    m_save_country_list.Add(RegionCode.MY);
                    m_save_country_list.Add(RegionCode.PA);
                    m_save_country_list.Add(RegionCode.PE);
                    m_save_country_list.Add(RegionCode.PH);  // 918-920 MHz
                    m_save_country_list.Add(RegionCode.SG);
                    m_save_country_list.Add(RegionCode.TH);
                    m_save_country_list.Add(RegionCode.UY);
                    m_save_country_list.Add(RegionCode.VE);
                    m_save_country_list.Add(RegionCode.VI);
                    m_save_country_list.Add(RegionCode.ZA);
                    m_save_country_list.Add(RegionCode.LH1);  // 
                    m_save_country_list.Add(RegionCode.LH2);  // 
                    m_save_country_list.Add(RegionCode.UH1); // 915-920 MHz
                    m_save_country_list.Add(RegionCode.UH2); // 920-928 MHz
                    break;

                case "-2 OFCA":
                    m_save_country_list.Add(RegionCode.HK);
                    break;

                case "-2 AS":
                    m_save_country_list.Add(RegionCode.AU);
                    break;

                case "-2 NZ":
                    m_save_country_list.Add(RegionCode.NZ);
                    break;

                case "-2 ZA":
                    m_save_country_list.Add(RegionCode.ZA);
                    break;

                case "-2 SG":
                    m_save_country_list.Add(RegionCode.SG);
                    break;

                case "-2 TH":
                    m_save_country_list.Add(RegionCode.TH);
                    break;

                case "-4":
                    m_save_country_list.Add(RegionCode.AU);
                    m_save_country_list.Add(RegionCode.CN);
                    m_save_country_list.Add(RegionCode.HK);
                    m_save_country_list.Add(RegionCode.ID);
                    m_save_country_list.Add(RegionCode.MY);
                    m_save_country_list.Add(RegionCode.SG);
                    m_save_country_list.Add(RegionCode.TW);
                    break;

                case "-6":
                    m_save_country_list.Add(RegionCode.KR);
                    break;

                case "-7":
                    m_save_country_list.Add(RegionCode.AU);
                    m_save_country_list.Add(RegionCode.CN);
                    m_save_country_list.Add(RegionCode.HK);
                    m_save_country_list.Add(RegionCode.ID);
                    m_save_country_list.Add(RegionCode.MY);
                    m_save_country_list.Add(RegionCode.SG);
                    m_save_country_list.Add(RegionCode.TH);
                    break;

                case "-8 JP4":
                    m_save_country_list.Add(RegionCode.JP);
                    break;

                case "-8 JP6":
                    m_save_country_list.Add(RegionCode.JP);
                    break;

                case "-9":
                    m_save_country_list.Add(RegionCode.ETSIUPPERBAND);
                    m_save_country_list.Add(RegionCode.ZA);
                    break;

                //default:
                    //throw new ReaderException(Result.INVALID_PARAMETER);
            }

            foreach (RegionCode code in m_save_country_list)
                m_save_country_list_name.Add(CSLibrary.FrequencyBand.GetRegionName(code));

            if (m_oem_freq_modification_flag == 0xaa)
                return;

            // add E710 frequency set
            foreach (var i in FrequencyBand_CS710S.frequencySet)
                if (i.modelCode.Equals(Model))
                {
                    var find = m_save_country_list_name.Find(item => item.Equals(i.name));

                    if (find == null)
                        m_save_country_list_name.Add(i.name);
                }
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Private.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using System.Reflection;


namespace CSLibrary
{
    using static RFIDDEVICE;
    using Constants;
    using Structures;
    using Events;
    using Tools;

    public partial class RFIDReader
    {
        private enum RFIDREADERCMDSTATUS
        {
            IDLE,           // Can send (SetRegister, GetRegister, ExecCmd, Abort), Can not receive data
            GETREGISTER,    // Can not send data, Can receive (GetRegister) 
            EXECCMD,        // Can send (Abort), Can receive (CMDBegin, CMDEnd, Inventory data, Abort)
            INVENTORY,      // Can send (Abort)
            ABORT,          // Can not send
        }

        // RFID event code
        internal class DOWNLINKCMD
        {
            public static readonly byte[] RFIDPOWERON = { 0x80, 0x00 };
            public static readonly byte[] RFIDPOWEROFF = { 0x80, 0x01 };
            public static readonly byte[] RFIDCMD = { 0x80, 0x02 };
        }

        private const int BYTES_PER_LEN_UNIT = 4;

        private const uint INVALID_POWER_VALUE = uint.MaxValue;
        private const uint INVALID_PROFILE_VALUE = uint.MaxValue;
        private const int DATA_FIELD_INDEX = 20;
        private const int RSSI_FIELD_INDEX = 12;
        private const int ANT_FIELD_INDEX = 14;
        private const int MS_FIELD_INDEX = 8;
        private const int RFID_PACKET_COMMON_SIZE = 8;

        private const ushort PC_START_OFFSET = 1;
        private const ushort PC_WORD_LENGTH = 1;
        private const ushort EPC_START_OFFSET = 2;
        private const ushort EPC_WORD_LENGTH = 6;
        private const ushort ACC_PWD_START_OFFSET = 2;
        private const ushort ACC_PWD_WORD_LENGTH = 2;
        private const ushort KILL_PWD_START_OFFSET = 0;
        private const ushort KILL_PWD_WORD_LENGTH = 2;
        private const ushort ONE_WORD_LEN = 1;
        private const ushort TWO_WORD_LEN = 2;

        private const ushort USER_WORD_LENGTH = 1;
        private const uint MAXFRECHANNEL = 50;

        private Result CurrentOperationResult;

        internal CSLibraryOperationParms m_rdr_opt_parms = new CSLibraryOperationParms();

        #region ====================== Fire Event ======================
        private void FireStateChangedEvent(RFState e)
        {
            TellThemOnStateChanged(this, new OnStateChangedEventArgs(e));
        }

        private void FireAccessCompletedEvent(OnAccessCompletedEventArgs args/*bool success, Bank bnk, TagAccess access, IBANK data*/)
        {
            TellThemOnAccessCompleted(this, args);
        }

        private void TellThemOnStateChanged(object sender, OnStateChangedEventArgs e)
        {
            if (OnStateChanged != null)
            {
                try
                {
                    OnStateChanged(sender, e);
                }
                catch (Exception ex)
                {
                    //Console.WriteLine(ex);
                }
            }
        }

        private void TellThemOnAccessCompleted(object sender, OnAccessCompletedEventArgs e)
        {
            if (OnAccessCompleted != null)
            {
                try
                {
                    OnAccessCompleted(sender, e);
                }
                catch (Exception ex)
                {
                    //Console.WriteLine(ex);
                }
            }
        }

        #endregion

        void Start18K6CRequest(uint tagStopCount, SelectFlags flags)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    Start18K6CRequest_CS108(tagStopCount, flags);
                    break;

                case MODEL.CS710S:
                    Start18K6CRequest_CS710S(tagStopCount, flags);
                    break;
            }
        }

        private void TagLockThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    TagLockThreadProc_CS108();
                    break;

                case MODEL.CS710S:
                    TagLockThreadProc_CS710S();
                    break;
            }
        }

        private void TagBlockLockThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    TagBlockLockThreadProc_CS108();
                    break;

                case MODEL.CS710S:
                    TagBlockLockThreadProc_CS710S();
                    break;
            }
        }

        private void TagKillThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    TagKillThreadProc_CS108();
                    break;

                case MODEL.CS710S:
                    TagKillThreadProc_CS710S();
                    break;
            }

            m_Result = Result.OK;
            return;
        }


        private void TagAuthenticateThreadProc()
        {
        }

        private void TagReadBufferThreadProc()
        {
        }

        private void TagUntraceableThreadProc()
        {
            return;
        }


        private bool FM13DTReadMemoryThreadProc()
        {
            return false;
        }

        private bool FM13DTWriteMemoryThreadProc()
        {
            return false;
        }

        private bool FM13DTReadRegThreadProc()
        {
            return true;
        }

        private bool FM13DTWriteRegThreadProc()
        {
            return true;
        }

        private bool FM13DTAuthThreadProc()
        {
//            FM13DT160_Auth(m_rdr_opt_parms.FM FM13DTWriteMemory.offset, m_rdr_opt_parms.FM13DTWriteMemory.count);
            return true;
        }

        private bool FM13DTGetTempThreadProc()
        {
            //FM13DT160_GetTemp(m_rdr_opt_parms.FM13DTWriteMemory.offset, m_rdr_opt_parms.FM13DTWriteMemory.count, m_rdr_opt_parms.FM13DTWriteMemory.data);
            return true;
        }
        private bool FM13DTStartLogThreadProc()
        {
            return true;
        }
        private bool FM13DTStopLogChkThreadProc()
        {
            return true;
        }
        private bool FM13DTDeepSleepThreadProc()
        {
            return true;
        }
        private bool FM13DTOpModeChkThreadProc()
        {
            return true;
        }
        private bool FM13DTInitialRegFileThreadProc()
        {
            return true;
        }

        private bool FM13DTLedCtrlThreadProc()
        {
            return true;
        }

        /// <summary>
        /// rfid reader packet
        /// </summary>
        /// <param name="RW"></param>
        /// <param name="add"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        internal byte[] PacketData(UInt16 add, UInt32? value = null)
        {
            byte[] CMDBuf = new byte[8];

            if (value == null)
            {
                CMDBuf[1] = 0x00;
                CMDBuf[4] = 0x00;
                CMDBuf[5] = 0x00;
                CMDBuf[6] = 0x00;
                CMDBuf[7] = 0x00;
            }
            else
            {
                CMDBuf[1] = 0x01;
                CMDBuf[4] = (byte)value;
                CMDBuf[5] = (byte)(value >> 8);
                CMDBuf[6] = (byte)(value >> 16);
                CMDBuf[7] = (byte)(value >> 24);
            }

            CMDBuf[0] = 0x70;
            CMDBuf[2] = (byte)add;
            CMDBuf[3] = (byte)((uint)add >> 8);

            return CMDBuf;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Private.FrequencyChannel.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;

namespace CSLibrary
{
    using static FrequencyBand;

    public partial class RFIDReader
    {
        /// <summary>
        /// Get frequency table on specific region
        /// </summary>
        /// <param name="region">Region Code</param>
        /// <returns></returns>
        internal double[] GetAvailableFrequencyTable_CS108(RegionCode region)
        {
            switch (region)
            {
                case RegionCode.AU:
                    return AUSTableOfFreq;
                case RegionCode.CN:
                    return CHNTableOfFreq;
                case RegionCode.ETSI:
                case RegionCode.G800:
                    return ETSITableOfFreq;
                case RegionCode.IN:
                    return IDATableOfFreq;
                case RegionCode.AR:
                case RegionCode.CL:
                case RegionCode.CO:
                case RegionCode.CR:
                case RegionCode.DO:
                case RegionCode.PA:
                case RegionCode.UY:
                case RegionCode.FCC:
                    return FCCTableOfFreq;
                case RegionCode.HK:
                    return OFCATableOfFreq;
                case RegionCode.SG:
                case RegionCode.TH:
                case RegionCode.VI:
                    return HKTableOfFreq;
                case RegionCode.JP:
                    if (m_oem_special_country_version == 0x2A4A5036)
                        return JPN2012TableOfFreq;
                    else
                        return JPN2019TableOfFreq;
                case RegionCode.KR:
                    return KRTableOfFreq;
                case RegionCode.MY:
                    return MYSTableOfFreq;
                case RegionCode.TW:
                    return TWTableOfFreq;
                case RegionCode.ZA:
                    return ZATableOfFreq;
                case RegionCode.BR1:
                    return BR1TableOfFreq;
                case RegionCode.PE:
                case RegionCode.BR2:
                    return BR2TableOfFreq;
                case RegionCode.BR3:
                    return BR3TableOfFreq;
                case RegionCode.BR4:
                    return BR4TableOfFreq;
                case RegionCode.BR5:
                    return BR5TableOfFreq;
                case RegionCode.ID:
                    return IDTableOfFreq;
                case RegionCode.JE:
                    return JETableOfFreq;
                case RegionCode.PH:
                    return PHTableOfFreq;
                case RegionCode.ETSIUPPERBAND:
                    return ETSIUPPERBANDTableOfFreq;
                case RegionCode.NZ:
                    return NZTableOfFreq;
                case RegionCode.UH1:
                    return UH1TableOfFreq;
                case RegionCode.UH2:
                    return UH2TableOfFreq;
                case RegionCode.LH:
                    return LHTableOfFreq;
                case RegionCode.LH1:
                    return LH1TableOfFreq;
                case RegionCode.LH2:
                    return LH2TableOfFreq;
                case RegionCode.VE:
                    return VETableOfFreq;
                case RegionCode.BA:
                    return BATableOfFreq;
                default:
                    return new double[0];
            }
        }


    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Private.Inventory.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        //private void StartInventory()
        //{
        //    _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.INV), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);

            //_deviceHandler.rfid._dataBuffer.Clear();
            /*
            // Create a timer that waits one second, then invokes every second.
            Xamarin.Forms.Device.StartTimer(TimeSpan.FromMilliseconds(2000), () => {
                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0, 0xf000, 0x000f), (UInt32)SENDREMARK.INVENTORY);
                return true;
            });
            */
        //}

/*
		private void TagRangingThreadProc()
		{
            
            _tagRangingParms = m_rdr_opt_parms.TagRanging.Clone();

            uint Value = 0;

			CSLibrary.Structures.InternalTagRangingParms parms = new CSLibrary.Structures.InternalTagRangingParms();
			parms.flags = m_rdr_opt_parms.TagRanging.flags;
			parms.tagStopCount = m_rdr_opt_parms.TagRanging.tagStopCount;

			// Set MultiBanks Info
			MacReadRegister(MACREGISTER.HST_INV_CFG, ref Value);

			Value &= 0xfff5fcff;
			if (m_rdr_opt_parms.TagRanging.multibanks != 0)
				Value |= (m_rdr_opt_parms.TagRanging.multibanks & (uint)0x03) << 16;

			if (m_rdr_opt_parms.TagRanging.QTMode == true)
				Value |= 0x00080000; // bit 19

            Value &= ~(0x03f00000U); // Set delay time to 0

            if (m_rdr_opt_parms.TagRanging.compactmode)
            {
                Value |= _INVENTORYDELAYTIME;
                Value |= (1 << 26); // bit 26
                MacWriteRegister(MACREGISTER.INV_CYCLE_DELAY, _InventoryCycleDelay);
            }
            else
            {
                Value |= (30 << 20);
                Value &= ~(1U << 26); // bit 26
                MacWriteRegister(MACREGISTER.INV_CYCLE_DELAY, 0);
            }

            MacWriteRegister(MACREGISTER.HST_INV_CFG, Value);

            Value = 0;
            if (m_rdr_opt_parms.TagRanging.focus)
                Value |= 0x10;
            if (m_rdr_opt_parms.TagRanging.fastid)
                Value |= 0x20;
            MacWriteRegister(MACREGISTER.HST_IMPINJ_EXTENSIONS, Value);
            
        // Set up the access bank register
        Value = (UInt32)(m_rdr_opt_parms.TagRanging.bank1) | (UInt32)(((int)m_rdr_opt_parms.TagRanging.bank2) << 2);
			MacWriteRegister(MACREGISTER.HST_TAGACC_BANK, Value);

			// Set up the access pointer register (tells the offset)
			Value = (UInt32)((m_rdr_opt_parms.TagRanging.offset1 & 0xffff) | ((m_rdr_opt_parms.TagRanging.offset2 & 0xffff) << 16));
			MacWriteRegister(MACREGISTER.HST_TAGACC_PTR, Value);

			// Set up the access count register (i.e., number values to read)
			Value = (UInt32)((0xFF & m_rdr_opt_parms.TagRanging.count1) | ((0xFF & m_rdr_opt_parms.TagRanging.count2) << 8));
			MacWriteRegister(MACREGISTER.HST_TAGACC_CNT, Value);

			// Set up the access password
			Value = (UInt32)(m_rdr_opt_parms.TagRanging.accessPassword);
			MacWriteRegister(MACREGISTER.HST_TAGACC_ACCPWD, Value);

			// Set Toggle off, if QT Mode. 
			if (m_rdr_opt_parms.TagRanging.QTMode == true)
			{
				uint RegValue = 0;

				for (uint cnt = 0; cnt < 4; cnt++)
				{
					MacWriteRegister(MACREGISTER.HST_INV_SEL, cnt);
					MacReadRegister(MACREGISTER.HST_INV_ALG_PARM_2, ref RegValue);
					Value &= 0xfffffffe;
					MacWriteRegister(MACREGISTER.HST_INV_ALG_PARM_2, Value);
				}
			}

			Start18K6CRequest(m_rdr_opt_parms.TagRanging.tagStopCount, parms.flags);

			_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.INV), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
			//m_Result = COMM_HostCommand(HST_CMD.INV);
		}
*/

        private CSLibrary.Structures.TagRangingParms _tagRangingParms;

/*        private void PreTagRangingThreadProc()
        {
            _tagRangingParms = m_rdr_opt_parms.TagRanging.Clone();

            uint Value = 0;

            CSLibrary.Structures.InternalTagRangingParms parms = new CSLibrary.Structures.InternalTagRangingParms();
            parms.flags = m_rdr_opt_parms.TagRanging.flags;
            parms.tagStopCount = m_rdr_opt_parms.TagRanging.tagStopCount;

            // Set MultiBanks Info
            MacReadRegister(MACREGISTER.HST_INV_CFG, ref Value);

            Value &= 0xfff0fcff;

            Value |= (1 << 18); // enable CRC checking

            if (m_rdr_opt_parms.TagRanging.multibanks != 0)
                Value |= (m_rdr_opt_parms.TagRanging.multibanks & (uint)0x03) << 16;

            if (m_rdr_opt_parms.TagRanging.QTMode == true)
                Value |= (1 << 19); // bit 19

            Value &= ~(0x03f00000U); // Set delay time to 0

            if (m_rdr_opt_parms.TagRanging.compactmode)
            {
                Value |= _INVENTORYDELAYTIME;
                Value |= (1 << 26); // bit 26
                MacWriteRegister(MACREGISTER.INV_CYCLE_DELAY, _InventoryCycleDelay);
            }
            else
            {
                Value |= (30 << 20);
                Value &= ~(1U << 26); // bit 26
                MacWriteRegister(MACREGISTER.INV_CYCLE_DELAY, 0);
            }

            MacWriteRegister(MACREGISTER.HST_INV_CFG, Value);

            Value = 0;
            if (m_rdr_opt_parms.TagRanging.focus)
                Value |= 0x10;
            if (m_rdr_opt_parms.TagRanging.fastid)
                Value |= 0x20;
            MacWriteRegister(MACREGISTER.HST_IMPINJ_EXTENSIONS, Value);

            // Set up the access bank register
            Value = (UInt32)(m_rdr_opt_parms.TagRanging.bank1) | (UInt32)(((int)m_rdr_opt_parms.TagRanging.bank2) << 2);
            MacWriteRegister(MACREGISTER.HST_TAGACC_BANK, Value);

            // Set up the access pointer register (tells the offset)
            Value = (UInt32)((m_rdr_opt_parms.TagRanging.offset1 & 0xffff) | ((m_rdr_opt_parms.TagRanging.offset2 & 0xffff) << 16));
            MacWriteRegister(MACREGISTER.HST_TAGACC_PTR, Value);

            // Set up the access count register (i.e., number values to read)
            Value = (UInt32)((0xFF & m_rdr_opt_parms.TagRanging.count1) | ((0xFF & m_rdr_opt_parms.TagRanging.count2) << 8));
            MacWriteRegister(MACREGISTER.HST_TAGACC_CNT, Value);

            // Set up the access password
            Value = (UInt32)(m_rdr_opt_parms.TagRanging.accessPassword);
            MacWriteRegister(MACREGISTER.HST_TAGACC_ACCPWD, Value);

            // Set Toggle off, if QT Mode. 
            if (m_rdr_opt_parms.TagRanging.QTMode == true)
            {
                uint RegValue = 0;

                for (uint cnt = 0; cnt < 4; cnt++)
                {
                    MacWriteRegister(MACREGISTER.HST_INV_SEL, cnt);
                    MacReadRegister(MACREGISTER.HST_INV_ALG_PARM_2, ref RegValue);
                    Value &= 0xfffffffe;
                    MacWriteRegister(MACREGISTER.HST_INV_ALG_PARM_2, Value);
                }
            }

            Start18K6CRequest(m_rdr_opt_parms.TagRanging.tagStopCount, parms.flags);
        }
*/

        private void ExeTagRangingThreadProc()
        {
            RunShortOperation (SCSLRFIDCMD.SCSLRFIDStartCompactInventory);
//            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.INV), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Private.Read.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using CSLibrary.Constants;
using CSLibrary.Structures;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using static CSLibrary.RFIDDEVICE;

namespace CSLibrary
{
    using static RFIDDEVICE;

    public partial class RFIDReader
    {
        void Setup18K6CReadRegisters(UInt32 bank, UInt32 offset, UInt32 count)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    Setup18K6CReadRegisters_CS108(bank, offset, count);
                    break;

                case MODEL.CS710S:
                    Setup18K6CReadRegisters_CS710S(bank, offset, count);
                    break;
            }
        }

        public int Start18K6CRead(uint bank, uint offset, uint count, UInt16[] data, uint accessPassword, uint retry, CSLibrary.Constants.SelectFlags flags)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return Start18K6CRead_CS108(bank, offset, count, data, accessPassword, retry, flags);

                case MODEL.CS710S:
                    return Start18K6CRead_CS710S(bank, offset, count, data, accessPassword, retry, flags);
            }

            return 0;
        } //  Start18K6CRead

        bool CUST_18K6CTagRead(CSLibrary.Constants.MemoryBank bank, int offset, int count, UInt16[] data, UInt32 password, /*UInt32 retry, */CSLibrary.Constants.SelectFlags flags)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return CUST_18K6CTagRead_CS108(bank, offset, count, data, password, flags);

                case MODEL.CS710S:
                    return CUST_18K6CTagRead_CS710S(bank, offset, count, data, password, flags);
            }

            return false;
        }

        private void ReadThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    ReadThreadProc_CS108();
                    break;

                case MODEL.CS710S:
                    ReadThreadProc_CS710S();
                    break;
            }
        }

        private void TagReadPCThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    TagReadPCThreadProc_CS108();
                    break;

                case MODEL.CS710S:
                    TagReadPCThreadProc_CS710S();
                    break;
            }
        }

        private void TagReadEPCThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    TagReadEPCThreadProc_CS108();
                    break;

                case MODEL.CS710S:
                    TagReadEPCThreadProc_CS710S();
                    break;
            }
        }

        private void TagReadAccPwdThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    TagReadAccPwdThreadProc_CS108();
                    break;

                case MODEL.CS710S:
                    TagReadAccPwdThreadProc_CS710S();
                    break;
            }
        }

        private void TagReadKillPwdThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    TagReadKillPwdThreadProc_CS108();
                    break;

                case MODEL.CS710S:
                    TagReadKillPwdThreadProc_CS710S();
                    break;
            }
        }

        private void TagReadTidThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    TagReadTidThreadProc_CS108();
                    break;

                case MODEL.CS710S:
                    TagReadTidThreadProc_CS710S();
                    break;
            }
        }

        private void TagReadUsrMemThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    TagReadUsrMemThreadProc_CS108();
                    break;

                case MODEL.CS710S:
                    TagReadUsrMemThreadProc_CS710S();
                    break;
            }
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Private.Select.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    using static RFIDDEVICE;
    using Constants;

    public partial class RFIDReader
    {
        private Structures.TagSelectedParms _tagSelectedParms;

        private void TagSelected()
        {
            switch (_deviceType)
            {
                case MODEL.CS710S:
                    TagSelected_CS710S();
                    break;
            }
        }

        private void TagSelectedDYNQ()
        {
            switch (_deviceType)
            {
                case MODEL.CS710S:
                    //TagSelectedDYNQ_CS710S();
                    break;
            }
        }

        /// <summary>
        /// Only set first EPC ID and length (register 0x804-0x807)
        /// </summary>
        private void FastTagSelected()
        {
            switch (_deviceType)
            {
                case MODEL.CS710S:
                    FastTagSelected_CS710S();
                    break;
            }
        }

        private void PreFilter()
        {
            switch (_deviceType)
            {
                case MODEL.CS710S:
                    PreFilter_CS710S();
                    break;
            }
        }

        private void SetMaskThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS710S:
                    SetMaskThreadProc_CS710S();
                    break;
            }
        }

        private void PostFilter()
        {
            switch (_deviceType)
            {
                case MODEL.CS710S:
                    PostFilter_CS710S();
                    break;
            }
        }

    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Private.Write.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    using static RFIDDEVICE;
    using Constants;
    using Structures;

    public partial class RFIDReader
    {
        const int MAX_WR_CNT = 0x20;

        void Setup18K6CWriteRegisters(CSLibrary.Constants.MemoryBank WriteBank, UInt32 WriteOffset, UInt32 WriteSize, UInt16[] WriteBuf, UInt32 BufOffset)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    Setup18K6CWriteRegisters_CS108(WriteBank, WriteOffset, WriteSize, WriteBuf, BufOffset);
                    break;

                case MODEL.CS710S:
                    Setup18K6CWriteRegisters_CS710S(WriteBank, WriteOffset, WriteSize, WriteBuf, BufOffset);
                    break;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="bank"></param>
        /// <param name="offset"></param>
        /// <param name="count"></param>
        /// <param name="data"></param>
        /// <param name="password"></param>
        /// <param name="retry"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        private CSLibrary.Constants.Result CUST_18K6CTagWrite(
            CSLibrary.Constants.MemoryBank bank,
            UInt32 offset,
            UInt32 count,
            UInt16[] data,
            UInt32 password,
            CSLibrary.Constants.SelectFlags flags
        )
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return CUST_18K6CTagWrite_CS108(bank, offset, count, data, password, flags);
                    break;

                case MODEL.CS710S:
                    return CUST_18K6CTagWrite_CS710S(bank, offset, count, data, password, flags);
                    break;
            }

            return Result.FAILURE;
        }

        private void WriteThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    WriteThreadProc_CS108();
                    break;

                case MODEL.CS710S:
                    WriteThreadProc_CS710S();
                    break;
            }
        }

        private void TagWritePCThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    TagWritePCThreadProc_CS108();
                    break;

                case MODEL.CS710S:
                    TagWritePCThreadProc_CS710S();
                    break;
            }
        }

        private void TagWriteEPCThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    TagWriteEPCThreadProc_CS108();
                    break;

                case MODEL.CS710S:
                    TagWriteEPCThreadProc_CS710S();
                    break;
            }
        }

        private void TagWriteAccPwdThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    TagWriteAccPwdThreadProc_CS108();
                    break;

                case MODEL.CS710S:
                    TagWriteAccPwdThreadProc_CS710S();
                    break;
            }
        }

        private void TagWriteKillPwdThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    TagWriteKillPwdThreadProc_CS108();
                    break;

                case MODEL.CS710S:
                    TagWriteKillPwdThreadProc_CS710S();
                    break;
            }
        }

        private void TagWriteUsrMemThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    TagWriteUsrMemThreadProc_CS108();
                    break;

                case MODEL.CS710S:
                    TagWriteUsrMemThreadProc_CS710S();
                    break;
            }
        }

        private void BlockWriteThreadProc()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    BlockWriteThreadProc_CS108();
                    break;

                case MODEL.CS710S:
                    BlockWriteThreadProc_CS710S();
                    break;
            }
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.Algorithm.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace CSLibrary
{
    using static RFIDDEVICE;
    using Constants;
    using Structures;

    public partial class RFIDReader
    {
        /// <summary>
        /// Allows the application to set the currently-active singulation 
        /// algorithm (i.e., the one that is used when performing a tag-
        /// protocol operation (e.g., inventory, tag read, etc.)).  The 
        /// currently-active singulation algorithm may not be changed while a 
        /// radio module is executing a tag-protocol operation. 
        /// </summary>
        /// <param name="SingulationAlgorithm">
        /// The singulation algorithm that is to be used for 
        /// subsequent tag-access operations.  If this 
        /// parameter does not represent a valid 
        /// singulation algorithm, 
        /// RFID_ERROR_INVALID_PARAMETER is returned. </param>m
        public Result SetCurrentSingulationAlgorithm(SingulationAlgorithm SingulationAlgorithm)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetCurrentSingulationAlgorithm_CS108(SingulationAlgorithm);
                    break;

                case MODEL.CS710S:
                    return SetCurrentSingulationAlgorithm_CS710S(SingulationAlgorithm);
                    break;
            }

            return Result.FAILURE;
        }

        /// <summary>
        /// Get Current Singulation Algorithm
        /// </summary>
        /// <param name="SingulationAlgorithm"></param>
        /// <returns></returns>
        public Result GetCurrentSingulationAlgorithm(ref SingulationAlgorithm SingulationAlgorithm)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return GetCurrentSingulationAlgorithm_CS108(ref SingulationAlgorithm);
                    break;

                case MODEL.CS710S:
                    return GetCurrentSingulationAlgorithm_CS710S(ref SingulationAlgorithm);
                    break;
            }

            return Result.FAILURE;
        }

        /// <summary>
        /// SetSingulationAlgorithmParms
        /// </summary>
        /// <param name="alg"></param>
        /// <param name="parms"></param>
        /// <returns></returns>
        public Result SetSingulationAlgorithmParms(SingulationAlgorithm alg, SingulationAlgorithmParms parms)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetSingulationAlgorithmParms_CS108(alg, parms);
                    break;

                case MODEL.CS710S:
                    return SetSingulationAlgorithmParms_CS710S(alg, parms);
                    break;
            }

            return Result.FAILURE;
        }

        /// <summary>
        /// The  parameters  for  the  fixed-Q  algorithm,  MAC  singulation  algorithm  0
        /// If running a same operation, it only need to config once times
        /// </summary>
        /// <param name="QValue">The Q value to use.  Valid values are 0-15, inclusive.</param>
        /// <param name="RetryCount">Specifies the number of times to try another execution 
        /// of the singulation algorithm for the specified 
        /// session/target before either toggling the target (if 
        /// toggleTarget is non-zero) or terminating the 
        /// inventory/tag access operation.  Valid values are 0-
        /// 255, inclusive. Valid values are 0-255, inclusive.</param>
        /// <param name="ToggleTarget"> A non-zero value indicates that the target should
        /// be toggled.A zero value indicates that the target should not be toggled.
        /// Note that if the target is toggled, retryCount and repeatUntilNoTags will also apply
        /// to the new target. </param>
        public Result SetFixedQParms(uint QValue, uint ToggleTarget)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetFixedQParms_CS108(QValue, 0, ToggleTarget, 0);
                    //return SetFixedQParms_CS108(QValue, ToggleTarget);
                    break;

                case MODEL.CS710S:
                    return SetFixedQParms_CS710S(QValue, ToggleTarget);
                    break;
            }

            return Result.FAILURE;
        }
        /// <summary>
        /// The  parameters  for  the  fixed-Q  algorithm,  MAC  singulation  algorithm  0
        /// If running a same operation, it only need to config once times
        /// </summary>
        /// <returns></returns>
        public Result SetFixedQParms(FixedQParms fixedQParm)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetFixedQParms_CS108(fixedQParm);
                    break;

                case MODEL.CS710S:
                    return SetFixedQParms_CS710S(fixedQParm);
                    break;
            }

            return Result.FAILURE;
        }
        /// <summary>
        /// The  parameters  for  the  fixed-Q  algorithm,  MAC  singulation  algorithm  0
        /// If running a same operation, it only need to config once times
        /// </summary>
        /// <returns></returns>
        public Result SetFixedQParms()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetFixedQParms_CS108();
                    break;

                case MODEL.CS710S:
                    return SetFixedQParms_CS710S();
                    break;
            }

            return Result.FAILURE;
        }

        /// <summary>
        /// The parameters for the dynamic-Q algorithm with application-controlled Q-adjustment-threshold, MAC singulation algorithm 3
        /// </summary>
        /// <param name="StartQValue">The starting Q value to use.  Valid values are 0-15, inclusive.  
        /// startQValue must be greater than or equal to minQValue and 
        /// less than or equal to maxQValue. </param>
        /// <param name="MinQValue">The minimum Q value to use.  Valid values are 0-15, inclusive.  
        /// minQValue must be less than or equal to startQValue and 
        /// maxQValue. </param>
        /// <param name="MaxQValue">The maximum Q value to use.  Valid values are 0-15, inclusive.  
        /// maxQValue must be greater than or equal to startQValue and 
        /// minQValue. </param>
        /// <param name="ToggleTarget">A flag that indicates if, after performing the inventory cycle for the 
        /// specified target (i.e., A or B), if the target should be toggled (i.e., 
        /// A to B or B to A) and another inventory cycle run.  A non-zero 
        /// value indicates that the target should be toggled.  A zero value 
        /// indicates that the target should not be toggled.  Note that if the 
        /// target is toggled, retryCount and maxQueryRepCount will 
        /// also apply to the new target. </param>
        public Result SetDynamicQParms(uint StartQValue, uint MinQValue, uint MaxQValue, uint ToggleTarget)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetDynamicQParms_CS108(StartQValue, MinQValue, MaxQValue, 0, 0, ToggleTarget);
                    //return SetDynamicQParms_CS108(StartQValue, MinQValue, MaxQValue, ToggleTarget);
                    break;

                case MODEL.CS710S:
                    return SetDynamicQParms_CS710S(StartQValue, MinQValue, MaxQValue, ToggleTarget);
                    break;
            }

            return Result.FAILURE;
        }
        /// <summary>
        /// The parameters for the dynamic-Q algorithm with application-controlled Q-adjustment-threshold
        /// </summary>
        /// <returns></returns>
        public Result SetDynamicQParms(DynamicQParms dynParm)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetDynamicQParms_CS108(dynParm);
                    break;

                case MODEL.CS710S:
                    return SetDynamicQParms_CS710S(dynParm);
                    break;
            }

            return Result.FAILURE;
        }
        /// <summary>
        /// The parameters for the dynamic-Q algorithm with application-controlled Q-adjustment-threshold
        /// </summary>
        /// <returns></returns>
        public Result SetDynamicQParms()
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetDynamicQParms_CS108();
                    break;

                case MODEL.CS710S:
                    return SetDynamicQParms_CS710S();
                    break;
            }

            return Result.FAILURE;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.Antenna.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Text;

namespace CSLibrary
{
    using static RFIDDEVICE;
    using Constants;
    using Structures;

    public partial class RFIDReader
    {
        //AntennaList m_AntennaList = nullnew AntennaList(AntennaList.DEFAULT_ANTENNA_LIST, true);
        AntennaList m_AntennaList = null;

        public AntennaList AntennaList
        {
            get { lock (m_AntennaList) return m_AntennaList; }
            set { lock (m_AntennaList) m_AntennaList = value; }
        }

        public Result SetDefaultAntennaList()
        {
            //DEBUG_WriteLine(DEBUGLEVEL.API, "HighLevelInterface.SetDefaultAntennaList()");
            
            m_AntennaList = new AntennaList();

            switch (m_oem_machine)
            {
                case MODEL.CS108:
                case MODEL.CS710S:
                    m_AntennaList.Add(new Antenna(0, AntennaPortState.ENABLED, 300, 0, 0x2000, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    break;

                default:
                    m_AntennaList.Add(new Antenna(0, AntennaPortState.ENABLED, 300, 0, 0x2000, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(1, AntennaPortState.DISABLED, 300, 0, 0x2000, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(2, AntennaPortState.DISABLED, 300, 0, 0x2000, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(3, AntennaPortState.DISABLED, 300, 0, 0x2000, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    break;
            }

            try
            {
                int i;
                //m_AntennaList = new AntennaList(AntennaList.DEFAULT_ANTENNA_LIST, true);
                for (i = 0; i < m_AntennaList.Count; i++)
                {
                    if (m_AntennaList[i].PowerLevel > GetSoftwareMaxPowerLevel(m_save_region_code))
                        m_AntennaList[i].PowerLevel = GetSoftwareMaxPowerLevel(m_save_region_code);

                    SetAntennaPortStatus((uint)i, m_AntennaList[i].AntennaStatus);
                    SetAntennaPortConfiguration((uint)i, m_AntennaList[i].AntennaConfig);
                }

                for (; i < 16; i++)
                {
                    AntennaPortSetState((uint)i, AntennaPortState.DISABLED);
                }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("HighLevelInterface.SetDefaultAntennaList() : " + ex.Message);
                //DEBUG_WriteLine(DEBUGLEVEL.API, "HighLevelInterface.SetDefaultAntennaList() : " + ex.Message);
                //CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.SetDefaultAntennaList()", ex);
            }

            return Result.OK;
        }

        /// <summary>
        /// Retrieves the status of the requested logical antenna port for a 
        /// particular radio module.  The antenna-port status cannot be 
        /// retrieved while a radio module is executing a tag-protocol 
        /// operation. 
        /// </summary>
        /// <param name="portStatus"></param>
        /// <returns></returns>
        public Result GetAntennaPortStatus(AntennaPortStatus portStatus)
        {
            return (m_Result = AntennaPortGetStatus(0, portStatus));
        }

        /// <summary>
        /// Retrieves the status of the requested logical antenna port for a 
        /// particular radio module.  The antenna-port status cannot be 
        /// retrieved while a radio module is executing a tag-protocol 
        /// operation. 
        /// </summary>
        /// <param name="port">antenna port</param>
        /// <param name="portStatus"></param>
        /// <returns></returns>
        public Result GetAntennaPortStatus(uint port, AntennaPortStatus portStatus)
        {
            return (m_Result = AntennaPortGetStatus(port, portStatus));
        }

        public Result AntennaPortGetStatus(uint port, AntennaPortStatus portStatus)
        {
            return Result.OK;
        }

        /// <summary>
        /// Retrieves the status of the requested logical antenna port for a 
        /// particular radio module.  The antenna-port status cannot be 
        /// retrieved while a radio module is executing a tag-protocol 
        /// operation. 
        /// </summary>
        /// <param name="portStatus"></param>
        /// <returns></returns>
        public Result SetAntennaPortStatus(AntennaPortStatus portStatus)
        {
            return (m_Result = AntennaPortSetStatus(0, portStatus));
        }

        /// <summary>
        /// Retrieves the status of the requested logical antenna port for a 
        /// particular radio module.  The antenna-port status cannot be 
        /// retrieved while a radio module is executing a tag-protocol 
        /// operation. 
        /// </summary>
        /// <param name="port">antenna port</param>
        /// <param name="portStatus"></param>
        /// <returns></returns>
        public Result SetAntennaPortStatus(uint port, AntennaPortStatus portStatus)
        {
            m_AntennaList[(int)port].AntennaStatus = portStatus;

            return (m_Result = AntennaPortSetStatus(port, portStatus));
        }

        public Result AntennaPortSetStatus(uint port, AntennaPortStatus portStatus)
        {
            return Result.OK;
        }

        /// <summary>
        /// Allows an application to specify whether or not a radio module's 
        /// logical antenna port is enabled for subsequent tag operations.  The 
        /// antenna-port state cannot be set while a radio module is executing 
        /// a tag-protocol operation. 
        /// </summary>
        /// <param name="portState">The new state of the logical antenna port. </param>
        /// <returns></returns>
        public Result SetAntennaPortState(AntennaPortState portState)
        {
            if (portState == AntennaPortState.UNKNOWN)
                return Result.INVALID_PARAMETER;

            return (m_Result = AntennaPortSetState(0, portState));
        }

        /// <summary>
        /// Allows an application to specify whether or not a radio module's 
        /// logical antenna port is enabled for subsequent tag operations.  The 
        /// antenna-port state cannot be set while a radio module is executing 
        /// a tag-protocol operation. 
        /// </summary>
        /// <param name="port">antenna port</param>
        /// <param name="portState">The new state of the logical antenna port.</param>
        /// <returns></returns>
        public Result SetAntennaPortState(uint port, AntennaPortState portState)
        {
            if (portState == AntennaPortState.UNKNOWN)
                return Result.INVALID_PARAMETER;

            m_AntennaList[(int)port].State = portState;

            return (m_Result = AntennaPortSetState(port, portState));
        }

        public Result AntennaPortSetState(UInt32 antennaPort, AntennaPortState state)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    AntennaPortSetState_CS108(antennaPort, state);
                    break;

                case MODEL.CS710S:
                    AntennaPortSetState_CS710S(antennaPort, state);
                    break;
            }

            return Result.FAILURE;
        } // Radio::SetAntennaPortState


        /// <summary>
        /// Allows an application to retrieve a single logical antenna port's 
        /// configuration parameters  e.g., dwell time, power level, and 
        /// number of inventory cycles.  Even if the logical antenna port is 
        /// disabled, an application is allowed to retrieve these configuration 
        /// parameters.  Retrieving configuration parameters does not cause a 
        /// logical antenna port to be automatically enabled; the application 
        /// must still enable the logical antenna port via 
        /// RFID_AntennaPortSetState.  The antenna-port configuration 
        /// cannot be retrieved while a radio module is executing a tag-
        /// protocol operation. 
        /// </summary>
        /// <param name="antenna">A structure that upon return will 
        /// contain the antenna-port configuration 
        /// parameters. </param>
        /// <returns>
        /// </returns>
        public Result GetAntennaPortConfiguration(ref AntennaPortConfig antenna)
        {
            AntennaPortGetConfiguration(0, antenna);

            return Result.OK;
        }

        /// <summary>
        /// Allows an application to retrieve a single logical antenna port's 
        /// configuration parameters  e.g., dwell time, power level, and 
        /// number of inventory cycles.  Even if the logical antenna port is 
        /// disabled, an application is allowed to retrieve these configuration 
        /// parameters.  Retrieving configuration parameters does not cause a 
        /// logical antenna port to be automatically enabled; the application 
        /// must still enable the logical antenna port via 
        /// RFID_AntennaPortSetState.  The antenna-port configuration 
        /// cannot be retrieved while a radio module is executing a tag-
        /// protocol operation. 
        /// </summary>
        /// <param name="port">antenna-port</param>
        /// <param name="antenna">A structure that upon return will 
        /// contain the antenna-port configuration 
        /// parameters. </param>
        /// <returns>
        /// </returns>
        public Result GetAntennaPortConfiguration(uint port, ref AntennaPortConfig antenna)
        {
            AntennaPortGetConfiguration(port, antenna);

            return Result.OK;
        }

        Result AntennaPortGetConfiguration(uint port, AntennaPortConfig antenna)
        {
            return Result.OK;
        }

        /// <summary>
        /// Allows an application to configure several parameters for a single 
        /// logical antenna port e.g.,  dwell time, power level, and number 
        /// of inventory cycles.  Even if the logical antenna port is disabled, 
        /// an application is allowed to set these configuration parameters.  
        /// Setting configuration parameters does not cause a logical antenna 
        /// port to be automatically enabled; the application must still enable 
        /// the logical antenna port via RFID_AntennaPortSetState.  The 
        /// antenna-port configuration cannot be set while a radio module is 
        /// executing a tag-protocol operation. 
        /// NOTE:  Since RFID_AntennaPortSetConfiguration sets all of the 
        /// configuration parameters that are present in the 
        /// RFID_ANTENNA_PORT_CONFIG structure, if an application wishes to 
        /// leave some parameters unchanged, the application should first call 
        /// RFID_AntennaPortGetConfiguration to retrieve the current 
        /// settings, update the values in the structure that are to be 
        /// changed, and then call RFID_AntennaPortSetConfiguration. 
        /// </summary>
        /// <param name="antenna">A structure that contains the 
        /// antenna-port configuration parameters.  This 
        /// parameter must not be NULL.  In version 1.1, 
        /// the physicalRxPort and physicalTxPort 
        /// fields must be the same. </param>
        /// <returns></returns>
        public Result SetAntennaPortConfiguration(AntennaPortConfig antenna)
        {
            if (antenna == null)
                return Result.INVALID_PARAMETER;

            return (m_Result = AntennaPortSetConfiguration(0, antenna));
        }

        /// <summary>
        /// Allows an application to configure several parameters for a single 
        /// logical antenna port e.g.,  dwell time, power level, and number 
        /// of inventory cycles.  Even if the logical antenna port is disabled, 
        /// an application is allowed to set these configuration parameters.  
        /// Setting configuration parameters does not cause a logical antenna 
        /// port to be automatically enabled; the application must still enable 
        /// the logical antenna port via RFID_AntennaPortSetState.  The 
        /// antenna-port configuration cannot be set while a radio module is 
        /// executing a tag-protocol operation. 
        /// NOTE:  Since RFID_AntennaPortSetConfiguration sets all of the 
        /// configuration parameters that are present in the 
        /// RFID_ANTENNA_PORT_CONFIG structure, if an application wishes to 
        /// leave some parameters unchanged, the application should first call 
        /// RFID_AntennaPortGetConfiguration to retrieve the current 
        /// settings, update the values in the structure that are to be 
        /// changed, and then call RFID_AntennaPortSetConfiguration. 
        /// </summary>
        /// <param name="port">antenna-port</param>
        /// <param name="antenna">A structure that contains the 
        /// antenna-port configuration parameters.  This 
        /// parameter must not be NULL.  In version 1.1, 
        /// the physicalRxPort and physicalTxPort 
        /// fields must be the same. </param>
        /// <returns></returns>
        public Result SetAntennaPortConfiguration(uint port, AntennaPortConfig antenna)
        {
            if (antenna == null)
                return Result.INVALID_PARAMETER;

            if (antenna.powerLevel > GetSoftwareMaxPowerLevel(m_save_region_code))
                return (m_Result = Result.INVALID_PARAMETER);

            m_AntennaList[(int)port].AntennaConfig = antenna;

            return (m_Result = AntennaPortSetConfiguration(port, antenna));
        }

        private Result SetAntennaPortConfiguration(uint virtual_port, uint physical_port)
        {
            AntennaPortConfig antenna = new AntennaPortConfig();

            if ((m_Result = AntennaPortGetConfiguration(virtual_port, antenna)) != Result.OK)
                return m_Result;

            return (m_Result = AntennaPortSetConfiguration(virtual_port, antenna));
        }

        Result AntennaPortSetConfiguration(uint port, AntennaPortConfig antenna)
        {
            SetPowerLevel((UInt16)(antenna.powerLevel * 10), (byte)port);
            SetInventoryDuration  ((UInt16)antenna.dwellTime, (byte)port);


            //RFIDRegister.AntennaPortConfig.SetPower((UInt16)(antenna.powerLevel * 10), (byte)port);
            //RFIDRegister.AntennaPortConfig.SetDwell((UInt16)antenna.dwellTime, (byte)port);

            //MacWriteRegister(MACREGISTER.HST_ANT_DESC_INV_CNT, antenna.numberInventoryCycles);





#if forreference

            UInt32 registerValue = 0;

            // First, tell the MAC which antenna descriptors we'll be reading and
            // verify that it was a valid selector
            MacWriteRegister( MACREGISTER.HST_ANT_DESC_SEL, port);

            /*
            MacReadRegister(MACREGISTER.MAC_ERROR, ref registerValue);

            if (registerValue == HOSTIF_ERR_SELECTORBNDS)
            {
                MacClearError();
                return Result.INVALID_PARAMETER;
            }
            */

            // Write the antenna dwell, RF power, inventory cycle count, and sense
            // resistor threshold registers
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_DWELL, antenna.dwellTime);

            MacWriteRegister(MACREGISTER.HST_ANT_DESC_RFPOWER, antenna.powerLevel);

            MacWriteRegister(MACREGISTER.HST_ANT_DESC_INV_CNT, antenna.numberInventoryCycles);
#endif

            return Result.OK;
        }

        public uint GetAntennaPort()
        {
            if (m_AntennaList == null)
                return 1;

            return (uint)m_AntennaList.Count;
		}

    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.Country.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;

namespace CSLibrary
{
    using static FrequencyBand;
    using static FrequencyBand_CS710S;

    public partial class RFIDReader
    {
        /// <summary>
        /// is reader can change country frequency
        /// </summary>
        /// <returns></returns>
        public bool IsCountryChangeable()
        {
            return (m_oem_freq_modification_flag != 0xaa);
        }

        /// <summary>
        /// Get Active Country Name List 
        /// </summary>
        /// <returns></returns>
        public string[] GetActiveCountryNameList()
        {
            switch (_deviceType)
            {
                case RFIDDEVICE.MODEL.CS108:
                    return GetActiveRegionNameList_CS108();

                case RFIDDEVICE.MODEL.CS710S:
                    return GetActiveRegionNameList_CS710S();
            }

            return null;
        }

        /// <summary>
        /// Get Current Country Name
        /// </summary>
        /// <returns></returns>
        public string GetCurrentCountry()
        {
            return m_save_countryname;
            // return FrequencyBand.frequencySet[m_oem_country_code].name;
        }

        /// <summary>
        /// Get CurrentCountry Index (A.3.4 CSL Ex10 Country Enum Table)
        /// </summary>
        /// <returns></returns>
        public int GetCurrentCountryIndex()
        {
            return (int)m_save_countryindex;
        }

        /// <summary>
        /// Get current selected frequency channel 
        /// </summary>
        /// <returns>channel number, first channel = 0 and hopping = -1</returns>
        public int GetCurrentFrequencyChannel()
        {
            return m_save_freq_channel;
        }

        /// <summary>
        // Get Available frequency table with country code
        /// </summary>
        /// <param name="CountryName"></param>
        /// <returns>Country index, if not found = -1</returns>
        public int GetCountryIndex(string CountryName)
        {
            var item = FrequencyBand_CS710S.frequencySet.Find(i => i.name.Equals(CountryName));

            if (item == null)
                return -1;

            return (item.index);
        }

        /// <summary>
        /// Get Current Country Available Frequency Table
        /// </summary>
        /// <returns></returns>
        public double[] GetAvailableFrequencyTable()
        {
            if (_deviceType == RFIDDEVICE.MODEL.CS108)
                if (m_save_region_code != RegionCode.UNKNOWN)
                    return GetAvailableFrequencyTable_CS108(m_save_region_code);

            return GetAvailableFrequencyTable(m_save_countryindex);
        }

        /// <summary>
        /// Get Available frequency table with country code
        /// </summary>
        /// <returns></returns>
        public double[] GetAvailableFrequencyTable(string CountryName)
        {
            if (_deviceType == RFIDDEVICE.MODEL.CS108)
            {
                var region = CSLibrary.FrequencyBand.GetRegionCode(CountryName);

                if (region != RegionCode.UNKNOWN)
                    return GetAvailableFrequencyTable_CS108(region);
            }

            int CountryIndex = GetCountryIndex(CountryName);

            if (CountryIndex == -1)
                return null;

            return GetAvailableFrequencyTable_CS710S(CountryIndex);
        }

        /// <summary>
        /// Get frequency table with country index
        /// </summary>
        /// <param name="CountryIndex"></param>
        /// <returns></returns>
        public double[] GetAvailableFrequencyTable(int CountryIndex)
        {
            return GetAvailableFrequencyTable_CS710S(CountryIndex);
        }

        /// <summary>
        /// Is Current Country Hopping Channel
        /// </summary>
        /// <returns></returns>
        public bool IsHoppingChannel()
        {
            if (m_save_region_code != RegionCode.UNKNOWN)
                return HoppingAvalibable(m_save_region_code);

            return IsHoppingChannel((int)m_save_countryindex);
        }

        public bool IsHoppingChannel(string CountryName)
        {
            if (_deviceType == RFIDDEVICE.MODEL.CS108)
            {
                var region = CSLibrary.FrequencyBand.GetRegionCode(CountryName);

                if (region != RegionCode.UNKNOWN)
                    return HoppingAvalibable(region);
            }

            int CountryIndex = GetCountryIndex(CountryName);

            if (CountryIndex == -1)
                return false;

            return IsHoppingChannel(CountryIndex);
        }

        public bool IsHoppingChannel(int CountryIndex)
        {
            return IsHopping_CS710S(CountryIndex);
        }

        /// <summary>
        /// Is Current Country Fixed Channel
        /// </summary>
        /// <returns></returns>
        public bool IsFixedChannel()
        {
            if (m_save_region_code != RegionCode.UNKNOWN)
                return !HoppingAvalibable(m_save_region_code);

            return IsFixedChannel((int)m_save_countryindex);
        }

        public bool IsFixedChannel(string CountryName)
        {
            if (_deviceType == RFIDDEVICE.MODEL.CS108)
            {
                var region = CSLibrary.FrequencyBand.GetRegionCode(CountryName);

                if (region != RegionCode.UNKNOWN)
                    return !HoppingAvalibable(region);
            }

            int CountryIndex = GetCountryIndex(CountryName);

            if (CountryIndex == -1)
                return false;

            return IsFixedChannel(CountryIndex);
        }

        public bool IsFixedChannel(int CountryIndex)
        {
            return IsFixed_CS710S(CountryIndex);
        }

        /// <summary>
        /// Select Country Frequency with channel if fixed
        /// </summary>
        /// <param name="CountryIndex"></param>
        /// <param name="Channel"></param>
        /// <returns></returns>
        public Result SetCountry(string CountryName, int Channel = 0)                                        // Select Country Frequency with channel if fixed
        {
            if (_deviceType == RFIDDEVICE.MODEL.CS108)
            {
                var region = CSLibrary.FrequencyBand.GetRegionCode(CountryName);

                if (region != RegionCode.UNKNOWN)
                {
                    if (IsHopping_CS108(region))
                        return SetHoppingChannels(region);
                    else
                        return SetFixedChannel(region, (uint)Channel);
                }
            }



            int CountryIndex = GetCountryIndex(CountryName);

            if (CountryIndex == -1)
                return Result.FAILURE;

            return SetCountry(CountryIndex, Channel);
        }

        /// <summary>
        /// Select Country Frequency with channel if fixed
        /// </summary>
        /// <param name="CountryIndex"></param>
        /// <param name="Channel"></param>
        /// <returns></returns>
        public Result SetCountry(int CountryIndex, int Channel = 0)
        {
            m_save_countryindex = CountryIndex;
            m_save_freq_channel = Channel;

            switch (_deviceType)
            {
                case RFIDDEVICE.MODEL.CS108:
                    return SetCountry_CS108(CountryIndex, Channel);

                case RFIDDEVICE.MODEL.CS710S:
                    return SetCountry_CS710S(CountryIndex, Channel);
            }

            return Result.FAILURE;
        }





        /*
                // Get Active Country Name List
                public string[] GetActiveCountryNameList()
                {
                    switch (_deviceType)
                    {
                        case RFIDDEVICE.MODEL.CS108:
                            return GetActiveRegionNameList_CS108();

                        case RFIDDEVICE.MODEL.CS710S:
                            return GetActiveRegionNameList_CS710S();
                    }

                    return null;
                }

                public bool IsHoppingChannel()
                {
                    return IsHoppingChannel(m_save_countryname);
                }
                public bool IsFixedChannel()
                {
                    return IsFixedChannel(m_save_countryname);
                }

                public bool IsHoppingChannel(string CountryName)
                {
                    switch (_deviceType)
                    {
                        case RFIDDEVICE.MODEL.CS108:
                            return IsHopping_CS108(CountryName);

                        case RFIDDEVICE.MODEL.CS710S:
                            return IsHopping_CS710S(CountryName);
                    }

                    return false;
                }

                public bool IsFixedChannel(string CountryName)
                {
                    switch (_deviceType)
                    {
                        case RFIDDEVICE.MODEL.CS108:
                            return IsFixed_CS108(CountryName);

                        case RFIDDEVICE.MODEL.CS710S:
                            return IsFixed_CS710S(CountryName);
                    }

                    return false;
                }

                public Result SetCountry(string CountryName, int Channel = 1)                                        // Select Country Frequency with channel if fixed
                {
                    switch (_deviceType)
                    {
                        case RFIDDEVICE.MODEL.CS108:
                            return SetRegion_CS108(CountryName, Channel);

                        case RFIDDEVICE.MODEL.CS710S:
                            return SetRegion_CS710S(CountryName, Channel);
                    }

                    return Result.FAILURE;
                }

                public double[] GetAvailableFrequencyTable()
                {
                    return GetAvailableFrequencyTable(m_save_countryname);
                }

                public double[] GetAvailableFrequencyTable(string CountryName)									// Get Available frequency table with country code
                {
                    switch (_deviceType)
                    {
                        case RFIDDEVICE.MODEL.CS108:
                            return GetAvailableFrequencyTable_CS108(CountryName);

                        case RFIDDEVICE.MODEL.CS710S:
                            return GetAvailableFrequencyTable_CS710S(CountryName);
                    }

                    return null;
                }

                /// <summary>
                /// Get frequency table with country index
                /// </summary>
                /// <param name="CountryIndex"></param>
                /// <returns></returns>
                public double[] GetAvailableFrequencyTable(int CountryIndex)
                {
                    return GetAvailableFrequencyTable_CS710S(CountryIndex);
                }

                public List<double> GetCurrentFrequencyTable()														// Get frequency table on current selected region
                {
                    switch (_deviceType)
                    {
                        case RFIDDEVICE.MODEL.CS108:
                            return GetCurrentFrequencyTable_CS108();

                        case RFIDDEVICE.MODEL.CS710S:
                            return GetCurrentFrequencyTable_CS710S();
                    }

                    return null;
                }
                public string GetCurrentCountry()
                {
                    switch (_deviceType)
                    {
                        case RFIDDEVICE.MODEL.CS108:
                            return GetCurrentCountry_CS108();

                        case RFIDDEVICE.MODEL.CS710S:
                            return GetCurrentCountry_CS710S();
                    }

                    return null;
                }

                public int GetCurrentCountryIndex()
                {
                    switch (_deviceType)
                    {
                        //case RFIDDEVICE.MODEL.CS108:
                        //    return GetCurrentCountryIndex_CS108();

                        case RFIDDEVICE.MODEL.CS710S:
                            return GetCurrentCountryIndex_CS710S();
                    }

                    return -1;
                }

                public int GetCurrentFrequencyChannel()
                {
                    switch (_deviceType)
                    {
                        //case RFIDDEVICE.MODEL.CS108:
                        //    return GetCurrentFrequencyChannel_CS108();

                        case RFIDDEVICE.MODEL.CS710S:
                            return GetCurrentFrequencyChannel_CS710S();
                    }

                    return -1;
                }

                /// <summary>
                /// Select Country Frequency with channel if fixed
                /// </summary>
                /// <param name="CountryIndex"></param>
                /// <param name="Channel"></param>
                /// <returns></returns>
                public Result SetCountry(int CountryIndex, int Channel = 1)                                        
                {
                    switch (_deviceType)
                    {
                        case RFIDDEVICE.MODEL.CS108:
                            return SetCountry_CS108(CountryIndex, Channel);

                        case RFIDDEVICE.MODEL.CS710S:
                            return SetCountry_CS710S(CountryIndex, Channel);
                    }

                    return Result.FAILURE;
                }




        */



    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.FrequencyChannel.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;
using CSLibrary.Structures;

namespace CSLibrary
{
    using static FrequencyBand;

    public partial class RFIDReader
    {
        private string m_save_countryname = "";                     // current selected country by name
        private int m_save_countryindex = -1;                       // current selected country by index
        private RegionCode m_save_region_code = RegionCode.UNKNOWN; // current selected country by RegionCode (just for old frequency set)
        private int m_save_freq_channel = -2;                       // current selected channel, start from 0 and -1 = hopping
        private int[] m_save_hoppingorder = null;                   // current hopping channel order (only for selected hopping channel)

        public Result SetDefaultChannel()
        {
            switch (_deviceType)
            {
                case RFIDDEVICE.MODEL.CS108:
                    return SetDefaultChannel_CS108();       // Set Default setting from hard code table

                case RFIDDEVICE.MODEL.CS710S:
                    return SetDefaultChannel_CS710S();      // Get Default setting from reader
            }

            return Result.FAILURE;
        }

    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.InventoryOptions.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    using static RFIDDEVICE;
    using static FrequencyBand;
    using Constants;

    public partial class RFIDReader
    {
        /*
        /// <summary>
        /// Special function for set multi bank inventory without reply
        /// </summary>
        public Result SetMultiBankInventoryNoReply(int index)
        {
            switch (_deviceType)
            {
                case MODEL.CS710S:
                    if (index < 0 || index > 2)
                        return Result.NOT_SUPPORTED;

                    RFIDRegister.MultibankReadConfig.SetNoReply((byte)index);
                    return Result.OK;
            }

            return Result.NOT_SUPPORTED;
        }
        */
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.Operation.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;
using CSLibrary.Structures;

namespace CSLibrary
{
    using static RFIDDEVICE;

    public partial class RFIDReader
    {
        private Operation CurrentOperation;

        public Result StartOperation(Operation opertion)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return StartOperation_CS108(opertion);

                case MODEL.CS710S:
                    return StartOperation_CS710S(opertion);
            }

            return Result.FAILURE;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.Power.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    using static RFIDDEVICE;
    using static FrequencyBand;
    using Constants;

    public partial class RFIDReader
    {
        //private uint m_oem_hipower = 0;

        /// <summary>
        /// Available Maximum Power you can set on specific region
        /// </summary>
        public uint GetActiveMaxPowerLevel()
        {
           return 320;
/*
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return GetActiveMaxPowerLevel_CS108();
                    break;

                case MODEL.CS710S:
                    return GetActiveMaxPowerLevel_CS710S();
                    break;
            }

            return 0;
*/
        }

        /// <summary>
        /// Get current power level
        /// </summary>
        public uint SelectedPowerLevel
        {
            get
            {
                uint pwrlvl = 0;
                switch (_deviceType)
                {
                    case MODEL.CS108:
                        GetPowerLevel_CS108(ref pwrlvl);
                        break;

                    case MODEL.CS710S:
                        GetPowerLevel_CS710S(ref pwrlvl);
                        break;
                }
                return pwrlvl;
            }
        }

        /// <summary>
        /// Get Power Level
        /// </summary>
        public Result GetPowerLevel(ref uint pwrlvl)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return GetPowerLevel_CS108(ref pwrlvl);

                case MODEL.CS710S:
                    return GetPowerLevel_CS710S(ref pwrlvl);
            }

            return Result.FAILURE;
        }

        public Result SetPowerLevel(uint pwrlevel, uint port = 0)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetPowerLevel_CS108(pwrlevel, port = 0);

                case MODEL.CS710S:
                    return SetPowerLevel_CS710S(pwrlevel, port = 0);
            }

            return Result.FAILURE;
        }

        public Result SetPowerLevel(int pwrlevel, uint port = 0)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetPowerLevel_CS108((uint)pwrlevel, port);

                case MODEL.CS710S:
                    return SetPowerLevel_CS710S((uint)pwrlevel, port);
            }

            return Result.FAILURE;
        }

        public Result SetPowerLevel(UInt32 [] pwrlevel)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetPowerLevel_CS108(pwrlevel);

                case MODEL.CS710S:
                    return SetPowerLevel_CS710S(pwrlevel);
            }

            return Result.FAILURE;
        }

        /// <summary>
        /// Available Maximum Power you can set on specific region
        /// </summary>
        private uint GetSoftwareMaxPowerLevel(RegionCode region)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return GetSoftwareMaxPowerLevel_CS108(region);

                case MODEL.CS710S:
                    return GetSoftwareMaxPowerLevel_CS710S(region);
            }

            return 0;
        }

        /// <summary>
        /// Set Power Sequencing (only for CS108)
        /// </summary>
        /// <param name="numberofPower"></param>
        /// <param name="power"></param>
        /// <param name="dwell"></param>
        /// <returns></returns>
        public Result SetPowerSequencing(int numberofPower, uint[] power = null, uint[] dwell = null, bool CloneAntenna0Setting = true)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetPowerSequencing_CS108(numberofPower, power, dwell);

                case MODEL.CS710S:
                    return SetPowerSequencing_CS710S(numberofPower, power, dwell, CloneAntenna0Setting);
            }

            return Result.FAILURE;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.Profile.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;

namespace CSLibrary
{
    using static RFIDDEVICE;
    using static FrequencyBand;

    public partial class RFIDReader
    {
        public uint[] GetActiveLinkProfile()
        {
            return GetActiveLinkProfile(m_save_region_code);
        }

        public string[] GetActiveLinkProfileName()
        {
            return GetActiveLinkProfileName(m_save_region_code);
        }

        public uint[] GetActiveLinkProfile(RegionCode region)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return GetActiveLinkProfile_CS108(region);

                case MODEL.CS710S:
                    return GetActiveLinkProfile_CS710S(region);
            }

            return null;
        }

        public string[] GetActiveLinkProfileName(RegionCode region)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return GetActiveLinkProfileName_CS108(region);

                case MODEL.CS710S:
                    return GetActiveLinkProfileName_CS710S(region);
            }

            return null;
        }

        /// <summary>
        /// Current selected frequency
        /// </summary>
        public uint SelectedLinkProfile
        {
            get
            {
                uint link = 0;
                GetCurrentLinkProfile(ref link);
                return link;
            }
        }

        /// <summary>
        /// Allows the application to set the current link profile for the radio 
        /// module.  A link profile will remain in effect until changed by a 
        /// subsequent call to RFID_RadioSetCurrentLinkProfile.  The 
        /// current link profile cannot be set while a radio module is executing 
        /// a tag-protocol operation. 
        /// </summary>
        /// <param name="profile">
        /// The link profile to make the current link profile.  If this 
        /// parameter does not represent a valid link profile, 
        /// RFID_ERROR_INVALID_PARAMETER is returned. </param>
        /// <returns></returns>
        public Result SetCurrentLinkProfile(uint profile)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetCurrentLinkProfile_CS108(profile);

                case MODEL.CS710S:
                    return SetCurrentLinkProfile_CS710S(profile);
            }

            return Result.FAILURE;
        }

        /// <summary>
        ///  Allows the application to retrieve the current link profile for the 
        ///  radio module.  The current link profile cannot be retrieved while a 
        ///  radio module is executing a tag-protocol operation. 
        /// </summary>
        /// <returns></returns>
        public Result GetCurrentLinkProfile(ref uint link)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return GetCurrentLinkProfile_CS108(ref link);

                case MODEL.CS710S:
                    return GetCurrentLinkProfile_CS710S(ref link);
            }

            return Result.FAILURE;
        }

    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.QTCommandParms.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace CSLibrary.Structures
{
	public class QTCommandParms
	{
		public uint accessPassword;
		public int MEM;
		public int RW;
		public int SR;
		public int TP;

//		public QTCommandParms();
	}
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.RSSIFilter.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    using static RFIDDEVICE;
    using Constants;

    namespace Constants
    {
        public enum RSSIFILTERTYPE
        {
            DISABLE,
            RSSI,
            //NB_RSSI    // for CS108 only
        }

        public enum RSSIFILTEROPTION
		{
            DISABLE,
            LESSOREQUAL,
			GREATEROREQUAL,
        }
    }

    public partial class RFIDReader
    {
        /// <summary>
        /// Set RSSI Filter Enable / Disable
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public Result SetRSSIFilter(RSSIFILTERTYPE type)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetRSSIFilter_CS108(type);

                case MODEL.CS710S:
                    return SetRSSIFilter_CS710S(type);
            }

            return Result.FAILURE;
        }

        /// <summary>
        /// Set RSSI dBuV Filter
        /// </summary>
        /// <param name="type"></param>
        /// <param name="option"></param>
        /// <param name="threshold"></param>
        /// <returns></returns>
        public Result SetRSSIFilter(RSSIFILTERTYPE type, RSSIFILTEROPTION option, double threshold)
        {
            switch(_deviceType)
            {
                case MODEL.CS108:
                    return SetRSSIFilter_CS108(type, option, threshold);

                case MODEL.CS710S:
                    return SetRSSIFilter_CS710S(type, option, Tools.dBConverion.dBuV2dBm(threshold));
            }

            return Result.FAILURE;
        }

        /// <summary>
        /// RSSI dBm Filter
        /// </summary>
        /// <param name="type"></param>
        /// <param name="option"></param>
        /// <param name="threshold"></param>
        /// <returns></returns>
        public Result SetRSSIdBmFilter(RSSIFILTERTYPE type, RSSIFILTEROPTION option, double threshold)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetRSSIFilter_CS108(type, option, Tools.dBConverion.dBm2dBuV(threshold));

                case MODEL.CS710S:
                    return SetRSSIFilter_CS710S(type, option, threshold);
            }

            return Result.FAILURE;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Public.SetLNA.cs">
using System;
using System.Collections.Generic;
using System.Text;

using CSLibrary.Constants;

namespace CSLibrary
{
    using static RFIDDEVICE;

    public partial class RFIDReader
    {
        /// <summary>
        /// RF LNA compression mode = 0, 1
        /// RF LNA Gain = 1, 7, 13
        /// IF LNA Gain = 6, 12, 18, 24
        /// AGC Gain = -12, -6, 0, 6
        /// </summary>
        /// <param name="rflna_high_comp_norm"></param>
        /// <param name="rflna_gain_norm"></param>
        /// <param name="iflna_gain_norm"></param>
        /// <param name="ifagc_gain_norm"></param>
        /// <param name="ifagc_gain_norm"></param>
        /// <returns></returns>
        public Result SetLNA(int rflna_high_comp, int rflna_gain, int iflna_gain, int ifagc_gain)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    return SetLNA_CS108(rflna_high_comp, rflna_gain, iflna_gain, ifagc_gain);

                //case MODEL.CS710S:
                //    break;
            }

            return Result.FAILURE;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.Puiblic.EngineeringAPI.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;

namespace CSLibrary
{
	public partial class RFIDReader
	{

		public Result TurnCarrierWaveOn(bool isDataMode)
		{
			if (isDataMode)
				return Result.NOT_SUPPORTED;

			//return COMM_HostCommand(HST_CMD.CWON);
			//_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.CWON), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE);

			return Result.OK;
		}

		public Result TurnCarrierWaveOff()
		{
			//return COMM_HostCommand(HST_CMD.CWOFF);
			//_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.CWOFF), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE);

			return Result.OK;
		}

	}
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.UCODE8.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace CSLibrary_CS710S
{
	public partial class RFIDReader
	{
		public bool SetBrandID(bool enable)
		{
			return false;
		}
	}
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/ClassRFID.UnifiedAPI.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Text;

namespace CSLibrary
{
    using static RFIDDEVICE;
    using Constants;

    public partial class RFIDReader
    {
        public void StopOperation(bool value = true)
        {
            switch (_deviceType)
            {
                case MODEL.CS108:
                    StopOperation_CS108();
                    break;

                case MODEL.CS710S:
                    StopOperation_CS710S();
                    break;
            }
        }

        public bool SetDuplicateEliminationRollingWindow(uint s)
        {
            switch (_deviceType)
            {
                case MODEL.CS710S:
                    return SetDuplicateEliminationRollingWindow_CS710S(s);
                    break;
            }

            return false;
        }

    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    using static RFIDDEVICE;
    using Constants;
    using Structures;
    using Events;
    using Tools;

    public partial class RFIDReader
    {
        public UInt32 LastMacErrorCode = 0;
        public UInt16 LastResultCode = 0;

        private CSLibrary.Tools.Queue _dataBuffer = new Tools.Queue(16 * 1024 * 1024);

        public ChipSetID OEMChipSetID
        {
            get
            {
                return ChipSetID.R2000;

                switch (m_oem_machine)
                {
                    case MODEL.CS103:
                    case MODEL.CS108:
                    case MODEL.CS209:
                    case MODEL.CS333:
                    case MODEL.CS463:
                        return ChipSetID.R2000;
                }

                return ChipSetID.R1000;
            }
        }

        int TwoByteArraryToInt(byte[] data, int startIndex)
        {
            int a = data[startIndex];
            a |= (data[startIndex + 1] << 8);

            return (a);
        }

        int FourByteArraryToInt(byte[] data, int startIndex)
        {
            int a = data[startIndex];
            a |= (data[startIndex + 1] << 8);
            a |= (data[startIndex + 2] << 16);
            a |= (data[startIndex + 3] << 24);

            return (a);
        }

        Single R2000_RssiTranslation(byte rawValue)
        {
            int iMantissa = rawValue & 0x07;
            int iExponent = (rawValue >> 3) & 0x1F;

            double dRSSI = 20.0 * Math.Log10(Math.Pow(2.0, (double)iExponent) * (1.0 + ((double)iMantissa / 8.0)));

            CSLibrary.Debug.WriteLine("Routine : R2000_RssiTranslation, 0x" + rawValue.ToString("x2") + "=" + dRSSI.ToString());

            return (Single) dRSSI;
        }

        bool R2000Packet_NewInventory(byte[] recvData, int offset = 0)
        {
            CSLibrary.Debug.WriteLine("Routine : R2000Packet_NewInventory");

            if (OnAsyncCallback != null)
            {
                uint newInventoryPacketOffset = 8;
                Byte AntennaPort = recvData[6];

                while (newInventoryPacketOffset < (recvData.Length - 1))
                {
                    CSLibrary.Structures.TagCallbackInfo info = new CSLibrary.Structures.TagCallbackInfo();

                    info.antennaPort = AntennaPort;

                    info.pc = (UInt16)(recvData[newInventoryPacketOffset] << 8 | recvData[newInventoryPacketOffset + 1]);
                    int epcbytelen = ((info.pc & 0xf800) >> 11) * 2;

                    if (epcbytelen == 0)
                        return false;

                    if ((newInventoryPacketOffset + epcbytelen + 1) >= recvData.Length)
                        return false;

                    info.rssi = R2000_RssiTranslation(recvData[newInventoryPacketOffset + epcbytelen + 2]);
                    info.rssidBm = Tools.dBConverion.dBuV2dBm(info.rssi);

                    int xpcoffset = 0;

                    if (info.pc.XI) // Check XPC W1
                    {
                        info.xpc_w1 = new S_XPC_W1((UInt16)(recvData[newInventoryPacketOffset + 2] << 8 | recvData[newInventoryPacketOffset + 3]));
                        xpcoffset+=2;
                        epcbytelen -= 2;

                        if (info.xpc_w1.XEB) // Check XPC W2
                        {
                            info.xpc_w2 = new S_XPC_W2((UInt16)(recvData[newInventoryPacketOffset + 4] << 8 | recvData[newInventoryPacketOffset + 5]));
                            xpcoffset+=2;
                            epcbytelen -= 2;
                        }
                    }

                    byte[] byteEpc = new byte[epcbytelen];
                    Array.Copy(recvData, (int)(newInventoryPacketOffset + 2 + xpcoffset), byteEpc, 0, epcbytelen);

/*
                    if (Options.TagRanging.fastid && info.pc.EPCLength >= 6 && byteEpc[byteEpc.Length - 12] == 0xe2 && byteEpc[byteEpc.Length - 11] == 0x80 && byteEpc[byteEpc.Length - 10] == 0x11)
                    {
                        byte[] newbyteEpc = new byte[byteEpc.Length - 12];
                        UInt16[] newbyteTid = new UInt16[6];

                        Array.Copy(byteEpc, 0, newbyteEpc, 0, newbyteEpc.Length);
                        ArrayCopy (byteEpc, byteEpc.Length - 12, newbyteTid, 0, 12);

                        info.FastTid = newbyteTid;
                        byteEpc = newbyteEpc;
                    }
*/

                    info.epc = new S_EPC(byteEpc);

                    newInventoryPacketOffset += (uint)(2 + xpcoffset + epcbytelen + 1);

                    switch (CurrentOperation)
                    {
                        case Operation.TAG_RANGING:
                            {
                                CSLibrary.Constants.CallbackType type = CSLibrary.Constants.CallbackType.TAG_RANGING;
                                CSLibrary.Events.OnAsyncCallbackEventArgs callBackData = new Events.OnAsyncCallbackEventArgs(info, type);
                                if (OnAsyncCallback != null)
                                    OnAsyncCallback(_deviceHandler, callBackData);
                            }
                            break;
                    }
                }
            }

            return true;
        }

        bool R2000Packet_Inventory (byte [] recvData, int offset = 0)
        {
            try
            {
            if (OnAsyncCallback != null)
            {
                CSLibrary.Structures.TagCallbackInfo info = new CSLibrary.Structures.TagCallbackInfo();

                var flags = recvData[offset + 1];
                var pkt_len = (recvData[offset + 4] | (recvData[offset + 5] << 8));
                var ms_ctr = (recvData[offset + 8] | recvData[offset + 9] << 8 | recvData[offset + 10] << 16 | recvData[offset + 11] << 24);
                var wb_rssi = recvData[offset + 12];
                var nb_rssi = recvData[offset + 13];
                var phase = recvData[offset + 14];
                var chidx = recvData[offset + 15];
                var data1count = recvData[offset + 16];
                var data2count = recvData[offset + 17];
                var antennaPort = (recvData[offset + 18] | recvData[offset + 19] << 8);
                var pc = (recvData[offset + 20] << 8 | recvData[offset + 21]);
                var totaldatalen = ((((pkt_len - 3) * 4) - ((flags >> 6) & 3)));
                var crc16 = (recvData[offset + 18 + totaldatalen] << 8 | recvData[offset + 19 + totaldatalen]);

                info.ms_ctr = (UInt32)ms_ctr;
                switch (OEMChipSetID)
                {
                    default:
                        info.rssi = (Single)(nb_rssi * 0.8);
                        break;

                    case ChipSetID.R2000:
                        info.rssi = R2000_RssiTranslation(nb_rssi);
                        break;
                }
                info.rssidBm = Tools.dBConverion.dBuV2dBm(info.rssi);

                if (currentInventoryFreqRevIndex != null)
                {
                    info.freqChannel = (chidx < currentInventoryFreqRevIndex.Length) ? currentInventoryFreqRevIndex[chidx] : (uint)0xff;
                }

                info.antennaPort = (UInt16)antennaPort;
                info.pc = new S_PC((UInt16)pc);
                info.crc16 = (UInt16)crc16;

                {
                    info.phase = (Int16)(phase & 0x3f);
                    if ((phase & 0x40) != 0x00)
                    {
                        UInt16 pvalue = (UInt16)info.phase;
                        pvalue |= 0xffc0;
                        info.phase = (Int16)pvalue;
                    }
                }

                if (data2count > 0)
                {
                    UInt16[] data = new UInt16[data2count];
                    int data2offset = (int)(offset + 20 + totaldatalen - 2 - (data2count * 2));

                    ArrayCopy(recvData, data2offset, data, 0, data2count * 2);
                    info.Bank2Data = data;

                    CSLibrary.Debug.WriteLine("data 2:" + Tools.Hex.ToString(data));
                }

                if (data1count > 0)
                {
                    UInt16[] data = new UInt16[data1count];
                    int data1offset = (int)(offset + 20 + totaldatalen - 2 - ((data2count + data1count) * 2));

                    ArrayCopy(recvData, data1offset, data, 0, data1count * 2);
                    info.Bank1Data = data;

                    CSLibrary.Debug.WriteLine("data 1:" + Tools.Hex.ToString(data));
                }

                int xpcoffset = 0;

                if (info.pc.XI) // Check XPC W1
                {
                    info.xpc_w1 = new S_XPC_W1((UInt16)(recvData[offset + 8 + 12] << 8 | recvData[offset + 8 + 13]));
                    xpcoffset += 2;

                    if (info.xpc_w1.XEB) // Check XPC W2
                    {
                        info.xpc_w2 = new S_XPC_W2((UInt16)(recvData[offset + 8 + 14] << 8 | recvData[offset + 8 + 15]));
                        xpcoffset += 2;
                    }
                }

                
                /*                if (CurrentOperation == Operation.TAG_RANGING)
                {
                    if (_tagRangingParms.multibanks == 2)
                    {
                        UInt16[] data = new UInt16[_tagRangingParms.count2];
                        int data2length = (int)(_tagRangingParms.count2 * 2);
                        int data2offset = (int)(offset + 8 + 14 + info.epcstrlen - data2length);

                        ArrayCopy(recvData, data2offset, data, 0, data2length);
                        info.Bank2Data = data;

                        CSLibrary.Debug.WriteLine("data 1:" + Tools.Hex.ToString(data));

                        info.epcstrlen -= (uint)data2length;
                    }

                    if (_tagRangingParms.multibanks > 0)
                    {
                        UInt16[] data = new UInt16[_tagRangingParms.count1];
                        int data1length = (int)(_tagRangingParms.count1 * 2);
                        int data1offset = (int)(offset + 8 + 14 + info.epcstrlen - data1length);

                        ArrayCopy(recvData, data1offset, data, 0, data1length);
                        info.Bank1Data = data;

                        CSLibrary.Debug.WriteLine("data 2:" + Tools.Hex.ToString(data));

                        info.epcstrlen -= (uint)data1length;
                    }
                }
*/

                byte[] byteEpc = new byte[info.pc.EPCLength * 2];
                Array.Copy(recvData, (int)(offset + 22 + xpcoffset), byteEpc, 0, (int)info.pc.EPCLength * 2);

/*
                if (Options.TagRanging.fastid && info.pc.EPCLength >= 6 && byteEpc[byteEpc.Length - 12] == 0xe2 && byteEpc[byteEpc.Length - 11] == 0x80 && byteEpc[byteEpc.Length - 10] == 0x11)
                {
                    byte[] newbyteEpc = new byte[byteEpc.Length - 12];
                    UInt16[] newbyteTid = new UInt16[6];

                    Array.Copy(byteEpc, 0, newbyteEpc, 0, newbyteEpc.Length);
                    ArrayCopy(byteEpc, byteEpc.Length - 12, newbyteTid, 0, 12);

                    info.FastTid = newbyteTid;
                    byteEpc = newbyteEpc;
                }
*/

                info.epc = new S_EPC(byteEpc);

                switch (CurrentOperation)
                {
                    case Operation.Kiloway_RANGING:
                    case Operation.TAG_RANGING:
                        {
                            CSLibrary.Constants.CallbackType type = CSLibrary.Constants.CallbackType.TAG_RANGING;
                            CSLibrary.Events.OnAsyncCallbackEventArgs callBackData = new Events.OnAsyncCallbackEventArgs(info, type);
                            if (OnAsyncCallback != null)
                                try
                                {
                                    OnAsyncCallback(_deviceHandler, callBackData);
                                }
                                catch (Exception ex)
                                {
                                    CSLibrary.Debug.WriteLine("OnAsyncCallback Error : " + ex.Message);
                                }
                        }
                        break;

                    case Operation.TAG_SEARCHING:
                        {
                            bool match = true;
                            // mach tag selected
                            if (_tagSelectedParms.bank == MemoryBank.EPC && ((_tagSelectedParms.flags & SelectMaskFlags.ENABLE_PC_MASK) == 0) && _tagSelectedParms.epcMaskLength == 96)
                            {
                                byte [] data = _tagSelectedParms.epcMask.ToBytes();

                                if (data.Length != byteEpc.Length)
                                    break;

                                for (int cnt= 0; cnt < data.Length; cnt++)
                                    if (data[cnt] != byteEpc[cnt])
                                    {
                                        match = false;
                                        break;
                                    }
                            }

                            if (match)
                            {
                                CSLibrary.Constants.CallbackType type = CSLibrary.Constants.CallbackType.TAG_SEARCHING;
                                CSLibrary.Events.OnAsyncCallbackEventArgs callBackData = new Events.OnAsyncCallbackEventArgs(info, type);
                                if (OnAsyncCallback != null)
                                    try
                                    {
                                        OnAsyncCallback(_deviceHandler, callBackData);
                                    }
                                    catch (Exception ex)
                                    {
                                        CSLibrary.Debug.WriteLine("OnAsyncCallback Error : " + ex.Message);
                                    }
                            }
                            else
                            {
                                CSLibrary.Debug.WriteLine("Found a non-match Tag");
                            }
                        }
                        break;

                    default:
                        return false;
                }
            }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("R2000Packet_Inventory Error : " + ex.Message);
                return false;
            }
            return true;
        }

        bool R2000Packet_TagAccess (byte[] recvData, int offset = 0)
        {
            if ((recvData[offset + 1] & 0x0f) != 0)
                return false;

			Operation RealCurrentOperation = (Operation)(_deviceHandler._currentCmdRemark);

            int packetType = recvData[offset + 12];

            switch (packetType)
            {
                case 0xc2:  // Read
                    switch (RealCurrentOperation)
                    {
                        case CSLibrary.Constants.Operation.TAG_READ:
                            ArrayCopy(recvData, offset + 20, m_rdr_opt_parms.TagRead.m_pData, 0, m_rdr_opt_parms.TagRead.count * 2);
                            break;

                        case CSLibrary.Constants.Operation.TAG_READ_PC:
                            m_rdr_opt_parms.TagReadPC.m_pc = (ushort)((recvData[offset + 20] << 8) | (recvData[offset + 21]));
                            break;

                        case CSLibrary.Constants.Operation.TAG_READ_EPC:
                            ArrayCopy(recvData, offset + 20, m_rdr_opt_parms.TagReadEPC.m_epc, 0, m_rdr_opt_parms.TagReadEPC.count * 2);
                            break;

                        case CSLibrary.Constants.Operation.TAG_READ_ACC_PWD:
                            m_rdr_opt_parms.TagReadAccPwd.m_password = (UInt32)((recvData[offset + 20] << 24) | (recvData[offset + 21] << 16) | (recvData[offset + 22] << 8) | (recvData[offset + 23]));
                            break;

                        case CSLibrary.Constants.Operation.TAG_READ_KILL_PWD:
							m_rdr_opt_parms.TagReadKillPwd.m_password = (UInt32)((recvData[offset + 20] << 24) | (recvData[offset + 21] << 16) | (recvData[offset + 22] << 8) | (recvData[offset + 23]));
							break;

                        case CSLibrary.Constants.Operation.TAG_READ_TID:
                            ArrayCopy(recvData, offset + 20, m_rdr_opt_parms.TagReadTid.pData, 0, m_rdr_opt_parms.TagReadTid.count * 2);
                            break;

                        case CSLibrary.Constants.Operation.TAG_READ_USER:
                            ArrayCopy(recvData, offset + 20, m_rdr_opt_parms.TagReadUser.m_pData, 0, m_rdr_opt_parms.TagReadUser.count * 2);
                            break;

                        case CSLibrary.Constants.Operation.TAG_AUTHENTICATE:
                            {
                                int pkt_len = recvData[5] << 8 | recvData[4];
                                int flags = recvData[1];
                                int len = ((pkt_len - 3) * 4) - ((flags >> 6) & 3);
                                byte[] response = new byte[len];
                                Array.Copy(recvData, offset + 20, response, 0, len);
                                m_rdr_opt_parms.TagAuthenticate.pData = new S_DATA(response);
                                //Array.Copy(recvData, offset + 20, m_rdr_opt_parms.TagAuthenticate.pData, 0, len);
                            }
                            break;
                    }
                    break;

                case 0xc3:  // Write
					switch (RealCurrentOperation)
					{
                        case CSLibrary.Constants.Operation.TAG_WRITE:
                            //ArrayCopy(recvData, offset + 20, m_rdr_opt_parms.TagReadUser.m_pData, 0, m_rdr_opt_parms.TagReadEPC.count * 2);
                            break;

                        case CSLibrary.Constants.Operation.TAG_WRITE_PC:
							//m_rdr_opt_parms.TagReadPC.m_pc = (ushort)((recvData[offset + 20] << 8) | (recvData[offset + 21]));
							break;

						case CSLibrary.Constants.Operation.TAG_WRITE_EPC:
							//ArrayCopy(recvData, offset + 20, m_rdr_opt_parms.TagReadEPC.m_epc, 0, m_rdr_opt_parms.TagReadEPC.count * 2);
							break;

						case CSLibrary.Constants.Operation.TAG_WRITE_ACC_PWD:
							//m_rdr_opt_parms.TagReadAccPwd.m_password = (UInt32)((recvData[offset + 20] << 24) | (recvData[offset + 21] << 16) | (recvData[offset + 22] << 8) | (recvData[offset + 23]));
							break;

						case CSLibrary.Constants.Operation.TAG_WRITE_KILL_PWD:
							//m_rdr_opt_parms.TagReadKillPwd.m_password = (UInt32)((recvData[offset + 20] << 24) | (recvData[offset + 21] << 16) | (recvData[offset + 22] << 8) | (recvData[offset + 23]));
							break;

						case CSLibrary.Constants.Operation.TAG_WRITE_USER:
							//ArrayCopy(recvData, offset + 20, m_rdr_opt_parms.TagReadUser.m_pData, 0, m_rdr_opt_parms.TagReadEPC.count * 2);
							break;
					}
					break;

				case 0xc4:  // Kill
                    break;

                case 0xc5:  // Lock
							/*
							 *
							 * 
								Win32.memcpy(tagreadbuf, TagAccessPacket, 20, (uint)len);

 * 							 * if (m_Result == Result.OK && !Options.TagBlockLock.setPermalock)
										{
											Options.TagBlockLock.mask = new ushort[Options.TagBlockLock.count];
											Array.Copy(tagreadbuf, Options.TagBlockLock.mask, Options.TagBlockLock.count);
										}
							*/
					break;

                case 0xc7:  // Block Write
                    break;

                case 0x04:  // EAS
                    break;

                case 0xe2: // Untraceable
                    break;

                case 0xd5: // Authenticate
                    break;

                case 0xe0: // FM13DT160 & EM4325
                    {
                        var a = 10;
					}

                    if (_deviceHandler.rfid.FM13DT160.TagAccessProc(RealCurrentOperation, recvData))
                        break;

                    if (_deviceHandler.rfid.EM4325.TagAccessProc(RealCurrentOperation, recvData))            
                        break;

                    return false;

                default:
                    return false;
            }

            return true;
        }

        public void ClearBuffer()
        {
            _dataBuffer.Clear();
        }

        public bool CheckValidRFIDPacket(ref byte [] packetHeader)
        {
            byte pkt_ver = packetHeader[0];
            byte flags = packetHeader[1];
            UInt16 pkt_type = (UInt16)((packetHeader[3] << 8 | packetHeader[2]) & 0x7fff);
            UInt16 pkt_len = (UInt16)(packetHeader[5] << 8 | packetHeader[4]);
            UInt16 reserved = (UInt16)(packetHeader[7] << 8 | packetHeader[6]);

            // Abort Command
            if ((pkt_ver == 0x40) && (flags == 0x03) && (pkt_type == 0x7cbf) && (pkt_len == 0xfcbf) && (reserved == 0xfcbf))
                return true;

            if (_readerMode == 0)
            {
                // Idle mode

                // Read Mac Register packet
                if ((pkt_ver == 0x70 || pkt_ver == 0x00) && (flags == 0x00))
                    return true;
            }
            else
            {
                // Command mode

                // Command-Begin Packet
                if ((pkt_ver == 0x01 || pkt_ver == 0x02) && (pkt_type == 0x0000) && (pkt_len == 0x02) && (reserved == 0x0000))
                    return true;

                // Command-End Packet 
                if ((pkt_ver == 0x01 || pkt_ver == 0x02) && (flags == 0x00) && (pkt_type == 0x0001) && (pkt_len == 0x02) && (reserved == 0x0000))
                    return true;

                // OEM Configuration Read Packet
                if ((pkt_ver == 0x01) && (flags == 0x00) && (pkt_type == 0x3007) && (pkt_len == 0x0002))
                    return true;

                // Inventory-Response Packet 
                if ((pkt_ver == 0x03) && (pkt_type == 0x0005) && (reserved == 0x0000))
                    return true;

                // Inventory-Response Packet (Compact mode)
                //if ((pkt_ver == 0x04) && (pkt_type == 0x0005) && (reserved == 0x0000))
                if ((pkt_ver == 0x04) && (pkt_type == 0x0005))
                    return true;

                // Tag-Access Packet 
                if ((pkt_ver == 0x01) && (pkt_type == 0x0006) && (reserved == 0x0000))
                    return true;

                // Antenna-Cycle-End Packet
                if ((pkt_ver == 0x01 || pkt_ver == 0x02) && (flags == 0x00) && (pkt_type == 0x0007) && (pkt_len == 0x0000) && (reserved == 0x0000))
                    return true;

                // LBT-Jam-Detected Packet 
                if ((pkt_ver == 0x01 || pkt_ver == 0x02) && (flags == 0x00) && (pkt_type == 0x0008) && (pkt_len == 0x0001))
                    return true;
            }

            //CSLibrary.Debug.WriteLine("Packet Check Fail : pkt_ver:" +); 
            return false;
        }


        /// <summary>
        /// Transfer BT API packet to R2000 packet
        /// </summary>
        /// <param name="recvData"></param>
        /// <param name="offset"></param>
        /// <param name="size"></param>
        internal CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE DeviceRecvData_CS108(byte[] recvData1, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE currentCommandResponse)
        {
            CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE result = HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.NOWAIT;

            try
            {
            CSLibrary.Debug.WriteLine("Routine : DeviceRecvData");

            if (!_dataBuffer.DataIn(recvData1, 10, recvData1[2] - 2))
                CSLibrary.Debug.WriteLine("RFID ring buffer FULL!!!!");

            while (_dataBuffer.length >= 8)
            {
                byte[] recvData = _dataBuffer.DataPreOut(8);

                if (!CheckValidRFIDPacket(ref recvData))
                {
                    // drop packet if not is valid RFID packet
                    _dataBuffer.TrimRFIDPacket(_readerMode);
                    continue;
                }

                // first packet
                byte header = recvData[0];

                CSLibrary.Debug.WriteLine("packet type :0x{0}", header.ToString("X2"));
                switch (header)
                {
                    default:
                        _dataBuffer.Clear();
                        CSLibrary.Debug.WriteLine("Can not handle R2000 packet type :0x{0}", header.ToString("X2"));
                        break;
                    case 0x40:  // Abort packet
                        {
                            _deviceHandler.battery.DisbleAutoBatteryLevel();
                            _readerMode = 0; // record reader status to idle mode

                            //result |= HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA2 | HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE;
                            result |= HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA2;
                            result |= HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE;
                            result = result | HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA2 | HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE;
                            _dataBuffer.DataDel(8);
                            LastMacErrorCode = 0x0000;
                            FireStateChangedEvent(CSLibrary.Constants.RFState.IDLE);
//                            _deviceHandler.rfid.SetToStandbyMode();
                        }
                        break;

                    case 0x00:
                    case 0x70:  // register read packet
                        {
                            UInt16 add = (UInt16)(recvData[3] << 8 | recvData[2]);
                            UInt32 data = (UInt32)(recvData[7] << 24 | recvData[6] << 16 | recvData[5] << 8 | recvData[4]);

                            SaveMacRegister(add, data);

                            result |= HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1;

                            _dataBuffer.DataDel(8);
                        }
                        break;

                    case 0x04:  // New Inventory Packet

                        //CSLibrary.HighLevelInterface._debugBLEHold = true;

                        // only valid on inventory compact mode
                        //if ((Operation)(_deviceHandler._currentCmdRemark) == Operation.TAG_RANGING)

                        {
                            int pkt_type = BitConverter.ToUInt16(recvData, 2) & 0x7fff;
                            int packetLen = BitConverter.ToUInt16(recvData, 4) + 8;

                            if (packetLen > _dataBuffer.length)
                                return result;

                            switch (pkt_type)
                            {
                                case 0x0005:    /// inventory packet
									{
                                        InventoryDebug.InventoryPackerCountInc();

                                        byte[] packetData = _dataBuffer.DataOut(packetLen);

                                        R2000Packet_NewInventory(packetData);
                                    }
                                    break;
                            }
                        }
                        break;

                    case 0x01:
                    case 0x02:
                    case 0x03:
                        {
                            int pkt_type = BitConverter.ToUInt16(recvData, 2) & 0x7fff;
                            int packetLen = BitConverter.ToUInt16(recvData, 4) * 4 + 8;

                            if (packetLen > _dataBuffer.length)
                                return result;

                            switch (pkt_type)
                            {
                                default:
                                    _dataBuffer.DataDel(packetLen);
                                    break;

                                case 0x0000:    // Command begin Packet
                                    _dataBuffer.DataDel(packetLen);
                                    break;

                                case 0x0001:    // Command end Packet
                                    _readerMode = 0; // record reader status to idle mode

                                    result |= HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.COMMANDENDRESPONSE;
                                    //_dataBuffer.DataDel(packetLen);
                                    {
                                        byte[] packetData = _dataBuffer.DataOut(packetLen);
                                        LastMacErrorCode = BitConverter.ToUInt32(packetData, 12);
                                    }

                                    // Check Tag access packet
                                    // if ((currentCommandResponse | HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0)
                                    {
                                        Operation RealCurrentOperation = (Operation)(_deviceHandler._currentCmdRemark);

                                        switch (RealCurrentOperation)
                                        {
                                            case CSLibrary.Constants.Operation.TAG_READ:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        CSLibrary.Constants.Bank.SPECIFIC,
                                                        TagAccess.READ,
                                                        m_rdr_opt_parms.TagRead.pData));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_READ_PC:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        CSLibrary.Constants.Bank.PC,
                                                        CSLibrary.Constants.TagAccess.READ,
                                                        m_rdr_opt_parms.TagReadPC.pc));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_READ_EPC:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.EPC,
                                                        TagAccess.READ,
                                                        m_rdr_opt_parms.TagReadEPC.epc));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_READ_ACC_PWD:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        CSLibrary.Constants.Bank.ACC_PWD,
                                                        CSLibrary.Constants.TagAccess.READ,
                                                        m_rdr_opt_parms.TagReadAccPwd.password));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_READ_KILL_PWD:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        CSLibrary.Constants.Bank.KILL_PWD,
                                                        CSLibrary.Constants.TagAccess.READ,
                                                        m_rdr_opt_parms.TagReadKillPwd.password));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_READ_TID:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        CSLibrary.Constants.Bank.TID,
                                                        CSLibrary.Constants.TagAccess.READ,
                                                        m_rdr_opt_parms.TagReadTid.tid));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_READ_USER:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.USER,
                                                        TagAccess.READ,
                                                        m_rdr_opt_parms.TagReadUser.pData));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_AUTHENTICATE:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.UNKNOWN,
                                                        TagAccess.AUTHENTICATE,
                                                        m_rdr_opt_parms.TagAuthenticate.pData));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_UNTRACEABLE:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.UNKNOWN,
                                                        TagAccess.UNTRACEABLE,
                                                        m_rdr_opt_parms.TagAuthenticate.pData));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_WRITE:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.SPECIFIC,
                                                        CSLibrary.Constants.TagAccess.WRITE,
                                                        m_rdr_opt_parms.TagReadUser.pData));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_WRITE_PC:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        CSLibrary.Constants.Bank.PC,
                                                        CSLibrary.Constants.TagAccess.WRITE,
                                                        m_rdr_opt_parms.TagReadPC.pc));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_WRITE_EPC:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.EPC,
                                                        CSLibrary.Constants.TagAccess.WRITE,
                                                        m_rdr_opt_parms.TagReadEPC.epc));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_WRITE_ACC_PWD:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        CSLibrary.Constants.Bank.ACC_PWD,
                                                        CSLibrary.Constants.TagAccess.WRITE,
                                                        m_rdr_opt_parms.TagReadAccPwd.password));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_WRITE_KILL_PWD:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        CSLibrary.Constants.Bank.KILL_PWD,
                                                        CSLibrary.Constants.TagAccess.WRITE,
                                                        m_rdr_opt_parms.TagReadKillPwd.password));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_WRITE_USER:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.USER,
                                                        CSLibrary.Constants.TagAccess.WRITE,
                                                        m_rdr_opt_parms.TagReadUser.pData));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_BLOCK_WRITE:
                                                {
                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.SPECIFIC,
                                                        CSLibrary.Constants.TagAccess.WRITE,
                                                        m_rdr_opt_parms.TagReadUser.pData));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_LOCK:
                                                {
                                                    CSLibrary.Debug.WriteLine("Tag lock end {0}", currentCommandResponse);

                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.UNKNOWN,
                                                        TagAccess.LOCK,
                                                        null));
                                                }
                                                break;

                                            case CSLibrary.Constants.Operation.TAG_KILL:
                                                {
                                                    CSLibrary.Debug.WriteLine("Tag Kill end {0}", currentCommandResponse);

                                                    FireAccessCompletedEvent(
                                                        new OnAccessCompletedEventArgs(
                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                        Bank.UNKNOWN,
                                                        TagAccess.KILL,
                                                        null));
                                                }
                                                break;

                                            default:
                                                if (_deviceHandler.rfid.EM4325.CommandEndProc(RealCurrentOperation, ((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0))
                                                    break;

                                                if (_deviceHandler.rfid.FM13DT160.CommandEndPProc(RealCurrentOperation, ((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0))
                                                    break;

                                                break;

                                                /*
                                                                                            case CSLibrary.Constants.Operation.TAG_UNTRACEABLE:
                                                                                                {
                                                                                                    CSLibrary.Debug.WriteLine("Tag untraceable end {0}", currentCommandResponse);

                                                                                                    FireAccessCompletedEvent(
                                                                                                        new OnAccessCompletedEventArgs(
                                                                                                        (((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
                                                                                                        Bank.UNTRACEABLE,
                                                                                                        TagAccess.WRITE,
                                                                                                        null));
                                                                                                }
                                                                                                break;
                                                                                                */

                                        }
                                    }

                                    FireStateChangedEvent(CSLibrary.Constants.RFState.IDLE);
//                                    _deviceHandler.rfid.SetToStandbyMode();

                                    break;

                                case 0x0005:    /// inventory packet
									{
                                        InventoryDebug.InventoryPackerCountInc();

                                        byte[] packetData = _dataBuffer.DataOut(packetLen);

                                        R2000Packet_Inventory(packetData);
                                    }
                                    break;

                                case 0x0006:    // Tag access Packet
                                    {
                                        byte[] packetData = _dataBuffer.DataOut(packetLen);

                                        if (R2000Packet_TagAccess(packetData))
                                            result |= HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1;
                                    }
                                    break;

                                case 0x0007:    // Antenna-Cycle-End Packet
                                    {
                                        byte[] packetData = _dataBuffer.DataOut(packetLen);
                                    }
                                    break;

                                case 0x000A:    // INVENTORY_CYCLE_BEGIN
                                    {
                                        byte[] packetData = _dataBuffer.DataOut(packetLen);
                                    }
                                    break;

                                case 0x3007:    // RFID_PACKET_OEMCFG_READ
                                    {
                                        byte[] packetData = _dataBuffer.DataOut(packetLen);

                                        var m_OEMReadAdd = (UInt32)(packetData[8] | packetData[9] << 8 | packetData[10] << 16 | packetData[11] << 24);
                                        var m_OEMReadData = (UInt32)(packetData[12] | packetData[13] << 8 | packetData[14] << 16 | packetData[15] << 24);

                                        StoreOEMData(m_OEMReadAdd, m_OEMReadData);

                                        result |= HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1;
                                    }
                                    break;
                            }
                        }
                        break;
                }
            }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("DeviceRecvData_CS108 Error : " + ex.Message);
            }
            return result;
        }

        ////////////////////////////////////////////////////////////////////////////////
        // Name:        Radio::WriteMacMaskRegisters
        // Description: Writes the MAC mask registers (select or post-singulation).
        ////////////////////////////////////////////////////////////////////////////////
        void WriteMacMaskRegisters(UInt16 registerAddress, UInt32 bitCount, byte[] pMask)
        {
			const int BITS_PER_BYTE = 8;
            const int BYTES_PER_REGISTER = 4;
            const int BITS_PER_REGISTER = BITS_PER_BYTE * BYTES_PER_REGISTER;
            int pcnt = 0;

            // Figure out how many bytes are in the mask
            UInt32 byteCount = (bitCount + 7) / 8;

            // Now write each MAC mask register
            while (byteCount > 0)
            {
                    UInt32 registerValue = 0;
                    int leftShift = 0;
                    UInt32 loopCount = (byteCount > BYTES_PER_REGISTER ? BYTES_PER_REGISTER : byteCount);

                    // Decrement the byte count by the number of bytes put into the register
                    byteCount -= loopCount;

                    // Build up the register value
                    for (int cnt = 0; cnt < loopCount; cnt++)
                    {
                        registerValue |= ((uint)pMask[pcnt++] << leftShift);
                        leftShift += BITS_PER_BYTE;
                    }

                    // If it is the last byte of the mask, then we are going to zero out
                    // any bits not in the mask
                    if (byteCount == 0 && (bitCount % BITS_PER_BYTE) != 0)
                    {
                        UInt32 mask = 0xFFFFFFFF;
                        mask <<= (int)(BITS_PER_REGISTER - (BITS_PER_BYTE - (bitCount % BITS_PER_BYTE)));
                        mask >>= (int)(BITS_PER_REGISTER - (leftShift - (bitCount % BITS_PER_BYTE)));
                        registerValue &= ~mask;
                    }

                // Write the register
                MacWriteRegister((MACREGISTER)(registerAddress++), registerValue);
           }
       } // Radio::WriteMacMaskRegisters

        /// <summary>
        /// Configures the tag-selection criteria for the ISO 18000-6C select 
        /// command.  The supplied tag-selection criteria will be used for any 
        /// tag-protocol operations (i.e., Inventory, etc.) in 
        /// which the application specifies that an ISO 18000-6C select 
        /// command should be issued prior to executing the tag-protocol 
        /// operation (i.e., the SelectFlags.SELECT flag is provided to 
        /// the appropriate RFID_18K6CTag* function).  The tag-selection 
        /// criteria will stay in effect until the next call to 
        /// SetSelectCriteria.  Tag-selection criteria may not 
        /// be changed while a radio module is executing a tag-protocol 
        /// operation. 
        /// </summary>
        /// <param name="critlist">
        /// SelectCriteria array, containing countCriteria entries, of selection 
        /// criterion structures that are to be applied sequentially, beginning with 
        /// pCriteria[0], to the tag population.  If this field is NULL, 
        /// countCriteria must be zero. 
        ///</param>
        /// <returns></returns>

        internal Result SetSelectCriteria_CS108(SelectCriterion[] critlist)
        {
            uint index;
            uint registerValue;

            if (critlist == null || critlist.Length == 0)
                return Result.INVALID_PARAMETER;

            try
            {
                SelectCriteria SC = new SelectCriteria();
                SC.countCriteria = (uint)critlist.Length;
                SC.pCriteria = (SelectCriterion[])critlist.Clone();

                for (index = 0; index < critlist.Length; index++)
                {
                    SelectCriterion pCriterion = SC.pCriteria[index];
                    SelectMask pMask = pCriterion.mask;
                    SelectAction pAction = pCriterion.action;

                    // Instruct the MAC as to which select mask we want to work with
                    MacWriteRegister(MACREGISTER.HST_TAGMSK_DESC_SEL, index);

                    // Create the HST_TAGMSK_DESC_CFG register value and write it to the MAC
                    registerValue = (0x01 |
                        (((uint)(pAction.target) & 0x07) << 1) |
                        (((uint)(pAction.action) & 0x07) << 4) |
                        (pAction.enableTruncate != 0x00 ? (uint)(1 << 7) : 0)) |
                        (((uint)(pAction.delay) & 0xFF) << 8) ;
                    MacWriteRegister(MACREGISTER.HST_TAGMSK_DESC_CFG, registerValue);

                    // Create the HST_TAGMSK_BANK register value and write it to the MAC
                    registerValue = (uint)pMask.bank;
                    MacWriteRegister(MACREGISTER.HST_TAGMSK_BANK, registerValue);

                    // Write the mask offset to the HST_TAGMSK_PTR register
                    MacWriteRegister(MACREGISTER.HST_TAGMSK_PTR, (uint)pMask.offset);

                    // Create the HST_TAGMSK_LEN register and write it to the MAC
                    registerValue = (uint)(pMask.count);
                    MacWriteRegister(MACREGISTER.HST_TAGMSK_LEN, registerValue);

                    // Now write the MAC's mask registers
                    WriteMacMaskRegisters((ushort)MACREGISTER.HST_TAGMSK_0_3, pMask.count, pMask.mask);
                    // Set up the selection criteria
                }
            }
            catch (System.Exception ex)
            {
#if DEBUG
                //				CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.SetSelectCriteria()", ex);
#endif
                return Result.SYSTEM_CATCH_EXCEPTION;
            }
            return m_Result;
        }

        internal Result CancelAllSelectCriteria_CS108()
        {
            for (uint cnt = 0; cnt < 7; cnt++)
            {
                SetSelectCriteria_CS108(cnt, null);
            }

            return Result.OK;
        }

        internal Result SetSelectCriteria_CS108(uint index, SelectCriterion crit)
        {
            uint registerValue;

            // Instruct the MAC as to which select mask we want to work with
            MacWriteRegister(MACREGISTER.HST_TAGMSK_DESC_SEL, index);

            if (crit == null)
            {
                MacWriteRegister(MACREGISTER.HST_TAGMSK_DESC_CFG, 0x0000);
                //MacWriteRegister(MACREGISTER.HST_TAGMSK_BANK, 0x0000);
                //MacWriteRegister(MACREGISTER.HST_TAGMSK_PTR, 0x0000);
                //MacWriteRegister(MACREGISTER.HST_TAGMSK_LEN, 0x0000);
                return Result.OK;
            }

            try
            {
                {
                    SelectCriterion pCriterion = crit;
                    SelectMask pMask = pCriterion.mask;
                    SelectAction pAction = pCriterion.action;

                    // Create the HST_TAGMSK_DESC_CFG register value and write it to the MAC
                    registerValue = (0x01 |
                        (((uint)(pAction.target) & 0x07) << 1) |
                        (((uint)(pAction.action) & 0x07) << 4) |
                        (pAction.enableTruncate != 0x00 ? (uint)(1 << 7) : 0)) |
                        (((uint)(pAction.delay) & 0xFF) << 8);
                    MacWriteRegister(MACREGISTER.HST_TAGMSK_DESC_CFG, registerValue);

                    // Create the HST_TAGMSK_BANK register value and write it to the MAC
                    registerValue = (uint)pMask.bank;
                    MacWriteRegister(MACREGISTER.HST_TAGMSK_BANK, registerValue);

                    // Write the mask offset to the HST_TAGMSK_PTR register
                    MacWriteRegister(MACREGISTER.HST_TAGMSK_PTR, (uint)pMask.offset);

                    // Create the HST_TAGMSK_LEN register and write it to the MAC
                    registerValue = (uint)(pMask.count);
                    MacWriteRegister(MACREGISTER.HST_TAGMSK_LEN, registerValue);

                    // Now write the MAC's mask registers
                    WriteMacMaskRegisters((ushort)MACREGISTER.HST_TAGMSK_0_3, pMask.count, pMask.mask);
                    // Set up the selection criteria
                }
            }
            catch (System.Exception ex)
            {
#if DEBUG
                //				CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.SetSelectCriteria()", ex);
#endif
                return Result.SYSTEM_CATCH_EXCEPTION;
            }
            return m_Result;
        }

        /// <summary>
        /// Configures the post-singulation match criteria to be used by the 
        /// RFID radio module.  The supplied post-singulation match criteria 
        /// will be used for any tag-protocol operations (i.e., 
        /// Inventory, etc.) in which the application specifies 
        /// that a post-singulation match should be performed on the tags 
        /// that are singulated by the tag-protocol operation (i.e., the 
        /// SelectFlags.POST_MATCH flag is provided to the 
        /// appropriate RFID_18K6CTag* function).  The post-singulation 
        /// match criteria will stay in effect until the next call to 
        /// SetPostMatchCriteria.  Post-singulation match 
        /// criteria may not be changed while a radio module is executing a 
        /// tag-protocol operation. 
        /// </summary>
        /// <param name="postmatch"> An array that specifies the post-
        /// singulation match criteria that are to be 
        /// applied to the tag's Electronic Product Code 
        /// after it is singulated to determine if it is to 
        /// have the tag-protocol operation applied to it.  
        /// If the countCriteria field is zero, all post-
        /// singulation criteria will be disabled.  This 
        /// parameter must not be NULL. </param>
        /// <returns></returns>
        internal Result SetPostMatchCriteria_CS108(SingulationCriterion[] postmatch)
		{
			UInt32 registerValue;

			try
			{
				if (postmatch.Length != 0)
				{
					// Set up the post-singulation match criteria
					//                    pCriterion = pParms->pCriteria;
					//                    const RFID_18K6C_SINGULATION_MASK* pMask = &pCriterion->mask;

					SingulationMask pMask = postmatch[0].mask;

					// Set up the HST_INV_EPC_MATCH_CFG register and write it to the MAC.
					// For now, we are going to assume that the singulation match should be
					// enabled (if the application so desires, we can turn it off when we
					// actually do the tag-protocol operation).
					registerValue =
                        (uint)(postmatch[0].match != 0 ? 0 : 2) |
						(uint)(postmatch[0].mask.count << 2) |
						(uint)(postmatch[0].mask.offset << 11);

                    MacWriteRegister(MACREGISTER.HST_INV_EPC_MATCH_SEL, 0X00);
					MacWriteRegister(MACREGISTER.HST_INV_EPC_MATCH_CFG, registerValue);

					// Now write the MAC's mask registers
					WriteMacMaskRegisters((UInt16)MACREGISTER.HST_INV_EPCDAT_0_3, pMask.count, pMask.mask);
				}
				else // must be calling to disable criteria
				{
					MacWriteRegister(MACREGISTER.HST_INV_EPC_MATCH_CFG, 0);
				}
			}
			catch (System.Exception ex)
			{
#if DEBUG
//				CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.SetSelectCriteria()", ex);
#endif
				return Result.SYSTEM_CATCH_EXCEPTION;
			}
			return m_Result;
		}

        #region ====================== Set Tag Group ======================
        /// <summary>
        /// Get Tag Group
        /// </summary>
        /// <param name="gpSelect"></param>
        /// <returns></returns>
        public Result SetTagGroup_CS108(Selected gpSelect)
        {
            UInt32 value = 0;

            MacReadRegister(MACREGISTER.HST_QUERY_CFG, ref value);

            value &= ~0x0180U;
            value |= ((uint)gpSelect << 7);

            MacWriteRegister(MACREGISTER.HST_QUERY_CFG, value);

            return Result.OK;
        }

        /// <summary>
        /// Once the tag population has been partitioned into disjoint groups, a subsequent 
        /// tag-protocol operation (i.e., an inventory operation or access command) is then 
        /// applied to one of the tag groups. 
        /// </summary>
        /// <param name="gpSelect">Specifies the state of the selected (SL) flag for tags that will have 
        /// the operation applied to them. </param>
        /// <param name="gpSession">Specifies which inventory session flag (i.e., S0, S1, S2, or S3) 
        /// will be matched against the inventory state specified by target. </param>
        /// <param name="gpSessionTarget">Specifies the state of the inventory session flag (i.e., A or B),
        /// specified by session, for tags that will have the operation 
        /// applied to them. </param>
        public Result SetTagGroup_CS108(Selected gpSelect, Session gpSession, SessionTarget gpSessionTarget)
		{
			UInt32 value = 0;

			//DEBUG_WriteLine(DEBUGLEVEL.API, "HighLevelInterface.SetTagGroup(Selected gpSelect, Session gpSession, SessionTarget gpSessionTarget)");

			MacReadRegister(MACREGISTER.HST_QUERY_CFG, ref value);

			value &= ~0x01f0U;
			value |= ((uint)gpSessionTarget << 4) | ((uint)gpSession << 5) | ((uint)gpSelect << 7);

			MacWriteRegister(MACREGISTER.HST_QUERY_CFG, value);

			return Result.OK;

			/*            return (m_Result = MacWriteRegister(MACREGISTER.HST_QUERY_CFG,
							(uint)gpSessionTarget << 4 |
							(uint)gpSession << 5 |
							(uint)gpSelect << 7));*/
		}

        /// <summary>
        /// Once the tag population has been partitioned into disjoint groups, a subsequent 
        /// tag-protocol operation (i.e., an inventory operation or access command) is then 
        /// applied to one of the tag groups. 
        /// </summary>
        /// <param name="tagGroup"><see cref="TagGroup"/></param>
        /// <returns></returns>
        public Result SetTagGroup_CS108(TagGroup tagGroup)
		{
			UInt32 value = 0;

			//DEBUG_WriteLine(DEBUGLEVEL.API, "HighLevelInterface.SetTagGroup(TagGroup tagGroup)");

			MacReadRegister(MACREGISTER.HST_QUERY_CFG, ref value);

			value &= ~0x01f0U;
			value |= ((uint)tagGroup.target << 4) | ((uint)tagGroup.session << 5) | ((uint)tagGroup.selected << 7);

			MacWriteRegister(MACREGISTER.HST_QUERY_CFG, value);

			return Result.OK;

			/*            return (m_Result = MacWriteRegister(MACREGISTER.HST_QUERY_CFG,
							(uint)tagGroup.target << 4 |
							(uint)tagGroup.session << 5 |
							(uint)tagGroup.selected << 7));
			*/
		}
		/// <summary>
		/// Get Tag Group
		/// </summary>
		/// <param name="tagGroup"></param>
		/// <returns></returns>
		internal Result GetTagGroup_CS108(ref TagGroup tagGroup)
		{
			//UInt16 HST_QUERY_CFG = 0x0900;

			UInt32 registerValue = 0;

			//DEBUG_WriteLine(DEBUGLEVEL.API, "HighLevelInterface.GetTagGroup(TagGroup tagGroup)");

			MacReadRegister(MACREGISTER.HST_QUERY_CFG, ref registerValue);

			tagGroup.selected = (Selected)((registerValue >> 7) & 0x03);
			tagGroup.session = (Session)((registerValue >> 5) & 0x03);
			tagGroup.target = (SessionTarget)((registerValue >> 4) & 0x01);

			return (m_Result = Result.OK);
		}
#endregion


        internal UInt32 _INVENTORYDELAYTIME = (7 << 20);

        internal bool SetTagDelayTime_CS108(UInt32 ms)
        {
            if (ms > 0x3f)
                return false;

            _INVENTORYDELAYTIME = (ms << 20);

            UInt32 value = 0;

            MacReadRegister(MACREGISTER.HST_INV_CFG, ref value);

            value &= ~(0x03f00000U);
            value |= (ms << 20);

            MacWriteRegister(MACREGISTER.HST_INV_CFG, value);

            return true;
        }

        #region Public Functions

		internal void Connect_CS108()
		{
            MacRegisterInitialize();
            ReadReaderOEMData();
        }

        internal void Reconnect_CS108()
		{
		}

        internal UInt32 GetFirmwareVersion_CS108()
        {
            UInt32 value = 0, value1;

            MacReadRegister(MACREGISTER.MAC_VER, ref value);

            value1 = (0xfff & value) | ((0xfff & (value >> 12)) << 8) | ((0xff & (value >> 24)) << 16);

            return value1;
        }

        internal string GetFirmwareVersionString_CS108()
        {
            var ver = GetFirmwareVersion_CS108();
            var verString = string.Format("{0}.{1}.{2}", (ver >> 16) & 0xff, (ver >> 8) & 0xff, ver & 0xff);

            return verString;
        }



        /// <summary>
        /// Retrieves the operation mode for the RFID radio module.  The 
        /// operation mode cannot be retrieved while a radio module is 
        /// executing a tag-protocol operation. 
        /// </summary>
        /// <param name="cycles">The number of antenna cycles to be completed for command execution.
        /// <para>0x0001 = once cycle through</para>
        /// <para>0xFFFF = cycle forever until a CANCEL is received.</para></param>
        /// <param name="mode">Antenna Sequence mode.</param>
        /// <param name="sequenceSize">Sequence size. Maximum value is 48</param>
        /// <returns></returns>
        public Result GetOperationMode_CS108(ref ushort cycles, ref AntennaSequenceMode mode, ref uint sequenceSize)
		{
			uint value = 0;

			MacReadRegister(MACREGISTER.HST_ANT_CYCLES /*0x700*/, ref value);

			cycles = (ushort)(0xffff & value);
			mode = (AntennaSequenceMode)((value >> 16) & 0x3);
			sequenceSize = (value >> 18) & 0x3F;

			return Result.OK;
		}

		/// <summary>
		/// Retrieves the operation mode for the RFID radio module.  The 
		/// operation mode cannot be retrieved while a radio module is 
		/// executing a tag-protocol operation. 
		/// </summary>
		/// <param name="mode"> return will receive the current operation mode.</param>
		/// <returns></returns>
		public void GetOperationMode_CS108(ref RadioOperationMode mode)
		{
			UInt32 value = 0;

			MacReadRegister(MACREGISTER.HST_ANT_CYCLES /*0x700 HST_ANT_CYCLES*/, ref value);

			if ((value & 0xffff) == 0xffff)
				mode = RadioOperationMode.CONTINUOUS;
			else
				mode = RadioOperationMode.NONCONTINUOUS;
		}

		/// <summary>
		/// Sets the operation mode of RFID radio module.  By default, when 
		/// an application opens a radio, the RFID Reader Library sets the 
		/// reporting mode to non-continuous.  An RFID radio module's 
		/// operation mode will remain in effect until it is explicitly changed 
		/// via RFID_RadioSetOperationMode, or the radio is closed and re-
		/// opened (at which point it will be set to non-continuous mode).  
		/// The operation mode may not be changed while a radio module is 
		/// executing a tag-protocol operation. 
		/// </summary>
		/// <param name="mode">The operation mode for the radio module.</param>
		/// <returns></returns>
		public Result SetOperationMode_CS108(RadioOperationMode mode)
		{
			AntennaSequenceMode smode = AntennaSequenceMode.NORMAL;
			uint sequenceSize = 0;

			if (RadioOperationMode.UNKNOWN == mode)
				return Result.INVALID_PARAMETER;

			SetOperationMode_CS108((ushort)(mode == RadioOperationMode.CONTINUOUS ? 0xFFFF : 1), smode, sequenceSize);

			return Result.OK;
		}

		/// <summary>
		/// Sets the operation mode of RFID radio module.  By default, when 
		/// an application opens a radio, the RFID Reader Library sets the 
		/// reporting mode to non-continuous.  An RFID radio module's 
		/// operation mode will remain in effect until it is explicitly changed 
		/// via RFID_RadioSetOperationMode, or the radio is closed and re-
		/// opened (at which point it will be set to non-continuous mode).  
		/// The operation mode may not be changed while a radio module is 
		/// executing a tag-protocol operation. 
		/// </summary>
		/// <param name="cycles">The number of antenna cycles to be completed for command execution.
		/// <para>0x0001 = once cycle through</para>
		/// <para>0xFFFF = cycle forever until a CANCEL is received.</para></param>
		/// <returns></returns>
		public Result SetOperationMode_CS108(UInt16 cycles)
		{
			bool result = false;
			uint value = 0, value1 = 0;

			if (!MacReadRegister(MACREGISTER.HST_ANT_CYCLES/*0x700*/, ref value))
				return Result.FAILURE;

			value1 = cycles;
			if (((value >> 24) & 0x01) != 0)
				value1 |= (0x01 << 24);

			MacWriteRegister(MACREGISTER.HST_ANT_CYCLES/*0x700*/, value1);

			return Constants.Result.OK;
		}

		/// <summary>
		/// Sets the operation mode of RFID radio module.  By default, when 
		/// an application opens a radio, the RFID Reader Library sets the 
		/// reporting mode to non-continuous.  An RFID radio module's 
		/// operation mode will remain in effect until it is explicitly changed 
		/// via RFID_RadioSetOperationMode, or the radio is closed and re-
		/// opened (at which point it will be set to non-continuous mode).  
		/// The operation mode may not be changed while a radio module is 
		/// executing a tag-protocol operation. 
		/// </summary>
		/// <param name="cycles">The number of antenna cycles to be completed for command execution.
		/// <para>0x0001 = once cycle through</para>
		/// <para>0xFFFF = cycle forever until a CANCEL is received.</para></param>
		/// <param name="mode">Antenna Sequence mode.</param>
		/// <param name="sequenceSize">Sequence size. Maximum value is 48</param>
		/// <returns></returns>
		public Result SetOperationMode_CS108(ushort cycles, AntennaSequenceMode mode = AntennaSequenceMode.NORMAL, uint sequenceSize = 0)
		{
			uint value = 0;

			if (sequenceSize > 48)
				return Result.INVALID_PARAMETER;

			value = (cycles | ((uint)mode & 0x3) << 16 | (sequenceSize & 0x3F) << 18);
			MacWriteRegister(MACREGISTER.HST_ANT_CYCLES, value);
            return Result.OK;
		}

        /// <summary>
        /// Sets the radio's operation mode.  An RFID radio module operation mode
        /// will remain in effect until it is explicitly changed via RadioSetOperationMode
        /// </summary>
        /// <param name="operationMode">The operation mode for the radio module.</param>
        /// <param name="sequenceMode">The antenna sequence mode for the radio module.</param>
        /// <param name="sequenceSize">The antenna sequence size for the radio module. This must be between 0 to 48.</param>
        /// <returns></returns>
        public Result SetOperationMode_CS108(RadioOperationMode operationMode, AntennaSequenceMode sequenceMode, int sequenceSize)
        {
            String __FUNCTION__ = "SetOperationMode";

            if (m_state == RFState.BUSY)
                return Result.RADIO_BUSY;

            try
            {
                // Validate the operation mode
                switch (operationMode)
                {
                    // Valid operation modes
                    case RadioOperationMode.CONTINUOUS:
                    case RadioOperationMode.NONCONTINUOUS:
                        {
                            break;
                        }
                    // Invalid operation modes
                    default:
                        {
                            return Result.INVALID_PARAMETER;
                        }
                } // switch (mode)

                switch (sequenceMode)
                {
                    case AntennaSequenceMode.NORMAL:
                    case AntennaSequenceMode.SEQUENCE:
                    case AntennaSequenceMode.SMART_CHECK:
                    case AntennaSequenceMode.SEQUENCE_SMART_CHECK:
                        break;
                    default:
                        {
                            return Result.INVALID_PARAMETER;
                        }
                }

                if (sequenceSize < 0 || sequenceSize > 48)
                {
                    return Result.INVALID_PARAMETER;
                }

                // Let the radio object set the operation mode
                uint old_data = 0;
                FreqAgileMode AgileEnable;

                MacReadRegister(MACREGISTER.HST_ANT_CYCLES, ref old_data);

                if ((old_data & (1 << 24)) == 0)
                    AgileEnable = FreqAgileMode.DISABLE;
                else
                    AgileEnable = FreqAgileMode.ENABLE;

                // Set the antenna cycles register to either perform a single cycle or to
                // cycle until a cancel
                UInt32 registerValue = (UInt32)(((operationMode == RadioOperationMode.CONTINUOUS) ? 0xffff : 0x00001) |
                                                ((int)sequenceMode << 16) |
                                                ((int)sequenceSize << 18) |
                                                ((AgileEnable == FreqAgileMode.ENABLE) ? 1 << 24 : 0x0000));

                MacWriteRegister(MACREGISTER.HST_ANT_CYCLES, registerValue);

                //m_save_antenna_cycle = operationMode;
                //m_save_antenna_cycle_sequence_mode = sequenceMode;
                //m_save_antenna_cycle_sequence_size = sequenceSize;
            }
            catch (Exception ex)
            {
            }

            return Result.OK;
        }

        /// <summary>
        /// This is used to set inventory duration
        /// </summary>
        /// <param name="duration"></param>
        /// <returns></returns>
        public Result SetInventoryDuration_CS108(uint duration, uint antennaPort = 0)
		{
			MacWriteRegister(MACREGISTER.HST_ANT_DESC_SEL, antennaPort);
			MacWriteRegister(MACREGISTER.HST_ANT_DESC_DWELL, duration);

			return Result.OK;
		}

        public Result SetInventoryDuration_CS108(uint [] duration)
        {
            Result r;

			for (uint cnt = 0; cnt < duration.Length; cnt++)
                if ((r = SetInventoryDuration(duration[cnt], cnt)) != Result.OK)
                    return r;

            return Result.OK;
        }

        #endregion

    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Private.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary;
using CSLibrary.Constants;
using CSLibrary.Structures;
using CSLibrary.Events;
using CSLibrary.Tools;


namespace CSLibrary
{
    public partial class RFIDReader
    {
        /// <summary>
        /// REGISTER NAME/ADDRESS CONSTANTS
        /// </summary>
        public enum MACREGISTER : UInt16
        {
            MAC_VER = 0x0000,
            MAC_INFO = 0x0001,
            MAC_RFTRANSINFO = 0x0002,
            MAC_DBG1 = 0x0003,
            MAC_DBG2 = 0x0004,
            MAC_ERROR = 0x0005,

            HST_ENGTST_ARG0 = 0x0100,
            HST_ENGTST_ARG1 = 0x0101,
            HST_DBG1 = 0x0102,
            HST_EMU = 0x0103,

            FM13DT160_CMDCFGPAR = 0x117,
            FM13DT160_REGADDRPAR = 0x118,
            FM13DT160_WRITEPAR = 0x119,
            FM13DT160_PWDPAR = 0x11a,
            FM13DT160_STOBLOCKADDPAR = 0x11b,
            FM13DT160_STARTADDRPAR = 0x11c,
            FM13DT160_READWRITELENPAR = 0x11d,
            FM13DT160_DATAPAR = 0x11e,

            EM4325_CFG = 0x11f,

            HST_PWRMGMT = 0x0200,
            HST_CMNDIAGS = 0x0201,
            MAC_BLK02RES1 = 0x0202,
            HST_IMPINJ_EXTENSIONS = 0x0203,
            HST_CTR1_CFG = 0x0204,
            MAC_CTR1_VAL = 0x0205,
            HST_CTR2_CFG = 0x0206,
            MAC_CTR2_VAL = 0x0207,
            HST_CTR3_CFG = 0x0208,
            MAC_CTR3_VAL = 0x0209,
            HST_CTR4_CFG = 0x020A,
            MAC_CTR4_VAL = 0x020B,

            HST_PROTSCH_SMIDX = 0x0300,
            HST_PROTSCH_SMCFG = 0x0301,
            HST_PROTSCH_FTIME_SEL = 0x0302,
            HST_PROTSCH_FTIME = 0x0303,
            HST_PROTSCH_SMCFG_SEL = 0x0304,
            HST_PROTSCH_TXTIME_SEL = 0x0305,
            HST_PROTSCH_TXTIME_ON = 0x0306,
            HST_PROTSCH_TXTIME_OFF = 0x0307,
            HST_PROTSCH_CYCCFG_SEL = 0x0308,
            HST_PROTSCH_CYCCFG_DESC_ADJ1 = 0x0309,
            HST_PROTSCH_ADJCW = 0x030A,

            HST_MBP_ADDR = 0x0400,
            HST_MBP_DATA = 0x0401,
            HST_MBP_RFU_0x0402 = 0x0402,
            HST_MBP_RFU_0x0403 = 0x0403,
            HST_MBP_RFU_0x0404 = 0x0404,
            HST_MBP_RFU_0x0405 = 0x0405,
            HST_MBP_RFU_0x0406 = 0x0406,
            HST_MBP_RFU_0x0407 = 0x0407,
            HST_LPROF_SEL = 0x0408,
            HST_LPROF_ADDR = 0x0409,
            HST_LPROF_DATA = 0x040A,

            HST_OEM_ADDR = 0x0500,
            HST_OEM_DATA = 0x0501,

            HST_GPIO_INMSK = 0x0600,
            HST_GPIO_OUTMSK = 0x0601,
            HST_GPIO_OUTVAL = 0x0602,
            HST_GPIO_CFG = 0x0603,

            HST_ANT_CYCLES = 0x0700,
            HST_ANT_DESC_SEL = 0x0701,
            HST_ANT_DESC_CFG = 0x0702,
            MAC_ANT_DESC_STAT = 0x0703,
            HST_ANT_DESC_PORTDEF = 0x0704,
            HST_ANT_DESC_DWELL = 0x0705,
            HST_ANT_DESC_RFPOWER = 0x0706,
            HST_ANT_DESC_INV_CNT = 0x0707,

            HST_TAGMSK_DESC_SEL = 0x0800,
            HST_TAGMSK_DESC_CFG = 0x0801,
            HST_TAGMSK_BANK = 0x0802,
            HST_TAGMSK_PTR = 0x0803,
            HST_TAGMSK_LEN = 0x0804,
            HST_TAGMSK_0_3 = 0x0805,
            HST_TAGMSK_4_7 = 0x0806,
            HST_TAGMSK_8_11 = 0x0807,
            HST_TAGMSK_12_15 = 0x0808,
            HST_TAGMSK_16_19 = 0x0809,
            HST_TAGMSK_20_23 = 0x080A,
            HST_TAGMSK_24_27 = 0x080B,
            HST_TAGMSK_28_31 = 0x080C,

            HST_QUERY_CFG = 0x0900,
            HST_INV_CFG = 0x0901,
            HST_INV_SEL = 0x0902,
            HST_INV_ALG_PARM_0 = 0x0903,
            HST_INV_ALG_PARM_1 = 0x0904,
            HST_INV_ALG_PARM_2 = 0x0905,
            HST_INV_ALG_PARM_3 = 0x0906,
            HST_INV_RSSI_FILTERING_CONFIG = 0x0907,
            HST_INV_RSSI_FILTERING_THRESHOLD = 0x0908,
            HST_INV_RFU_0x0909 = 0x0909,
            HST_INV_RFU_0x090A = 0x090A,
            HST_INV_RFU_0x090B = 0x090B,
            HST_INV_RFU_0x090C = 0x090C,
            HST_INV_RFU_0x090D = 0x090D,
            HST_INV_RFU_0x090E = 0x090E,
            HST_INV_RFU_0x090F = 0x090F,
            HST_INV_EPC_MATCH_SEL = 0x0910,
            HST_INV_EPC_MATCH_CFG = 0x0911,
            HST_INV_EPCDAT_0_3 = 0x0912,
            HST_INV_EPCDAT_4_7 = 0x0913,
            HST_INV_EPCDAT_8_11 = 0x0914,
            HST_INV_EPCDAT_12_15 = 0x0915,
            HST_INV_EPCDAT_16_19 = 0x0916,
            HST_INV_EPCDAT_20_23 = 0x0917,
            HST_INV_EPCDAT_24_27 = 0x0918,
            HST_INV_EPCDAT_28_31 = 0x0919,
            HST_INV_EPCDAT_32_35 = 0x091A,
            HST_INV_EPCDAT_36_39 = 0x091B,
            HST_INV_EPCDAT_40_43 = 0x091C,
            HST_INV_EPCDAT_44_47 = 0x091D,
            HST_INV_EPCDAT_48_51 = 0x091E,
            HST_INV_EPCDAT_52_55 = 0x091F,
            HST_INV_EPCDAT_56_59 = 0x0920,
            HST_INV_EPCDAT_60_63 = 0x0921,

            HST_TAGACC_DESC_SEL = 0x0A00,
            HST_TAGACC_DESC_CFG = 0x0A01,
            HST_TAGACC_BANK = 0x0A02,
            HST_TAGACC_PTR = 0x0A03,
            HST_TAGACC_CNT = 0x0A04,
            HST_TAGACC_LOCKCFG = 0x0A05,
            HST_TAGACC_ACCPWD = 0x0A06,
            HST_TAGACC_KILLPWD = 0x0A07,
            HST_TAGWRDAT_SEL = 0x0A08,
            HST_TAGWRDAT_0 = 0x0A09,
            HST_TAGWRDAT_1 = 0x0A0A,
            HST_TAGWRDAT_2 = 0x0A0B,
            HST_TAGWRDAT_3 = 0x0A0C,
            HST_TAGWRDAT_4 = 0x0A0D,
            HST_TAGWRDAT_5 = 0x0A0E,
            HST_TAGWRDAT_6 = 0x0A0F,
            HST_TAGWRDAT_7 = 0x0A10,
            HST_TAGWRDAT_8 = 0x0A11,
            HST_TAGWRDAT_9 = 0x0A12,
            HST_TAGWRDAT_10 = 0x0A13,
            HST_TAGWRDAT_11 = 0x0A14,
            HST_TAGWRDAT_12 = 0x0A15,
            HST_TAGWRDAT_13 = 0x0A16,
            HST_TAGWRDAT_14 = 0x0A17,
            HST_TAGWRDAT_15 = 0x0A18,

            MAC_RFTC_PAPWRLEV = 0x0B00,
            HST_RFTC_PAPWRCTL_PGAIN = 0x0B01,
            HST_RFTC_PAPWRCTL_IGAIN = 0x0B02,
            HST_RFTC_PAPWRCTL_DGAIN = 0x0B03,
            MAC_RFTC_REVPWRLEV = 0x0B04,
            HST_RFTC_REVPWRTHRSH = 0x0B05,
            MAC_RFTC_AMBIENTTEMP = 0x0B06,
            HST_RFTC_AMBIENTTEMPTHRSH = 0x0B07,
            MAC_RFTC_XCVRTEMP = 0x0B08,
            HST_RFTC_XCVRTEMPTHRSH = 0x0B09,
            MAC_RFTC_PATEMP = 0x0B0A,
            HST_RFTC_PATEMPTHRSH = 0x0B0B,
            HST_RFTC_PADELTATEMPTHRSH = 0x0B0C,
            HST_RFTC_PAPWRCTL_AIWDELAY = 0x0B0D,
            MAC_RFTC_PAPWRCTL_STAT0 = 0x0B0E,
            MAC_RFTC_PAPWRCTL_STAT1 = 0x0B0F,
            MAC_RFTC_PAPWRCTL_STAT2 = 0x0B10,
            MAC_RFTC_PAPWRCTL_STAT3 = 0x0B11,
            HST_RFTC_ANTSENSRESTHRSH = 0x0B12,
            HST_RFTC_IFLNAAGCRANGE = 0x0B13,
            MAC_RFTC_LAST_ANACTRL1 = 0x0B14,
            HST_RFTC_OPENLOOPPWRCTRL = 0x0B15,
            HST_RFTC_RFU_0x0B16 = 0x0B16,
            HST_RFTC_RFU_0x0B17 = 0x0B17,
            HST_RFTC_RFU_0x0B18 = 0x0B18,
            HST_RFTC_RFU_0x0B19 = 0x0B19,
            HST_RFTC_PREDIST_COEFF0 = 0x0B1A,
            HST_RFTC_RFU_0x0B1B = 0x0B1B,
            HST_RFTC_RFU_0x0B1C = 0x0B1C,
            HST_RFTC_RFU_0x0B1D = 0x0B1D,
            HST_RFTC_RFU_0x0B1E = 0x0B1E,
            HST_RFTC_RFU_0x0B1F = 0x0B1F,
            HST_RFTC_CAL_GGNEG7 = 0x0B20,
            HST_RFTC_CAL_GGNEG5 = 0x0B21,
            HST_RFTC_CAL_GGNEG3 = 0x0B22,
            HST_RFTC_CAL_GGNEG1 = 0x0B23,
            HST_RFTC_CAL_GGPLUS1 = 0x0B24,
            HST_RFTC_CAL_GGPLUS3 = 0x0B25,
            HST_RFTC_CAL_GGPLUS5 = 0x0B26,
            HST_RFTC_CAL_GGPLUS7 = 0x0B27,
            HST_RFTC_CAL_MACADCREFV = 0x0B28,
            HST_RFTC_CAL_RFFWDPWR_C0 = 0x0B29,
            HST_RFTC_CAL_RFFWDPWR_C1 = 0x0B2A,
            HST_RFTC_CAL_RFFWDPWR_C2 = 0x0B2B,
            HST_RFTC_RFU_0x0B2C = 0x0B2C,
            HST_RFTC_RFU_0x0B2D = 0x0B2D,
            HST_RFTC_RFU_0x0B2E = 0x0B2E,
            HST_RFTC_RFU_0x0B2F = 0x0B2F,
            HST_RFTC_CLKDBLR_CFG = 0x0B30,
            HST_RFTC_CLKDBLR_SEL = 0x0B31,
            HST_RFTC_CLKDBLR_LUTENTRY = 0x0B32,
            HST_RFTC_RFU_0x0B33 = 0x0B33,
            HST_RFTC_RFU_0x0B34 = 0x0B34,
            HST_RFTC_RFU_0x0B35 = 0x0B35,
            HST_RFTC_RFU_0x0B36 = 0x0B36,
            HST_RFTC_RFU_0x0B37 = 0x0B37,
            HST_RFTC_RFU_0x0B38 = 0x0B38,
            HST_RFTC_RFU_0x0B39 = 0x0B39,
            HST_RFTC_RFU_0x0B3A = 0x0B3A,
            HST_RFTC_RFU_0x0B3B = 0x0B3B,
            HST_RFTC_RFU_0x0B3C = 0x0B3C,
            HST_RFTC_RFU_0x0B3D = 0x0B3D,
            HST_RFTC_RFU_0x0B3E = 0x0B3E,
            HST_RFTC_RFU_0x0B3F = 0x0B3F,
            HST_RFTC_FRQHOPMODE = 0x0B40,
            HST_RFTC_FRQHOPENTRYCNT = 0x0B41,
            HST_RFTC_FRQHOPTABLEINDEX = 0x0B42,
            MAC_RFTC_HOPCNT = 0x0B43,
            HST_RFTC_MINHOPDUR = 0x0B44,
            HST_RFTC_MAXHOPDUR = 0x0B45,
            HST_RFTC_FRQHOPRANDSEED = 0x0B46,
            MAC_RFTC_FRQHOPSHFTREGVAL = 0x0B47,
            MAC_RFTC_FRQHOPRANDNUMCNT = 0x0B48,
            HST_RFTC_FRQCHINDEX = 0x0B49,
            HST_RFTC_PLLLOCKTIMEOUT = 0x0B4A,
            HST_RFTC_PLLLOCK_DET_THRSH = 0x0B4B,
            HST_RFTC_PLLLOCK_DET_CNT = 0x0B4C,
            HST_RFTC_PLLLOCK_TO = 0x0B4D,
            HST_RFTC_BERREADDELAY = 0x0B4E,
            HST_RFTC_RFU_0x0B4F = 0x0B4F,
            MAC_RFTC_FWDRFPWRRAWADC = 0x0B50,
            MAC_RFTC_REVRFPWRRAWADC = 0x0B51,
            MAC_RFTC_ANTSENSERAWADC = 0x0B52,
            MAC_RFTC_AMBTEMPRAWADC = 0x0B53,
            MAC_RFTC_PATEMPRAWADC = 0x0B54,
            MAC_RFTC_XCVRTEMPRAWADC = 0x0B55,
            HST_RFTC_RFU_0x0B56 = 0x0B56,
            HST_RFTC_RFU_0x0B57 = 0x0B57,
            HST_RFTC_RFU_0x0B58 = 0x0B58,
            HST_RFTC_RFU_0x0B59 = 0x0B59,
            HST_RFTC_RFU_0x0B5A = 0x0B5A,
            HST_RFTC_RFU_0x0B5B = 0x0B5B,
            HST_RFTC_RFU_0x0B5C = 0x0B5C,
            HST_RFTC_RFU_0x0B5D = 0x0B5D,
            HST_RFTC_RFU_0x0B5E = 0x0B5E,
            HST_RFTC_RFU_0x0B5F = 0x0B5F,
            HST_RFTC_CURRENT_PROFILE = 0x0B60,
            HST_RFTC_PROF_SEL = 0x0B61,
            MAC_RFTC_PROF_CFG = 0x0B62,
            MAC_RFTC_PROF_ID_HIGH = 0x0B63,
            MAC_RFTC_PROF_ID_LOW = 0x0B64,
            MAC_RFTC_PROF_IDVER = 0x0B65,
            MAC_RFTC_PROF_PROTOCOL = 0x0B66,
            MAC_RFTC_PROF_R2TMODTYPE = 0x0B67,
            MAC_RFTC_PROF_TARI = 0x0B68,
            MAC_RFTC_PROF_X = 0x0B69,
            MAC_RFTC_PROF_PW = 0x0B6A,
            MAC_RFTC_PROF_RTCAL = 0x0B6B,
            MAC_RFTC_PROF_TRCAL = 0x0B6C,
            MAC_RFTC_PROF_DIVIDERATIO = 0x0B6D,
            MAC_RFTC_PROF_MILLERNUM = 0x0B6E,
            MAC_RFTC_PROF_T2RLINKFREQ = 0x0B6F,
            MAC_RFTC_PROF_VART2DELAY = 0x0B70,
            MAC_RFTC_PROF_RXDELAY = 0x0B71,
            MAC_RFTC_PROF_MINTOTT2DELAY = 0x0B72,
            MAC_RFTC_PROF_TXPROPDELAY = 0x0B73,
            MAC_RFTC_PROF_RSSIAVECFG = 0x0B74,
            MAC_RFTC_PROF_PREAMCMD = 0x0B75,
            MAC_RFTC_PROF_FSYNCCMD = 0x0B76,
            MAC_RFTC_PROF_T2WAITCMD = 0x0B77,
            HST_RFTC_RFU_0x0B78 = 0x0B78,
            HST_RFTC_RFU_0x0B79 = 0x0B79,
            HST_RFTC_RFU_0x0B7A = 0x0B7A,
            HST_RFTC_RFU_0x0B7B = 0x0B7B,
            HST_RFTC_RFU_0x0B7C = 0x0B7C,
            HST_RFTC_RFU_0x0B7D = 0x0B7D,
            HST_RFTC_RFU_0x0B7E = 0x0B7E,
            HST_RFTC_RFU_0x0B7F = 0x0B7F,
            HST_RFTC_RFU_0x0B80 = 0x0B80,
            HST_RFTC_RFU_0x0B81 = 0x0B81,
            HST_RFTC_RFU_0x0B82 = 0x0B82,
            HST_RFTC_RFU_0x0B83 = 0x0B83,
            HST_RFTC_RFU_0x0B84 = 0x0B84,

            HST_RFTC_FRQCH_ENTRYCNT = 0x0C00,
            HST_RFTC_FRQCH_SEL = 0x0C01,
            HST_RFTC_FRQCH_CFG = 0x0C02,
            HST_RFTC_FRQCH_DESC_PLLDIVMULT = 0x0C03,
            HST_RFTC_FRQCH_DESC_PLLDACCTL = 0x0C04,
            MAC_RFTC_FRQCH_DESC_PLLLOCKSTAT0 = 0x0C05,
            MAC_RFTC_FRQCH_DESC_PLLLOCKSTAT1 = 0x0C06,
            HST_RFTC_FRQCH_DESC_PARFU3 = 0x0C07,
            HST_RFTC_FRQCH_CMDSTART = 0x0C08,

            // for Ucode DNA Tag
            AUTHENTICATE_CFG = 0x0F00,
            AUTHENTICATE_MSG0 = 0x0F01,
            AUTHENTICATE_MSG1 = 0x0F02,
            AUTHENTICATE_MSG2 = 0x0F03,
            AUTHENTICATE_MSG3 = 0x0F04,
            READBUFFER_PTR = 0x0A03,
            READBUFFER_LEN = 0x0A04,
            UNTRACEABLE_CFG = 0x0F05,

            INV_CYCLE_DELAY = 0x0F0F,

            HST_CMD = 0xF000
        }

        internal enum HST_CMD : uint
        {
            NV_MEM_UPDATE = 0x00000001, // Enter NV MEMORY UPDATE mode
            WROEM = 0x00000002, // Write OEM Configuration Area
            RDOEM = 0x00000003, // Read OEM Configuration Area
            ENGTST1 = 0x00000004, // Engineering Test Command #1
            MBPRDREG = 0x00000005, // R1000 firmware by-pass Read Register
            MBPWRREG = 0x00000006, // R1000 firmware by-pass Write Register
            RDGPIO = 0x0000000C, // Read GPIO
            WRGPIO = 0x0000000D, // Write GPIO
            CFGGPIO = 0x0000000E, // Configure GPIO
            INV = 0x0000000F, // ISO 18000-6C Inventory
            READ = 0x00000010, // ISO 18000-6C Read
            WRITE = 0x00000011, // ISO 18000-6C Write
            LOCK = 0x00000012, // ISO 18000-6C Lock
            KILL = 0x00000013, // ISO 18000-6C Kill
            SETPWRMGMTCFG = 0x00000014, // Set Power Management Configuration
            CLRERR = 0x00000015, // Clear Error
            CWON = 0x00000017, // Engineering CMD: Powers up CW
            CWOFF = 0x00000018, // Engineering CMD: Powers down CW
            UPDATELINKPROFILE = 0x00000019, // Changes the Link Profile
            CALIBRATE_GG = 0x0000001B, // Calibrate gross-gain settings
            LPROF_RDXCVRREG = 0x0000001C, // Read R1000 reg associated with given link profile
            LPROF_WRXCVRREG = 0x0000001D, // Write R1000 reg associated with given link profile
            BLOCKERASE = 0x0000001e, // ISO 18000-6C block erase
            BLOCKWRITE = 0x0000001f, // ISO 18000-6C block write
            POPULATE_SPURWATABLE = 0x00000020, // populate a local copy of the spur workaround table
            POPRFTCSENSLUTS = 0x00000021, // map the ADC readings to sensor-appropriate units
            BLOCKPERMALOCK,
            CUSTOMM4QT,
            CUSTOMG2XREADPROTECT,
            CUSTOMG2XRESETREADPROTECT,
            CUSTOMG2XCHANGEEAS,
            CUSTOMG2XEASALARM,
            CUSTOMG2XCHANGECONFIG,
            CUSTOMSLSETPASSWORD,
            CUSTOMSLSETLOGMODE,
            CUSTOMSLSETLOGLIMITS,
            CUSTOMSLGETMEASUREMENTSETUP,
            CUSTOMSLSETSFEPARA,
            CUSTOMSLSETCALDATA,
            CUSTOMSLENDLOG,
            CUSTOMSLSTARTLOG,
            CUSTOMSLGETLOGSTATE,
            CUSTOMSLGETCALDATA,
            CUSTOMSLGETBATLV,
            CUSTOMSLSETSHELFLIFE,
            CUSTOMSLINIT,
            CUSTOMSLGETSENSORVALUE,
            CUSTOMSLOPENAREA,
            CUSTOMSLACCESSFIFO,
            CUSTOMEM4324GETUID,
            CUSTOMEM4325GETUID,
            CUSTOMEMGETSENSORDATA = 0x3B,
            CUSTOMEMRESETALARMS,
            CUSTOMEMSENDSPI,
            AUTHENTICATE = 0x50,
            READBUFFER = 0x51,
            UNTRACEABLE = 0x52,
            CUSTOMMFM13DTREADMEMORY = 0x00000053,
	        CUSTOMMFM13DTWRITEMEMORY = 0x00000054,
	        CUSTOMMFM13DTAUTH = 0x00000055,
	        CUSTOMMFM13DTGETTEMP = 0x00000056,
	        CUSTOMMFM13DTSTARTLOG = 0x00000057,
	        CUSTOMMFM13DTSTOPLOG = 0x00000058,
	        CUSTOMMFM13DTWRITEREG = 0x00000059,
	        CUSTOMMFM13DTREADREG = 0x0000005A,
	        CUSTOMMFM13DTDEEPSLEEP = 0x0000005B,
	        CUSTOMMFM13DTOPMODECHK = 0x0000005C,
	        CUSTOMMFM13DTINITIALREGFILE = 0x0000005D,
	        CUSTOMMFM13DTLEDCTRL = 0x0000005E,
            CMD_END
        }

        /*
        private const int BYTES_PER_LEN_UNIT = 4;

        private const uint INVALID_POWER_VALUE = uint.MaxValue;
        private const uint INVALID_PROFILE_VALUE = uint.MaxValue;
        private const int DATA_FIELD_INDEX = 20;
        private const int RSSI_FIELD_INDEX = 12;
        private const int ANT_FIELD_INDEX = 14;
        private const int MS_FIELD_INDEX = 8;
        private const int RFID_PACKET_COMMON_SIZE = 8;

        private const ushort PC_START_OFFSET = 1;
        private const ushort PC_WORD_LENGTH = 1;
        private const ushort EPC_START_OFFSET = 2;
        private const ushort EPC_WORD_LENGTH = 6;
        private const ushort ACC_PWD_START_OFFSET = 2;
        private const ushort ACC_PWD_WORD_LENGTH = 2;
        private const ushort KILL_PWD_START_OFFSET = 0;
        private const ushort KILL_PWD_WORD_LENGTH = 2;
        private const ushort ONE_WORD_LEN = 1;
        private const ushort TWO_WORD_LEN = 2;

        private const ushort USER_WORD_LENGTH = 1;
        private const uint MAXFRECHANNEL = 50;

        private Result CurrentOperationResult;

        internal CSLibraryOperationParms m_rdr_opt_parms = new CSLibraryOperationParms();
        */

        void Start18K6CRequest_CS108(uint tagStopCount, SelectFlags flags)
        {
            // Set up the rest of the HST_INV_CFG register.  First, we have to read its
            // current value
            UInt32 registerValue = 0;

            MacReadRegister(MACREGISTER.HST_INV_CFG, ref registerValue);
            registerValue &= ~0x0000FFC0U;  // reserver bit 0:5 ~ 16:31

            // TBD - an optimization could be to only write back the register if
            // the value changes

            // Set the tag stop count and enabled flags and then write the register
            // back
            if ((flags & SelectFlags.SELECT) != 0)
            {
                registerValue |= (1 << 14);
            }
            if ((flags & SelectFlags.DISABLE_INVENTORY) != 0)
            {
                registerValue |= (1 << 15);
            }
            registerValue |= tagStopCount << 6;
            MacWriteRegister(MACREGISTER.HST_INV_CFG, registerValue);

            // Set the enabled flag in the HST_INV_EPC_MATCH_CFG register properly.  To
            // do so, have to read the register value first.  Then set the bit properly
            // and then write the register value back to the MAC.
            MacReadRegister(MACREGISTER.HST_INV_EPC_MATCH_CFG, ref registerValue);
            if ((flags & SelectFlags.POST_MATCH) != 0)
            {
                registerValue |= 0x01;
            }
            else
            {
                registerValue &= ~(uint)0x01; ;
            }

            MacWriteRegister(MACREGISTER.HST_INV_EPC_MATCH_CFG, registerValue);
        } // Radio::Start18K6CRequest

        /*
				public int CUST_18K6CTagWrite(uint bank, uint offset, uint count, UInt16[] data, uint accessPassword, uint retry, SelectFlags flags)
				{
					// Perform the common 18K6C tag operation setup
					Start18K6CRequest(retry, flags);

					Setup18K6CReadRegisters(bank, offset, count);

					// Set up the access password register
					MacWriteRegister(MACREGISTER.HST_TAGACC_ACCPWD, accessPassword);

					// Issue the read command
					_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.WRITE), (UInt32)SENDREMARK.EXECCMD);

					return 0;
				}
		*/

        private void TagLockThreadProc_CS108()
        {
            const uint HST_TAGACC_LOCKCFG_MASK_USE_PWD_ACTION = 0x1;
            const uint HST_TAGACC_LOCKCFG_MASK_USE_PERMA_ACTION = 0x2;

            /* HST_TAGACC_LOCKCFG register helper macros                                */
            /* The size of the bit fields in the HST_TAGACC_LOCKCFG register.           */
            const byte HST_TAGACC_LOCKCFG_ACTION_USER_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_ACTION_TID_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_ACTION_EPC_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_ACTION_ACC_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_ACTION_KILL_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_MASK_USER_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_MASK_TID_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_MASK_EPC_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_MASK_ACC_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_MASK_KILL_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_RFU1_SIZE = 12;

            const byte HST_TAGACC_LOCKCFG_ACTION_USER_SHIFT = 0;
            const byte HST_TAGACC_LOCKCFG_ACTION_TID_SHIFT = (HST_TAGACC_LOCKCFG_ACTION_USER_SHIFT + HST_TAGACC_LOCKCFG_ACTION_USER_SIZE);
            const byte HST_TAGACC_LOCKCFG_ACTION_EPC_SHIFT = (HST_TAGACC_LOCKCFG_ACTION_TID_SHIFT + HST_TAGACC_LOCKCFG_ACTION_TID_SIZE);
            const byte HST_TAGACC_LOCKCFG_ACTION_ACC_SHIFT = (HST_TAGACC_LOCKCFG_ACTION_EPC_SHIFT + HST_TAGACC_LOCKCFG_ACTION_EPC_SIZE);
            const byte HST_TAGACC_LOCKCFG_ACTION_KILL_SHIFT = (HST_TAGACC_LOCKCFG_ACTION_ACC_SHIFT + HST_TAGACC_LOCKCFG_ACTION_ACC_SIZE);
            const byte HST_TAGACC_LOCKCFG_MASK_USER_SHIFT = (HST_TAGACC_LOCKCFG_ACTION_KILL_SHIFT + HST_TAGACC_LOCKCFG_ACTION_KILL_SIZE);
            const byte HST_TAGACC_LOCKCFG_MASK_TID_SHIFT = (HST_TAGACC_LOCKCFG_MASK_USER_SHIFT + HST_TAGACC_LOCKCFG_MASK_USER_SIZE);
            const byte HST_TAGACC_LOCKCFG_MASK_EPC_SHIFT = (HST_TAGACC_LOCKCFG_MASK_TID_SHIFT + HST_TAGACC_LOCKCFG_MASK_TID_SIZE);
            const byte HST_TAGACC_LOCKCFG_MASK_ACC_SHIFT = (HST_TAGACC_LOCKCFG_MASK_EPC_SHIFT + HST_TAGACC_LOCKCFG_MASK_EPC_SIZE);
            const byte HST_TAGACC_LOCKCFG_MASK_KILL_SHIFT = (HST_TAGACC_LOCKCFG_MASK_ACC_SHIFT + HST_TAGACC_LOCKCFG_MASK_ACC_SIZE);
            const byte HST_TAGACC_LOCKCFG_RFU1_SHIFT = (HST_TAGACC_LOCKCFG_MASK_KILL_SHIFT + HST_TAGACC_LOCKCFG_MASK_KILL_SIZE);

            /* Constants for HST_TAGACC_LOCKCFG register bit fields (note that the      */
            /* values are already shifted into the low-order bits of the constant.      */
            const uint HST_TAGACC_LOCKCFG_ACTION_MEM_WRITE = 0x0;
            const uint HST_TAGACC_LOCKCFG_ACTION_MEM_PERM_WRITE = 0x1;
            const uint HST_TAGACC_LOCKCFG_ACTION_MEM_SEC_WRITE = 0x2;
            const uint HST_TAGACC_LOCKCFG_ACTION_MEM_NO_WRITE = 0x3;
            const uint HST_TAGACC_LOCKCFG_ACTION_PWD_ACCESS = 0x0;
            const uint HST_TAGACC_LOCKCFG_ACTION_PWD_PERM_ACCESS = 0x1;
            const uint HST_TAGACC_LOCKCFG_ACTION_PWD_SEC_ACCESS = 0x2;
            const uint HST_TAGACC_LOCKCFG_ACTION_PWD_NO_ACCESS = 0x3;
            const uint HST_TAGACC_LOCKCFG_MASK_USE_NO_ACTION = 0x0;

            const uint HST_TAGACC_LOCKCFG_MASK_USE_BOTH_ACTION = (HST_TAGACC_LOCKCFG_MASK_USE_PWD_ACTION | HST_TAGACC_LOCKCFG_MASK_USE_PERMA_ACTION);

            const uint RFID_18K6C_TAG_PWD_PERM_ACCESSIBLE = 0x0;
            const uint RFID_18K6C_TAG_PWD_PERM_ALWAYS_NOT_ACCESSIBLE = 0x1;
            const uint RFID_18K6C_TAG_PWD_PERM_ALWAYS_ACCESSIBLE = 0x2;
            const uint RFID_18K6C_TAG_PWD_PERM_SECURED_ACCESSIBLE = 0x3;
            const uint RFID_18K6C_TAG_PWD_PERM_NO_CHANGE = 0x4;

            const uint RFID_18K6C_TAG_MEM_PERM_WRITEABLE = 0x0;             //unlock		00
            const uint RFID_18K6C_TAG_MEM_PERM_ALWAYS_NOT_WRITEABLE = 0x1;  //permlock		01
            const uint RFID_18K6C_TAG_MEM_PERM_ALWAYS_WRITEABLE = 0x2;      //permunlock	10
            const uint RFID_18K6C_TAG_MEM_PERM_SECURED_WRITEABLE = 0x3;     //lock			11
            const uint RFID_18K6C_TAG_MEM_PERM_NO_CHANGE = 0x4;


            m_Result = Result.FAILURE;

            UInt32 registerValue = 0;

            Start18K6CRequest(1, m_rdr_opt_parms.TagLock.flags);

            if (m_rdr_opt_parms.TagLock.permanentLock)
            {
                registerValue = 0xfffff;
            }
            else
            {

                if (RFID_18K6C_TAG_PWD_PERM_NO_CHANGE == (uint)m_rdr_opt_parms.TagLock.killPasswordPermissions)
                {
                    registerValue |= (HST_TAGACC_LOCKCFG_MASK_USE_NO_ACTION << HST_TAGACC_LOCKCFG_MASK_KILL_SHIFT);
                }
                // Otherwise, indicate to look at the kill password bits and set the
                // persmission for it
                else
                {
                    registerValue |= (HST_TAGACC_LOCKCFG_MASK_USE_BOTH_ACTION << HST_TAGACC_LOCKCFG_MASK_KILL_SHIFT);
                    registerValue |= ((uint)m_rdr_opt_parms.TagLock.killPasswordPermissions << HST_TAGACC_LOCKCFG_ACTION_KILL_SHIFT);
                }

                // If the access password access permissions are not to change, then
                // indicate to ignore those bits.
                if (RFID_18K6C_TAG_PWD_PERM_NO_CHANGE == (uint)m_rdr_opt_parms.TagLock.accessPasswordPermissions)
                {
                    registerValue |= HST_TAGACC_LOCKCFG_MASK_USE_NO_ACTION << HST_TAGACC_LOCKCFG_MASK_ACC_SHIFT;
                }
                // Otherwise, indicate to look at the access password bits and set the
                // persmission for it
                else
                {
                    registerValue |= HST_TAGACC_LOCKCFG_MASK_USE_BOTH_ACTION << HST_TAGACC_LOCKCFG_MASK_ACC_SHIFT;
                    registerValue |= (uint)m_rdr_opt_parms.TagLock.accessPasswordPermissions << HST_TAGACC_LOCKCFG_ACTION_ACC_SHIFT;
                }

                // If the EPC memory access permissions are not to change, then indicate
                // to ignore those bits.
                if (RFID_18K6C_TAG_MEM_PERM_NO_CHANGE == (uint)m_rdr_opt_parms.TagLock.epcMemoryBankPermissions)
                {
                    registerValue |= HST_TAGACC_LOCKCFG_MASK_USE_NO_ACTION << HST_TAGACC_LOCKCFG_MASK_EPC_SHIFT;
                }
                // Otherwise, indicate to look at the EPC memory bits and set the
                // persmission for it
                else
                {
                    registerValue |= HST_TAGACC_LOCKCFG_MASK_USE_BOTH_ACTION << HST_TAGACC_LOCKCFG_MASK_EPC_SHIFT;
                    registerValue |= (uint)m_rdr_opt_parms.TagLock.epcMemoryBankPermissions << HST_TAGACC_LOCKCFG_ACTION_EPC_SHIFT;
                }

                // If the TID memory access permissions are not to change, then indicate
                // to ignore those bits.
                if (RFID_18K6C_TAG_MEM_PERM_NO_CHANGE == (uint)m_rdr_opt_parms.TagLock.tidMemoryBankPermissions)
                {
                    registerValue |= HST_TAGACC_LOCKCFG_MASK_USE_NO_ACTION << HST_TAGACC_LOCKCFG_MASK_TID_SHIFT;
                }
                // Otherwise, indicate to look at the TID memory bits and set the
                // persmission for it
                else
                {
                    registerValue |= HST_TAGACC_LOCKCFG_MASK_USE_BOTH_ACTION << HST_TAGACC_LOCKCFG_MASK_TID_SHIFT;
                    registerValue |= (uint)m_rdr_opt_parms.TagLock.tidMemoryBankPermissions << HST_TAGACC_LOCKCFG_ACTION_TID_SHIFT;
                }

                // If the user memory access permissions are not to change, then indicate
                // to ignore those bits.
                if (RFID_18K6C_TAG_MEM_PERM_NO_CHANGE == (uint)m_rdr_opt_parms.TagLock.userMemoryBankPermissions)
                {
                    registerValue |= HST_TAGACC_LOCKCFG_MASK_USE_NO_ACTION << HST_TAGACC_LOCKCFG_MASK_USER_SHIFT;
                }
                // Otherwise, indicate to look at the user memory bits and set the
                // persmission for it
                else
                {
                    registerValue |= HST_TAGACC_LOCKCFG_MASK_USE_BOTH_ACTION << HST_TAGACC_LOCKCFG_MASK_USER_SHIFT;
                    registerValue |= (uint)m_rdr_opt_parms.TagLock.userMemoryBankPermissions << HST_TAGACC_LOCKCFG_ACTION_USER_SHIFT;
                }
            }

            // Set up the lock configuration register
            MacWriteRegister(MACREGISTER.HST_TAGACC_LOCKCFG, registerValue);

            // Set up the access password register
            MacWriteRegister(MACREGISTER.HST_TAGACC_ACCPWD, m_rdr_opt_parms.TagLock.accessPassword);

            // Set up the HST_TAGACC_DESC_CFG register (controls the verify and retry
            // count) and write it to the MAC
            //m_pMac->WriteRegister(HST_TAGACC_DESC_CFG, HST_TAGACC_DESC_CFG_RETRY(0));

            // Issue the lock command
            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.LOCK), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (UInt32)CurrentOperation);
        }

        private void TagBlockLockThreadProc_CS108()
        {
            const UInt32 RFID_NUM_TAGWRDAT_REGS_PER_BANK = 16;

            // Perform the common 18K6C tag operation setup
            //this->Start18K6CRequest(&pBWParms->common, flags);
            Start18K6CRequest(1, Options.TagBlockLock.flags);

            // Set the tag access descriptor to the first one just to be safe
            MacWriteRegister(MACREGISTER.HST_TAGACC_DESC_SEL, 0);

            // Set the tag write data select register to zero
            MacWriteRegister(MACREGISTER.HST_TAGWRDAT_SEL, 0x0000);

            // Set up the HST_TAGACC_DESC_CFG register (controls the verify and retry
            // count) and write it to the MAC
            /*INT32U  registerValue = 
            (pBWParms->verify ? HST_TAGACC_DESC_CFG_VERIFY_ENABLED :
            HST_TAGACC_DESC_CFG_VERIFY_DISABLED)  |
            HST_TAGACC_DESC_CFG_RETRY(pBWParms->verifyRetryCount)     | 
            HST_TAGACC_DESC_CFG_RFU1(0);
            m_pMac->WriteRegister(HST_TAGACC_DESC_CFG, registerValue);*/

            //INT16U count = pBWParms->permalockCmdParms.count;
            //INT16U offset = pBWParms->permalockCmdParms.offset;
            //BOOL32 readOrLock = pBWParms->permalockCmdParms.readOrLock;
            //const INT16U* pData = pBWParms->permalockCmdParms.pData;

            // Set up the tag bank register (tells where to write the data)
            MacWriteRegister(MACREGISTER.HST_TAGACC_BANK, 0x03);

            //Set up the access offset register (i.e., number of words to lock)
            MacWriteRegister(MACREGISTER.HST_TAGACC_PTR, Options.TagBlockLock.offset);

            // Set up the access count register (i.e., number of words to lock)
            MacWriteRegister(MACREGISTER.HST_TAGACC_CNT, Options.TagBlockLock.count);

            // Set up the tag access password
            MacWriteRegister(MACREGISTER.HST_TAGACC_ACCPWD, Options.TagBlockLock.accessPassword);

            MacWriteRegister(MACREGISTER.HST_TAGACC_LOCKCFG, (Options.TagBlockLock.setPermalock ? (1U << 20) : 0x0000U));

            UInt16 count = 0;
            UInt16 offset = Options.TagBlockLock.offset;

            if (Options.TagBlockLock.setPermalock)
            {
                // Set up the HST_TAGWRDAT_N registers.  Fill up a bank at a time.
                for (UInt32 registerBank = 0; count < Options.TagBlockLock.count; ++registerBank)
                {
                    // Indicate which bank of tag write registers we are going to fill
                    MacWriteRegister(MACREGISTER.HST_TAGWRDAT_SEL, registerBank);

                    /*
                    if (HOSTIF_ERR_SELECTORBNDS == MacReadRegister(MAC_ERROR))
                    {
                        this->ClearMacError();
                        throw RfidErrorException(RFID_ERROR_INVALID_PARAMETER);
                    }
                    */

                    // Write the values to the bank until either the bank is full or we get to
                    // a point where we cannot fill a register (i.e., we have 0 or 1 words left)
                    offset = 0;
                    for (; (offset < RFID_NUM_TAGWRDAT_REGS_PER_BANK) && (count < (Options.TagBlockLock.count - 1)); ++offset)
                    {
                        MacWriteRegister((MACREGISTER)((int)MACREGISTER.HST_TAGWRDAT_0 + offset), (uint)((Options.TagBlockLock.mask[count] << 16) | Options.TagBlockLock.mask[count + 1]));
                        count += 2;
                    }

                    // If we didn't use all registers in the bank and count is non-zero, it means
                    // that the request was for an odd number of words to be written.  Make sure
                    // that the last word is written.
                    if ((offset < RFID_NUM_TAGWRDAT_REGS_PER_BANK) && (count < Options.TagBlockLock.count))
                    {
                        MacWriteRegister((MACREGISTER)((int)MACREGISTER.HST_TAGWRDAT_0 + offset), (uint)((Options.TagBlockLock.mask[count] << 16)));
                        //MacWriteRegister(MacRegister.HST_TAGWRDAT_0 + offset, HST_TAGWRDAT_N_DATA0(*pData) | HST_TAGWRDAT_N_DATA1(0));
                        break;
                    }
                }
            }

            // Issue the write command to the MAC
            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.BLOCKPERMALOCK), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE);
            //m_Result = COMM_HostCommand(HST_CMD.BLOCKPERMALOCK);


            /*			if (m_Result == Result.OK && !Options.TagBlockLock.setPermalock)
						{
							Options.TagBlockLock.mask = new ushort[Options.TagBlockLock.count];
							Array.Copy(tagreadbuf, Options.TagBlockLock.mask, Options.TagBlockLock.count);
						}
			*/
        }

        ////////////////////////////////////////////////////////////////////////////////
        // Name: RFID_18K6CTagKill
        //
        // Description:
        //   Executes a tag kill for the tags of interest.  If the
        //   RFID_FLAG_PERFORM_SELECT flag is specified, the tag population is
        //   partitioned (i.e., ISO 18000-6C select) prior to the tag-kill operation.
        //   If the RFID_FLAG_PERFORM_POST_MATCH flag is specified, the post-singulation
        //   match mask is applied to a singulated tag's EPC to determine if the tag
        //   will be killed.  The operation-response packets will be returned to the
        //   application via the application-supplied callback function.  Each tag-kill
        //   record is grouped with its corresponding tag-inventory record.  An
        //   application may prematurely stop a kill operation by calling
        //   RFID_Radio{Cancel|Aobrt}Operation on another thread or by returning a non-
        //   zero value from the callback function.
        ////////////////////////////////////////////////////////////////////////////////
        private bool RFID_18K6CTagKill_CS108()
        {
            // Perform the common 18K6C tag operation setup
            Start18K6CRequest(1, m_rdr_opt_parms.TagKill.flags);

            // Set up the access password register
            MacWriteRegister(MACREGISTER.HST_TAGACC_ACCPWD, m_rdr_opt_parms.TagKill.accessPassword);

            // Set up the kill password register
            MacWriteRegister(MACREGISTER.HST_TAGACC_KILLPWD, m_rdr_opt_parms.TagKill.killPassword);

            // Set up the kill extended register
            MacWriteRegister(MACREGISTER.HST_TAGACC_LOCKCFG, (0x7U & (uint)m_rdr_opt_parms.TagKill.extCommand) << 21);

            // Set up the HST_TAGACC_DESC_CFG register (controls the verify and retry
            // count) and write it to the MAC
            //m_pMac->WriteRegister(HST_TAGACC_DESC_CFG, HST_TAGACC_DESC_CFG_RETRY(7));

            // Issue the kill command
            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.KILL), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.TAG_KILL);
            //if (COMM_HostCommand(HST_CMD.KILL) != Result.OK || CurrentOperationResult != Result.OK)
            //	return false;

            return true;
        } // RFID_18K6CTagKill

        private void TagKillThreadProc_CS108()
        {
            ushort[] tmp = new ushort[1];

            RFID_18K6CTagKill_CS108();

#if oldcode
            if (RFID_18K6CTagKill())
            {
                if (CUST_18K6CTagRead(
                    MemoryBank.EPC,
                    EPC_START_OFFSET,
                    1,
                    tmp,
                    m_rdr_opt_parms.TagKill.accessPassword,
                    //m_rdr_opt_parms.TagKill.retryCount,
                    SelectFlags.SELECT) != true)
                {
                    //can't read mean killed
                    m_Result = Result.OK;
                    return;
                }
            }
            //FireAccessCompletedEvent(new OnAccessCompletedEventArgs(m_Result == Result.OK, Bank.UNKNOWN, TagAccess.KILL, null));
            //FireStateChangedEvent(RFState.IDLE);
#endif
        }

        private void TagAuthenticateThreadProc_CS108()
        {
            UInt32 value = 0;
            UInt32[] m_data;

            if (m_rdr_opt_parms.TagAuthenticate.Message.Length > 32)
            {
                m_Result = Result.INVALID_PARAMETER;
                return;
            }


            // Set up the access password register
            MacWriteRegister(MACREGISTER.HST_TAGACC_ACCPWD, m_rdr_opt_parms.TagAuthenticate.password);
            value |= (UInt32)m_rdr_opt_parms.TagAuthenticate.SenRep & 0x01;
            value |= ((UInt32)m_rdr_opt_parms.TagAuthenticate.IncRepLen & 0x01) << 1;
            value |= ((UInt32)m_rdr_opt_parms.TagAuthenticate.CSI & 0xff) << 2;
            value |= ((UInt32)m_rdr_opt_parms.TagAuthenticate.Length & 0xFFF) << 10;

            string NewMessage = m_rdr_opt_parms.TagAuthenticate.Message + new String('0', 32 - m_rdr_opt_parms.TagAuthenticate.Message.Length);

            m_data = CSLibrary.Tools.Hex.ToUInt32s(NewMessage);

            MacWriteRegister(MACREGISTER.AUTHENTICATE_CFG, value);
            MacWriteRegister(MACREGISTER.AUTHENTICATE_MSG0, m_data[0]);
            MacWriteRegister(MACREGISTER.AUTHENTICATE_MSG1, m_data[1]);
            MacWriteRegister(MACREGISTER.AUTHENTICATE_MSG2, m_data[2]);
            MacWriteRegister(MACREGISTER.AUTHENTICATE_MSG3, m_data[3]);

            Start18K6CRequest(1, CSLibrary.Constants.SelectFlags.SELECT);

            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.AUTHENTICATE), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (UInt32)CurrentOperation);
            m_Result = Result.OK;
            return;
        }

        private void TagReadBufferThreadProc_CS108()
        {
            MacWriteRegister(MACREGISTER.READBUFFER_PTR, m_rdr_opt_parms.TagReadBuffer.Offset);
            MacWriteRegister(MACREGISTER.READBUFFER_LEN, (UInt32)(m_rdr_opt_parms.TagReadBuffer.Length & 0xfff));

            Start18K6CRequest(1, CSLibrary.Constants.SelectFlags.SELECT);

            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.READBUFFER), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE);
            m_Result = Result.OK;
            return;
        }

        private void TagUntraceableThreadProc_CS108()
        {
            UInt32 value = 0;

            if (m_rdr_opt_parms.TagUntraceable.EPCLength >= 32)
            {
                m_Result = Result.INVALID_PARAMETER;
                return;
            }

            value |= (UInt32)m_rdr_opt_parms.TagUntraceable.Range;
            value |= ((UInt32)m_rdr_opt_parms.TagUntraceable.User << 2);
            value |= ((UInt32)m_rdr_opt_parms.TagUntraceable.TID << 3);
            value |= ((UInt32)m_rdr_opt_parms.TagUntraceable.EPC << 10);
            value |= ((UInt32)m_rdr_opt_parms.TagUntraceable.EPCLength << 5);
            value |= ((UInt32)m_rdr_opt_parms.TagUntraceable.U << 11);

            MacWriteRegister( MACREGISTER.UNTRACEABLE_CFG, value);

            Start18K6CRequest(1, CSLibrary.Constants.SelectFlags.SELECT);

            // Issue the untraceable command
            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.UNTRACEABLE), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (UInt32)CurrentOperation);
            m_Result = Result.OK;
            return;
        }


        private bool FM13DTReadMemoryThreadProc_CS108()
        {
            if (m_rdr_opt_parms.FM13DTReadMemory.offset > 0xffff)
                return false;

            FM13DT160_ReadMemory(m_rdr_opt_parms.FM13DTReadMemory.offset, m_rdr_opt_parms.FM13DTReadMemory.count);
            return true;
        }

        private bool FM13DTWriteMemoryThreadProc_CS108()
        {
            if (m_rdr_opt_parms.FM13DTWriteMemory.offset > 0xffff)
                return false;

            FM13DT160_WriteMemory(m_rdr_opt_parms.FM13DTWriteMemory.offset, m_rdr_opt_parms.FM13DTWriteMemory.data);
            return true;
        }

        private bool FM13DTReadRegThreadProc_CS108()
        {
            if (m_rdr_opt_parms.FM13DTReadMemory.offset > 0xffff)
                return false;

            FM13DT160_ReadMemory(m_rdr_opt_parms.FM13DTReadMemory.offset, m_rdr_opt_parms.FM13DTReadMemory.count);
            return true;
        }

        private bool FM13DTWriteRegThreadProc_CS108()
        {
            if (m_rdr_opt_parms.FM13DTWriteMemory.offset > 0xffff)
                return false;

            FM13DT160_WriteMemory(m_rdr_opt_parms.FM13DTWriteMemory.offset, m_rdr_opt_parms.FM13DTWriteMemory.data);
            return true;
        }

        private bool FM13DTAuthThreadProc_CS108()
        {
//            FM13DT160_Auth(m_rdr_opt_parms.FM FM13DTWriteMemory.offset, m_rdr_opt_parms.FM13DTWriteMemory.count);
            return true;
        }

        private bool FM13DTGetTempThreadProc_CS108()
        {
            //FM13DT160_GetTemp(m_rdr_opt_parms.FM13DTWriteMemory.offset, m_rdr_opt_parms.FM13DTWriteMemory.count, m_rdr_opt_parms.FM13DTWriteMemory.data);
            return true;
        }
        private bool FM13DTStartLogThreadProc_CS108()
        {
            FM13DT160_StartLog();
            return true;
        }
        private bool FM13DTStopLogChkThreadProc_CS108()
        {
            FM13DT160_StopLog(m_rdr_opt_parms.FM13DTWriteMemory.offset);
            return true;
        }
        private bool FM13DTDeepSleepThreadProc_CS108()
        {
            FM13DT160_DeepSleep(true);
            return true;
        }
        private bool FM13DTOpModeChkThreadProc_CS108()
        {
            FM13DT160_OpModeChk(m_rdr_opt_parms.FM13DTOpModeChk.enable);
            return true;
        }
        private bool FM13DTInitialRegFileThreadProc_CS108()
        {
            FM13DT160_InitialRegFile();
            return true;
        }

        private bool FM13DTLedCtrlThreadProc_CS108()
        {
            FM13DT160_LedCtrl(m_rdr_opt_parms.FM13DTLedCtrl.enable);
            return true;
        }

        /// <summary>
        /// rfid reader packet
        /// </summary>
        /// <param name="RW"></param>
        /// <param name="add"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        internal byte[] PacketData_CS108(UInt16 add, UInt32? value = null)
        {
            byte[] CMDBuf = new byte[8];

            if (value == null)
            {
                CMDBuf[1] = 0x00;
                CMDBuf[4] = 0x00;
                CMDBuf[5] = 0x00;
                CMDBuf[6] = 0x00;
                CMDBuf[7] = 0x00;
            }
            else
            {
                CMDBuf[1] = 0x01;
                CMDBuf[4] = (byte)value;
                CMDBuf[5] = (byte)(value >> 8);
                CMDBuf[6] = (byte)(value >> 16);
                CMDBuf[7] = (byte)(value >> 24);
            }

            CMDBuf[0] = 0x70;
            CMDBuf[2] = (byte)add;
            CMDBuf[3] = (byte)((uint)add >> 8);

            return CMDBuf;
        }

        private Result MacReadOemData(UInt32 address, ref UInt32 value)
        {
            MacWriteRegister(MACREGISTER.HST_OEM_ADDR, address);

            // Issue read OEM command
            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.RDOEM), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1_COMMANDENDRESPONSE, (UInt32)0xffffffff);

            return Result.OK;
        }

        private Result MacWriteOemData(uint address, uint value)
        {
            MacWriteRegister(MACREGISTER.HST_OEM_ADDR, address);
            MacWriteRegister(MACREGISTER.HST_OEM_DATA, value);

            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.WROEM), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (UInt32)0xffffffff);

            return Result.OK;
        }

        private Result MacWriteOemData(uint address, uint [] value)
        {
            return Result.CURRENTLY_NOT_ALLOWED;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Private.FrequencyChannel.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    using static FrequencyBand;
    using Constants;

    public partial class RFIDReader
    {
        private uint[] currentInventoryFreqRevIndex = null;

        #region ====================== Frequency Table ======================

        #region FCC (-2)
        /// <summary>
        /// FCC Frequency Table
        /// </summary>
        private readonly double[] FCCTableOfFreq = new double[]
            {
                902.75,//0
                903.25,//1
                903.75,
                904.25,
                904.75,
                905.25,//5
                905.75,
                906.25,
                906.75,
                907.25,
                907.75,//10
                908.25,
                908.75,
                909.25,
                909.75,
                910.25,//15
                910.75,
                911.25,
                911.75,
                912.25,
                912.75,//20
                913.25,
                913.75,
                914.25,
                914.75,
                915.25,//25
                915.75,
                916.25,
                916.75,
                917.25,
                917.75,//30
                918.25,
                918.75,
                919.25,
                919.75,
                920.25,//35
                920.75,
                921.25,
                921.75,
                922.25,
                922.75,//40
                923.25,
                923.75,
                924.25,
                924.75,
                925.25,//45
                925.75,
                926.25,
                926.75,
                927.25,//49
            };
        /*OK*/
        private uint[] fccFreqTable = new uint[]
        {
            0x00180E1F, /*903.75 MHz  2 */
            0x00180E41, /*912.25 MHz  19 */
            0x00180E2F, /*907.75 MHz  10 */
            0x00180E39, /*910.25 MHz  15 */
            0x00180E6B, /*922.75 MHz  40 */
            0x00180E6D, /*923.25 MHz  41 */
            0x00180E6F, /*923.75 MHz  42 */
            0x00180E4D, /*915.25 MHz  25 */
            0x00180E35, /*909.25 MHz  13 */
            0x00180E43, /*912.75 MHz  20 */
            0x00180E3B, /*910.75 MHz  16 */
            0x00180E47, /*913.75 MHz  22 */
            0x00180E37, /*909.75 MHz  14 */
            0x00180E25, /*905.25 MHz  5 */
            0x00180E3F, /*911.75 MHz  18 */
            0x00180E1B, /*902.75 MHz  0 */
            0x00180E49, /*914.25 MHz  23 */
            0x00180E59, /*918.25 MHz  31 */
            0x00180E79, /*926.25 MHz  47 */
            0x00180E77, /*925.75 MHz  46 */
            0x00180E63, /*920.75 MHz  36 */
            0x00180E61, /*920.25 MHz  35 */
            0x00180E2D, /*907.25 MHz  9 */
            0x00180E4B, /*914.75 MHz  24 */
            0x00180E5F, /*919.75 MHz  34 */
            0x00180E69, /*922.25 MHz  39 */
            0x00180E1D, /*903.25 MHz  1 */
            0x00180E29, /*906.25 MHz  7 */
            0x00180E27, /*905.75 MHz  6 */
            0x00180E7B, /*926.75 MHz  48 */
            0x00180E71, /*924.25 MHz  43 */
            0x00180E23, /*904.75 MHz  4 */
            0x00180E75, /*925.25 MHz  45 */
            0x00180E73, /*924.75 MHz  44 */
            0x00180E5D, /*919.25 MHz  33 */
            0x00180E53, /*916.75 MHz  28 */
            0x00180E3D, /*911.25 MHz  17 */
            0x00180E65, /*921.25 MHz  37 */
            0x00180E31, /*908.25 MHz  11 */
            0x00180E33, /*908.75 MHz  12 */
            0x00180E45, /*913.25 MHz  21 */
            0x00180E51, /*916.25 MHz  27 */
            0x00180E21, /*904.25 MHz  3 */
            0x00180E2B, /*906.75 MHz  8 */
            0x00180E57, /*917.75 MHz  30 */
            0x00180E67, /*921.75 MHz  38 */
            0x00180E55, /*917.25 MHz  29 */
            0x00180E7D, /*927.25 MHz  49 */
            0x00180E5B, /*918.75 MHz  32 */
            0x00180E4F, /*915.75 MHz  26 */
        };
        /// <summary>
        /// FCC Frequency Channel number
        /// </summary>
        private const uint FCC_CHN_CNT = 50;
        private readonly uint[] fccFreqSortedIdx = new uint[]{
            2, 19, 10, 15, 40,
            41, 42, 25, 13, 20,
            16, 22, 14, 5, 18,
            0, 23, 31, 47, 46,
            36, 35, 9, 24, 34,
            39, 1, 7, 6, 48,
            43, 4, 45, 44, 33,
            28, 17, 37, 11, 12,
            21, 27, 3, 8, 30,
            38, 29, 49, 32, 26
        };

        private uint[] fccFreqTable_Ver20170001 = new uint[]
        {
            0x00180E4D, /*915.25 MHz  25 */
            0x00180E63, /*920.75 MHz  36 */
            0x00180E35, /*909.25 MHz  13 */
            0x00180E41, /*912.25 MHz  19 */
            0x00180E59, /*918.25 MHz  31 */
            0x00180E61, /*920.25 MHz  35 */
            0x00180E37, /*909.75 MHz  14 */
            0x00180E39, /*910.25 MHz  15 */
            0x00180E5F, /*919.75 MHz  34 */
            0x00180E6B, /*922.75 MHz  40 */
            0x00180E33, /*908.75 MHz  12 */
            0x00180E47, /*913.75 MHz  22 */
            0x00180E1F, /*903.75 MHz  2 */
            0x00180E5D, /*919.25 MHz  33 */
            0x00180E69, /*922.25 MHz  39 */
            0x00180E2F, /*907.75 MHz  10 */
            0x00180E3F, /*911.75 MHz  18 */
            0x00180E6F, /*923.75 MHz  42 */
            0x00180E53, /*916.75 MHz  28 */
            0x00180E79, /*926.25 MHz  47 */
            0x00180E31, /*908.25 MHz  11 */
            0x00180E43, /*912.75 MHz  20 */
            0x00180E71, /*924.25 MHz  43 */
            0x00180E51, /*916.25 MHz  27 */
            0x00180E7D, /*927.25 MHz  49 */
            0x00180E2D, /*907.25 MHz  9 */
            0x00180E3B, /*910.75 MHz  16 */
            0x00180E1D, /*903.25 MHz  1 */
            0x00180E57, /*917.75 MHz  30 */
            0x00180E7B, /*926.75 MHz  48 */
            0x00180E25, /*905.25 MHz  5 */
            0x00180E3D, /*911.25 MHz  17 */
            0x00180E73, /*924.75 MHz  44 */
            0x00180E55, /*917.25 MHz  29 */
            0x00180E77, /*925.75 MHz  46 */
            0x00180E2B, /*906.75 MHz  8 */
            0x00180E49, /*914.25 MHz  23 */
            0x00180E23, /*904.75 MHz  4 */
            0x00180E5B, /*918.75 MHz  32 */
            0x00180E6D, /*923.25 MHz  41 */
            0x00180E1B, /*902.75 MHz  0 */
            0x00180E4B, /*914.75 MHz  24 */
            0x00180E27, /*905.75 MHz  6 */
            0x00180E4F, /*915.75 MHz  26 */
            0x00180E75, /*925.25 MHz  45 */
            0x00180E29, /*906.25 MHz  7 */
            0x00180E65, /*921.25 MHz  37 */
            0x00180E45, /*913.25 MHz  21 */
            0x00180E67, /*921.75 MHz  38 */
            0x00180E21, /*904.25 MHz  3 */
        };

        private readonly uint[] fccFreqSortedIdx_Ver20170001 = new uint[]{
            25, 36, 13, 19, 31,
            35, 14, 15, 34, 40,
            12, 22, 2, 33, 39,
            10, 18, 42, 28, 47,
            11, 20, 43, 27, 49,
            9, 16, 1, 30, 48,
            5, 17, 44, 29, 46,
            8, 23, 4, 32, 41,
            0, 24, 6, 26, 45,
            7, 37, 21, 38, 3
        };

        #endregion

        #region South Africa
        /// <summary>
        /// South Africa Frequency Table
        /// </summary>
        private readonly double[] ZATableOfFreq = new double[]
            {
                915.7,
                915.9,
                916.1,
                916.3,
                916.5,
                916.7,
                916.9,
                917.1,
                917.3,
                917.5,
                917.7,
                917.9,
                918.1,
                918.3,
                918.5,
                918.7,
            };
        /*OK*/
        private uint[] zaFreqTable = new uint[]
        {
            0x003C23C5, /*915.7 MHz   */ 
            0x003C23C7, /*915.9 MHz   */
            0x003C23C9, /*916.1 MHz   */
            0x003C23CB, /*916.3 MHz   */
            0x003C23CD, /*916.5 MHz   */
            0x003C23CF, /*916.7 MHz   */
            0x003C23D1, /*916.9 MHz   */
            0x003C23D3, /*917.1 MHz   */
            0x003C23D5, /*917.3 MHz   */
            0x003C23D7, /*917.5 MHz   */
            0x003C23D9, /*917.7 MHz   */
            0x003C23DB, /*917.9 MHz   */
            0x003C23DD, /*918.1 MHz   */
            0x003C23DF, /*918.3 MHz   */
            0x003C23E1, /*918.5 MHz   */
            0x003C23E3, /*918.7 MHz   */
        };
        /// <summary>
        /// FCC Frequency Channel number
        /// </summary>
        private const uint ZA_CHN_CNT = 16;
        private readonly uint[] zaFreqSortedIdx = new uint[]{
            0,1,2,3,
            4,5,6,7,
            8,9,10,11,
            12,13,14,15
        };
        #endregion

        #region ETSI, G800
        /// <summary>
        /// ETSI, G800 and India Frequency Table
        /// </summary>
        private readonly double[] ETSITableOfFreq = new double[]
        {
            865.70,
            866.30,
            866.90,
            867.50,
        };

        /*OK*/
        private readonly uint[] etsiFreqTable = new uint[]
        {
            0x003C21D1, /*865.700MHz   */
            0x003C21D7, /*866.300MHz   */
            0x003C21DD, /*866.900MHz   */
            0x003C21E3, /*867.500MHz   */
        };
        /// <summary>
        /// ETSI Frequency Channel number
        /// </summary>
        private const uint ETSI_CHN_CNT = 4;
        private readonly uint[] etsiFreqSortedIdx = new uint[]{
            0,
            1,
            2,
            3
        };

        #endregion

        #region India
        /// <summary>
        /// India Frequency Table
        /// </summary>
        private readonly double[] IDATableOfFreq = new double[]
        {
            865.70,
            866.30,
            866.90,
        };

        /*OK*/
        private readonly uint[] indiaFreqTable = new uint[]
        {
            0x003C21D1, /*865.700MHz   */
            0x003C21D7, /*866.300MHz   */
            0x003C21DD, /*866.900MHz   */
        };
        /// <summary>
        /// India Frequency Channel number
        /// </summary>
        private const uint IDA_CHN_CNT = 3;
        private readonly uint[] indiaFreqSortedIdx = new uint[]{
            0,
            1,
            2,
        };

        #endregion

        #region Australia
        /// <summary>
        /// Australia Frequency Table
        /// </summary>
        private readonly double[] AUSTableOfFreq = new double[]
        {
            920.75,
            921.25,
            921.75,
            922.25,
            922.75,
            923.25,
            923.75,
            924.25,
            924.75,
            925.25,
        };
        /*OK*/
        private readonly uint[] AusFreqTable = new uint[]
        {
            0x00180E63, /* 920.75MHz   */
            0x00180E69, /* 922.25MHz   */
            0x00180E6F, /* 923.75MHz   */
            0x00180E73, /* 924.75MHz   */
            0x00180E65, /* 921.25MHz   */
            0x00180E6B, /* 922.75MHz   */
            0x00180E71, /* 924.25MHz   */
            0x00180E75, /* 925.25MHz   */
            0x00180E67, /* 921.75MHz   */
            0x00180E6D, /* 923.25MHz   */
        };
        /// <summary>
        /// Australia Frequency Channel number
        /// </summary>
        private const uint AUS_CHN_CNT = 10;

        private readonly uint[] ausFreqSortedIdx = new uint[]{
                                                    0, 3, 6, 8, 1,
                                                    4, 7, 9, 2, 5,};
        #endregion

        #region China
        /// <summary>
        /// China Frequency Table
        /// </summary>
        private readonly double[] CHNTableOfFreq = new double[]
        {
            920.625,
            920.875,
            921.125,
            921.375,
            921.625,
            921.875,
            922.125,
            922.375,
            922.625,
            922.875,
            923.125,
            923.375,
            923.625,
            923.875,
            924.125,
            924.375,
        };
        /*OK*/
        private readonly uint[] cnFreqTable = new uint[]
        {
            0x00301CD3, /*922.375MHz   */
            0x00301CD1, /*922.125MHz   */
            0x00301CCD, /*921.625MHz   */
            0x00301CC5, /*920.625MHz   */
            0x00301CD9, /*923.125MHz   */
            0x00301CE1, /*924.125MHz   */
            0x00301CCB, /*921.375MHz   */
            0x00301CC7, /*920.875MHz   */
            0x00301CD7, /*922.875MHz   */
            0x00301CD5, /*922.625MHz   */
            0x00301CC9, /*921.125MHz   */
            0x00301CDF, /*923.875MHz   */
            0x00301CDD, /*923.625MHz   */
            0x00301CDB, /*923.375MHz   */
            0x00301CCF, /*921.875MHz   */
            0x00301CE3, /*924.375MHz   */
        };
        /// <summary>
        /// China Frequency Channel number
        /// </summary>
        private const uint CN_CHN_CNT = 16;
        private readonly uint[] cnFreqSortedIdx = new uint[]{
                                                7, 6, 4, 0,
                                                10, 14, 3, 1,
                                                9, 8, 2, 13,
                                                12, 11, 5, 15,
                                                };
        #endregion

        #region China1
        /// <summary>
        /// China Frequency Table
        /// </summary>
        private readonly double[] CHN1TableOfFreq = new double[]
        {
            920.625,
            920.875,
            921.125,
            921.375,
        };
        private readonly uint[] cn1FreqTable = new uint[]
        {
            0x00301CC5, /*920.625MHz   */
            0x00301CC7, /*920.875MHz   */
            0x00301CC9, /*921.125MHz   */
            0x00301CCB, /*921.375MHz   */
        };
        /// <summary>
        /// China Frequency Channel number
        /// </summary>
        private const uint CN1_CHN_CNT = 4;
        private readonly uint[] cn1FreqSortedIdx = new uint[]{
                                                0,1,2,3
                                                };
        #endregion
        #region China2
        /// <summary>
        /// China Frequency Table
        /// </summary>
        private readonly double[] CHN2TableOfFreq = new double[]
        {
            921.625,
            921.875,
            922.125,
            922.375,
        };
        private readonly uint[] cn2FreqTable = new uint[]
        {
            0x00301CCD, /*921.625MHz   */
            0x00301CCF, /*921.875MHz   */
            0x00301CD1, /*922.125MHz   */
			0x00301CD3, /*922.375MHz   */
        };
        #endregion
        #region China3
        /// <summary>
        /// China Frequency Table
        /// </summary>
        private readonly double[] CHN3TableOfFreq = new double[]
        {
            922.625,
            922.875,
            923.125,
            923.375,
        };
        private readonly uint[] cn3FreqTable = new uint[]
        {
            0x00301CD5, /*922.625MHz   */
            0x00301CD7, /*922.875MHz   */
            0x00301CD9, /*923.125MHz   */
            0x00301CDB, /*923.375MHz   */
        };
        #endregion
        #region China4
        /// <summary>
        /// China Frequency Table
        /// </summary>
        private readonly double[] CHN4TableOfFreq = new double[]
        {
            923.625,
            923.875,
            924.125,
            924.375,
        };
        private readonly uint[] cn4FreqTable = new uint[]
        {
            0x00301CDD, /*923.625MHz   */
            0x00301CDF, /*923.875MHz   */
            0x00301CE1, /*924.125MHz   */
            0x00301CE3, /*924.375MHz   */
        };
        #endregion
        #region China5
        /// <summary>
        /// China Frequency Table
        /// </summary>
        private readonly double[] CHN5TableOfFreq = new double[]
        {
            920.625,
            921.625,
            922.625,
            923.625,
        };
        private readonly uint[] cn5FreqTable = new uint[]
        {
            0x00301CC5, /*920.625MHz   */
            0x00301CCD, /*921.625MHz   */
            0x00301CD5, /*922.625MHz   */
            0x00301CDD, /*923.625MHz   */
        };
        #endregion
        #region China6
        /// <summary>
        /// China Frequency Table
        /// </summary>
        private readonly double[] CHN6TableOfFreq = new double[]
        {
            920.875,
            921.875,
            922.875,
            923.875,
        };
        private readonly uint[] cn6FreqTable = new uint[]
        {
            0x00301CC7, /*920.875MHz   */
            0x00301CCF, /*921.875MHz   */
            0x00301CD7, /*922.875MHz   */
            0x00301CDF, /*923.875MHz   */
        };
        #endregion
        #region China7
        /// <summary>
        /// China Frequency Table
        /// </summary>
        private readonly double[] CHN7TableOfFreq = new double[]
        {
            921.125,
            922.125,
            923.125,
            924.125,
        };
        private readonly uint[] cn7FreqTable = new uint[]
        {
             0x00301CC9, /*921.125MHz   */
             0x00301CD1, /*922.125MHz   */
             0x00301CD9, /*923.125MHz   */
             0x00301CE1, /*924.125MHz   */
        };
        #endregion
        #region China8
        /// <summary>
        /// China Frequency Table
        /// </summary>
        private readonly double[] CHN8TableOfFreq = new double[]
        {
            921.375,
            922.375,
            923.375,
            924.375,
        };
        private readonly uint[] cn8FreqTable = new uint[]
        {
            0x00301CCB, /*921.375MHz   */
            0x00301CD3, /*922.375MHz   */
            0x00301CDB, /*923.375MHz   */
            0x00301CE3, /*924.375MHz   */
        };
        #endregion
        #region China9
        /// <summary>
        /// China Frequency Table
        /// </summary>
        private readonly double[] CHN9TableOfFreq = new double[]
        {
            920.625,
            920.875,
            921.125,
        };
        private readonly uint[] cn9FreqTable = new uint[]
        {
            0x00301CC5, /*920.625MHz   */
            0x00301CC7, /*920.875MHz   */
            0x00301CC9, /*921.125MHz   */
        };
        /// <summary>
        /// China Frequency Channel number
        /// </summary>
        private const uint CN9_CHN_CNT = 3;
        private readonly uint[] cn9FreqSortedIdx = new uint[]{
                                                0,1,2
                                                };
        #endregion
        #region China10
        /// <summary>
        /// China Frequency Table
        /// </summary>
        private readonly double[] CHN10TableOfFreq = new double[]
        {
            921.625,
            921.875,
            922.125,
        };
        private readonly uint[] cn10FreqTable = new uint[]
        {
            0x00301CCD, /*921.625MHz   */
            0x00301CCF, /*921.875MHz   */
            0x00301CD1, /*922.125MHz   */
        };
        #endregion
        #region China11
        /// <summary>
        /// China Frequency Table
        /// </summary>
        private readonly double[] CHN11TableOfFreq = new double[]
        {
            922.625,
            922.875,
            923.125,
        };
        private readonly uint[] cn11FreqTable = new uint[]
        {
            0x00301CD5, /*922.625MHz   */
            0x00301CD7, /*922.875MHz   */
            0x00301CD9, /*923.125MHz   */
        };
        #endregion
        #region China12
        /// <summary>
        /// China Frequency Table
        /// </summary>
        private readonly double[] CHN12TableOfFreq = new double[]
        {
            923.625,
            923.875,
            924.125,
        };
        private readonly uint[] cn12FreqTable = new uint[]
        {
            0x00301CDD, /*923.625MHz   */
            0x00301CDF, /*923.875MHz   */
            0x00301CE1, /*924.125MHz   */
        };
        #endregion
        #region Singapo
        /// <summary>
        /// Hong Kong and Singapo Frequency Table
        /// </summary>
        private readonly double[] HKTableOfFreq = new double[]
        {
            920.75,
            921.25,
            921.75,
            922.25,
            922.75,
            923.25,
            923.75,
            924.25,
        };
        /*OK*/
        private readonly uint[] hkFreqTable = new uint[]
        {
            0x00180E63, /*920.75MHz   */
            0x00180E69, /*922.25MHz   */
            0x00180E71, /*924.25MHz   */
            0x00180E65, /*921.25MHz   */
            0x00180E6B, /*922.75MHz   */
            0x00180E6D, /*923.25MHz   */
            0x00180E6F, /*923.75MHz   */
            0x00180E67, /*921.75MHz   */
        };
        /// <summary>
        /// Hong Kong Frequency Channel number
        /// </summary>
        private const uint HK_CHN_CNT = 8;
        private readonly uint[] hkFreqSortedIdx = new uint[]{
            0, 3, 7, 1,
            4, 5, 6, 2,
        };
        #endregion

        #region OFCA (Hong Kong)
        /// <summary>
        /// Hong Kong and Singapo Frequency Table
        /// </summary>
        private readonly double[] OFCATableOfFreq = new double[]
        {
 920.416, // CH1
 920.500, // CH2
 920.583, // CH3	
 920.666, // CH4
 920.750, // CH5
 920.833, // CH6
 920.916, // CH7
 921.000, // CH8
 921.083, // CH9
 921.166, // CH10
 921.250, // CH11	
 921.333, // CH12
 921.416, // CH13	
 921.500, // CH14	
 921.583, // CH15	
 921.666, // CH16 	
 921.750, // CH17
 921.833, // CH18
 921.916, // CH19
 922.000, // CH20	
 922.083, // CH21
 922.166, // CH22
 922.250, // CH23	
 922.333, // CH24
 922.416, // CH25
 922.500, // CH26 
 922.583, // CH27
 922.666, // CH28
 922.750, // CH29
 922.833, // CH30
 922.916, // CH31
 923.000, // CH32 	
 923.083, // CH33
 923.166, // CH34	
 923.250, // CH35	
 923.333, // CH36 	
 923.416, // CH37	
 923.500, // CH38
 923.583, // CH39
 923.666, // CH40	
 923.750, // CH41	
 923.833, // CH42
 923.916, // CH43
 924.000, // CH44
 924.083, // CH45
 924.166, // CH46
 924.250, // CH47
 924.333, // CH48
 924.416, // CH49
 924.500 // CH50
        };
        /*OK*/
        private readonly uint[] ofcaFreqTable = new uint[]
        {
0x00482B3E,// 922.500 MHz CH26 
0x00482B49,// 923.416 MHz CH37	
0x00482B32,// 921.500 MHz CH14	
0x00482B38,// 922.000 MHz CH20	
0x00482B44,// 923.000 MHz CH32 	
0x00482B48,// 923.333 MHz CH36 	
0x00482B33,// 921.583 MHz CH15	
0x00482B34,// 921.666 MHz CH16 	
0x00482B47,// 923.250 MHz CH35	
0x00482B4D,// 923.750 MHz CH41	
0x00482B31,// 921.416 MHz CH13	
0x00482B3B,// 922.250 MHz CH23	
0x00482B27,// 920.583 MHz CH3	
0x00482B46,// 923.166 MHz CH34	
0x00482B4C,// 923.666 MHz CH40	
0x00482B2F,// 921.250 MHz CH11	
0x00482B37,// 921.916 MHz CH19
0x00482B4F,// 923.916 MHz CH43
0x00482B41,// 922.750 MHz CH29
0x00482B54,// 924.333 MHz CH48
0x00482B30,// 921.333 MHz CH12
0x00482B39,// 922.083 MHz CH21
0x00482B50,// 924.000 MHz CH44
0x00482B40,// 924.666 MHz CH28
0x00482B56,// 924.500 MHz CH50
0x00482B2E,// 921.166 MHz CH10
0x00482B35,// 921.750 MHz CH17
0x00482B26,// 920.500 MHz CH2
0x00482B43,// 922.916 MHz CH31
0x00482B55,// 924.416 MHz CH49
0x00482B2A,// 920.833 MHz CH6
0x00482B36,// 921.833 MHz CH18
0x00482B51,// 924.083 MHz CH45
0x00482B42,// 922.833 MHz CH30
0x00482B53,// 924.250 MHz CH47
0x00482B2D,// 921.083 MHz CH9
0x00482B3C,// 922.333 MHz CH24
0x00482B29,// 920.750 MHz CH5
0x00482B45,// 923.083 MHz CH33
0x00482B4E,// 923.833 MHz CH42
0x00482B25,// 920.416 MHz CH1
0x00482B3D,// 922.416 MHz CH25
0x00482B2B,// 920.916 MHz CH7
0x00482B3F,// 922.583 MHz CH27
0x00482B52,// 924.166 MHz CH46
0x00482B2C,// 921.000 MHz CH8
0x00482B4A,// 923.500 MHz CH38
0x00482B3A,// 922.166 MHz CH22
0x00482B4B,// 923.583 MHz CH39
0x00482B28 // 920.666 MHz CH4
        };
        /// <summary>
        /// Hong Kong Frequency Channel number
        /// </summary>
        private const uint OFCA_CHN_CNT = 50;
        private readonly uint[] ofcaFreqSortedIdx = new uint[]{
25, 36, 13, 19, 31,
35, 14, 15, 34, 40,
12, 22, 2, 33, 39,
10, 18, 42, 28, 47,
11, 20, 43, 27, 49,
9, 16, 1, 30, 48,
5, 17, 44, 29, 46,
8, 23, 4, 32, 41,
0, 24, 6, 26, 45,
7, 37, 21, 38, 3
        };
        #endregion

        #region Japan
        /// <summary>
        /// Japan Frequency Table
        /// </summary>
        private readonly double[] JPNTableOfFreq = new double[]
        {
            952.20,
            952.40,
            952.60,
            952.80,
            953.00,
            953.20,
            953.40,
            953.60,
            953.80,
        };
        private readonly double[] JPNTableOfFreq28 = new double[]
        {
            //952.20,
            952.40,
            952.60,
            952.80,
            953.00,
            953.20,
            953.40,
            953.60,
            //953.80,
        };
        /// <summary>
        /// Japan Frequency Table
        /// </summary>
        private readonly double[] JPNTableOfFreq29 = new double[]
        {
            //952.20,
            952.40,
            952.60,
            952.80,
            953.00,
            953.20,
            953.40,
            953.60,
            953.80,
        };
        /*OK*/
        private readonly uint[] jpnFreqTable = new uint[]
        {
            0x003C2534, /*952.400MHz   Channel 2*/
            0x003C2542, /*953.800MHz   Channel 9*/
            0x003C253A, /*953.000MHz   Channel 5*/
            0x003C2540, /*953.600MHz   Channel 8*/
            0x003C2536, /*952.600MHz   Channel 3*/
            0x003C253C, /*953.200MHz   Channel 6*/
            0x003C2538, /*952.800MHz   Channel 4*/
            0x003C253E, /*953.400MHz   Channel 7*/
            0x003C2532, /*952.200MHz   Channel 1*/
        };
        private readonly uint[] jpnFreqTable28 = new uint[]
        {
            0x003C2534, /*952.400MHz   Channel 2*/
            0x003C253A, /*953.000MHz   Channel 5*/
            0x003C2540, /*953.600MHz   Channel 8*/
            0x003C2536, /*952.600MHz   Channel 3*/
            0x003C253C, /*953.200MHz   Channel 6*/
            0x003C2538, /*952.800MHz   Channel 4*/
            0x003C253E, /*953.400MHz   Channel 7*/
        };
        private readonly uint[] jpnFreqTable29 = new uint[]
        {
            0x003C2534, /*952.400MHz   Channel 2*/
            0x003C2542, /*953.800MHz   Channel 9*/
            0x003C253A, /*953.000MHz   Channel 5*/
            0x003C2540, /*953.600MHz   Channel 8*/
            0x003C2536, /*952.600MHz   Channel 3*/
            0x003C253C, /*953.200MHz   Channel 6*/
            0x003C2538, /*952.800MHz   Channel 4*/
            0x003C253E, /*953.400MHz   Channel 7*/
        };

        /// <summary>
        /// Japan Frequency Channel number
        /// </summary>
        private const uint JPN_CHN_CNT = 9;
        private const uint JPN_CHN_CNT28 = 7;
        private const uint JPN_CHN_CNT29 = 8;
        private readonly uint[] jpnFreqSortedIdx = new uint[]{
            0, 4, 6, 2, 5, 7, 3, 1, 8
        };
        private readonly uint[] jpnFreqSortedIdx28 = new uint[]{
            0, 4, 6, 2, 5, 3, 1
        };
        private readonly uint[] jpnFreqSortedIdx29 = new uint[]{
            0, 4, 6, 2, 5, 7, 3, 1
        };

#if nouse
        private readonly uint[] jpnFreqTable = new uint[]
        {
            //0x003C2532, /*952.200MHz   */
            0x003C2534, /*952.400MHz   */
            0x003C2536, /*952.600MHz   */
            0x003C2538, /*952.800MHz   */
            0x003C253A, /*953.000MHz   */
            0x003C253C, /*953.200MHz   */
            0x003C253E, /*953.400MHz   */
            0x003C2540, /*953.600MHz   */
            //0x003C2542, /*953.800MHz   */
        };

        /// <summary>
        /// Japan Frequency Channel number
        /// </summary>
        private const uint JPN_CHN_CNT = 7;// CS203 is not supported channel 1 and 9;
        private readonly uint[] jpnFreqSortedIdx = new uint[]{
	        0, 1, 2,
            3, 4, 5,
            6, //7, 8,
        };
#endif
        #endregion

        #region Japan
        /// <summary>
        /// Japan 2012 Frequency Table
        /// </summary>
        private readonly double[] JPN2012TableOfFreq = new double[]
        {
            916.80,
            918.00,
            919.20,
            920.40,
            920.60,
            920.80,
        };
        /*OK*/
        private readonly uint[] jpn2012FreqTable = new uint[]
        {
            0x003C23D0, /*916.800MHz   Channel 1*/
            0x003C23DC, /*918.000MHz   Channel 2*/
            0x003C23E8, /*919.200MHz   Channel 3*/
            0x003C23F4, /*920.400MHz   Channel 4*/
            0x003C23F6, /*920.600MHz   Channel 5*/
            0x003C23F8, /*920.800MHz   Channel 6*/
        };
        /// <summary>
        /// Japan Frequency Channel number
        /// </summary>
        private const uint JPN2012_CHN_CNT = 6;
        private readonly uint[] jpn2012FreqSortedIdx = new uint[]{
            0, 1, 2, 3, 4, 5
        };

        private readonly double[] JPN2019TableOfFreq = new double[]
        {
            916.80,
            918.00,
            919.20,
            920.40,
        };

        private readonly uint[] jpn2019FreqTable = new uint[]
        {
            0x003C23D0, /*916.800MHz   Channel 1*/
            0x003C23DC, /*918.000MHz   Channel 2*/
            0x003C23E8, /*919.200MHz   Channel 3*/
            0x003C23F4, /*920.400MHz   Channel 4*/
        };
        /// <summary>
        /// Japan Frequency 2019 Channel number
        /// </summary>
        private const uint JPN2019_CHN_CNT = 4;
        private readonly uint[] jpn2019FreqSortedIdx = new uint[]{
            0, 1, 2, 3
        };

        #endregion

        #region Korea
        /// <summary>
        /// Korea Frequency Table
        /// </summary>
        private double[] KRTableOfFreq = new double[]
        {
            917.30,
            917.90,
            918.50,
            919.10,
            919.70,
            920.30
        };

        /*Not same as CS101???*/
        private uint[] krFreqTable = new uint[]
        {
            0x003C23E7, /*919.1 MHz   */
            0x003C23D5, /*917.3 MHz   */
            0x003C23F3, /*920.3 MHz   */
            0x003C23DB, /*917.9 MHz   */
            0x003C23ED, /*919.7 MHz   */
            0x003C23E1, /*918.5 MHz   */
        };

        /// <summary>
        /// Korea Frequency Channel number
        /// </summary>
        private const uint KR_CHN_CNT = 6;
        private readonly uint[] krFreqSortedIdx = new uint[]{
            3, 0, 5, 1, 4, 2
        };

#if oldvalue
        /// <summary>
        /// Korea Frequency Table
        /// </summary>
        private double[] KRTableOfFreq = new double[]
        {
            910.20,
            910.40,
            910.60,
            910.80,
            911.00,
            911.20,
            911.40,
            911.60,
            911.80,
            912.00,
            912.20,
            912.40,
            912.60,
            912.80,
            913.00,
            913.20,
            913.40,
            913.60,
            913.80,
        };

        /*Not same as CS101???*/
        private uint[] krFreqTable = new uint[]
        {
            0x003C23A8, /*912.8MHz   13*/
            0x003C23A0, /*912.0MHz   9*/
            0x003C23AC, /*913.2MHz   15*/
            0x003C239E, /*911.8MHz   8*/
            0x003C23A4, /*912.4MHz   11*/
            0x003C23B2, /*913.8MHz   18*/
            0x003C2392, /*910.6MHz   2*/
            0x003C23B0, /*913.6MHz   17*/
            0x003C2390, /*910.4MHz   1*/
            0x003C239C, /*911.6MHz   7*/
            0x003C2396, /*911.0MHz   4*/
            0x003C23A2, /*912.2MHz   10*/
            0x003C238E, /*910.2MHz   0*/
            0x003C23A6, /*912.6MHz   12*/
            0x003C2398, /*911.2MHz   5*/
            0x003C2394, /*910.8MHz   3*/
            0x003C23AE, /*913.4MHz   16*/
            0x003C239A, /*911.4MHz   6*/
            0x003C23AA, /*913.0MHz   14*/
        };

        /// <summary>
        /// Korea Frequency Channel number
        /// </summary>
        private const uint KR_CHN_CNT = 19;
        private readonly uint[] krFreqSortedIdx = new uint[]{
            13, 9, 15, 8, 11,
            18, 2, 17, 1, 7,
            4, 10, 0, 12, 5,
            3, 16, 6, 14
        };
#endif

        /*private const uint VIRTUAL_KR_DIVRAT = 0x001E0000;
        private const uint VIRTUAL_KR_CHN_CNT = 19;
        private readonly uint[] Virtual_krFreqMultRat = new uint[]{ // with 0x001E as DIVRat
            0x11CA,0x11CE,0x11D2,0x11CD,0x11D6,
            0x11D8,0x11D3,0x11CF,0x11CB,0x11C9,
            0x11C7,0x11D1,0x11D4,0x11D9,0x11D7,
            0x11D5,0x11D0,0x11CC,0x11C8
        };
        private readonly uint[] Virtual_krFreqSortedIdx = new uint[]{
            10, 18, 9, 0, 8,
            17, 3, 1, 7, 16,
            11, 2, 6, 12, 15,
            4, 14, 5, 13
        };*/


        #endregion

        #region Malaysia
        /// <summary>
        /// Malaysia Frequency Table
        /// </summary>
        private double[] MYSTableOfFreq = new double[]
        {
            919.75,
            920.25,
            920.75,
            921.25,
            921.75,
            922.25,
        };

        private uint[] mysFreqTable = new uint[]
        {
            0x00180E5F, /*919.75MHz   */
            0x00180E65, /*921.25MHz   */
            0x00180E61, /*920.25MHz   */
            0x00180E67, /*921.75MHz   */
            0x00180E63, /*920.75MHz   */
            0x00180E69, /*922.25MHz   */
        };

        /// <summary>
        /// Malaysia Frequency Channel number
        /// </summary>
        private const uint MYS_CHN_CNT = 6;
        private readonly uint[] mysFreqSortedIdx = new uint[]{
                                                    0, 3, 1,
                                                    4, 2, 5,
                                                    };

#endregion

#region Taiwan
        /// <summary>
        /// Taiwan Frequency Table
        /// </summary>
        private double[] TWTableOfFreq = new double[]
        {
#if oldtwfreq
            922.25,
            922.75,
            923.25,
            923.75,
            924.25,
            924.75,
            925.25,
            925.75,
            926.25,
            926.75,
            927.25,
            927.75,
#endif
            922.875,
            923.250,
            923.625,
            924.000,
            924.375,
            924.750,
            925.125,
            925.500,
            925.875,
            926.250,
            926.625,
            927.000
        };

        /*Not same as CS101*/
        private uint[] twFreqTable = new uint[]
        {
#if oldtwfreq
            0x00180E7D, /*927.25MHz   10*/
            0x00180E73, /*924.75MHz   5*/
            0x00180E6B, /*922.75MHz   1*/
            0x00180E75, /*925.25MHz   6*/
            0x00180E7F, /*927.75MHz   11*/
            0x00180E71, /*924.25MHz   4*/
            0x00180E79, /*926.25MHz   8*/
            0x00180E6D, /*923.25MHz   2*/
            0x00180E7B, /*926.75MHz   9*/
            0x00180E69, /*922.25MHz   0*/
            0x00180E77, /*925.75MHz   7*/
            0x00180E6F, /*923.75MHz   3*/
#endif
            0x001009a7, /* 926.625 10 */
            0x001009a2, /* 924.750 5 */
            0x0010099e, /* 923.250 1 */
            0x001009a3, /* 925.125 6 */
            0x001009a8, /* 927.000 11 */
            0x001009a1, /* 924.375 4 */
            0x001009a5, /* 925.875 8 */
            0x0010099f, /* 923.625 2 */
            0x001009a6, /* 926.250 9 */
            0x0010099d, /* 922.875 0 */
            0x001009a4, /* 925.500 7 */
            0x001009a0, /* 924.000 3 */
        };

        /// <summary>
        /// Taiwan Frequency Channel number
        /// </summary>
        private const uint TW_CHN_CNT = 12;
        private readonly uint[] twFreqSortedIdx = new uint[]{
            10, 5, 1, 6,
            11, 4, 8, 2,
            9, 0, 7, 3,
        };
#endregion

#region Brazil

        private double[] BR1TableOfFreq = new double[]
            {
                /*902.75,
                903.25,
                903.75,
                904.25,
                904.75,
                905.25,
                905.75,
                906.25,
                906.75,
                907.25,
                907.75,
                908.25,
                908.75,
                909.25,
                909.75,
                910.25,
                910.75,
                911.25,
                911.75,
                912.25,
                912.75,
                913.25,
                913.75,
                914.25,
                914.75,
                915.25,*/
                915.75,
                916.25,
                916.75,
                917.25,
                917.75,
                918.25,
                918.75,
                919.25,
                919.75,
                920.25,
                920.75,
                921.25,
                921.75,
                922.25,
                922.75,
                923.25,
                923.75,
                924.25,
                924.75,
                925.25,
                925.75,
                926.25,
                926.75,
                927.25,
            };
        private uint[] br1FreqTable = new uint[]
        {
            0x00180E4F, /*915.75 MHz   */
            //0x00180E4D, /*915.25 MHz   */
            //0x00180E1D, /*903.25 MHz   */
            0x00180E7B, /*926.75 MHz   */
            0x00180E79, /*926.25 MHz   */
            //0x00180E21, /*904.25 MHz   */
            0x00180E7D, /*927.25 MHz   */
            0x00180E61, /*920.25 MHz   */
            0x00180E5D, /*919.25 MHz   */
            //0x00180E35, /*909.25 MHz   */
            0x00180E5B, /*918.75 MHz   */
            0x00180E57, /*917.75 MHz   */
            //0x00180E25, /*905.25 MHz   */
            //0x00180E23, /*904.75 MHz   */
            0x00180E75, /*925.25 MHz   */
            0x00180E67, /*921.75 MHz   */
            //0x00180E4B, /*914.75 MHz   */
            //0x00180E2B, /*906.75 MHz   */
            //0x00180E47, /*913.75 MHz   */
            0x00180E69, /*922.25 MHz   */
            //0x00180E3D, /*911.25 MHz   */
            //0x00180E3F, /*911.75 MHz   */
            //0x00180E1F, /*903.75 MHz   */
            //0x00180E33, /*908.75 MHz   */
            //0x00180E27, /*905.75 MHz   */
            //0x00180E41, /*912.25 MHz   */
            //0x00180E29, /*906.25 MHz   */
            0x00180E55, /*917.25 MHz   */
            //0x00180E49, /*914.25 MHz   */
            //0x00180E2D, /*907.25 MHz   */
            0x00180E59, /*918.25 MHz   */
            0x00180E51, /*916.25 MHz   */
            //0x00180E39, /*910.25 MHz   */
            //0x00180E3B, /*910.75 MHz   */
            //0x00180E2F, /*907.75 MHz   */
            0x00180E73, /*924.75 MHz   */
            //0x00180E37, /*909.75 MHz   */
            0x00180E5F, /*919.75 MHz   */
            0x00180E53, /*916.75 MHz   */
            //0x00180E45, /*913.25 MHz   */
            0x00180E6F, /*923.75 MHz   */
            //0x00180E31, /*908.25 MHz   */
            0x00180E77, /*925.75 MHz   */
            //0x00180E43, /*912.75 MHz   */
            0x00180E71, /*924.25 MHz   */
            0x00180E65, /*921.25 MHz   */
            0x00180E63, /*920.75 MHz   */
            0x00180E6B, /*922.75 MHz   */
            //0x00180E1B, /*902.75 MHz   */
            0x00180E6D, /*923.25 MHz   */
        };
        /// <summary>
        /// Brazil1 Frequency Channel number
        /// </summary>
        private const uint BR1_CHN_CNT = 24;
        private readonly uint[] br1FreqSortedIdx = new uint[]{
            0, 22, 21, 23,
            9, 7, 6, 4,
            19, 12, 13, 3,
            5, 1, 18, 8,
            2, 16, 20, 17,
            11, 10, 14, 15,
        };

        private double[] BR2TableOfFreq = new double[]
            {
                902.75,
                903.25,
                903.75,
                904.25,
                904.75,
                905.25,
                905.75,
                906.25,
                906.75,
                /*907.25,
                907.75,
                908.25,
                908.75,
                909.25,
                909.75,
                910.25,
                910.75,
                911.25,
                911.75,
                912.25,
                912.75,
                913.25,
                913.75,
                914.25,
                914.75,
                915.25,*/
                915.75,
                916.25,
                916.75,
                917.25,
                917.75,
                918.25,
                918.75,
                919.25,
                919.75,
                920.25,
                920.75,
                921.25,
                921.75,
                922.25,
                922.75,
                923.25,
                923.75,
                924.25,
                924.75,
                925.25,
                925.75,
                926.25,
                926.75,
                927.25,
            };
        private uint[] br2FreqTable = new uint[]
            {
                0x00180E4F, /*915.75 MHz   */
                //0x00180E4D, /*915.25 MHz   */
                0x00180E1D, /*903.25 MHz   */
                0x00180E7B, /*926.75 MHz   */
                0x00180E79, /*926.25 MHz   */
                0x00180E21, /*904.25 MHz   */
                0x00180E7D, /*927.25 MHz   */
                0x00180E61, /*920.25 MHz   */
                0x00180E5D, /*919.25 MHz   */
                //0x00180E35, /*909.25 MHz   */
                0x00180E5B, /*918.75 MHz   */
                0x00180E57, /*917.75 MHz   */
                0x00180E25, /*905.25 MHz   */
                0x00180E23, /*904.75 MHz   */
                0x00180E75, /*925.25 MHz   */
                0x00180E67, /*921.75 MHz   */
                //0x00180E4B, /*914.75 MHz   */
                0x00180E2B, /*906.75 MHz   */
                //0x00180E47, /*913.75 MHz   */
                0x00180E69, /*922.25 MHz   */
                //0x00180E3D, /*911.25 MHz   */
                //0x00180E3F, /*911.75 MHz   */
                0x00180E1F, /*903.75 MHz   */
                //0x00180E33, /*908.75 MHz   */
                0x00180E27, /*905.75 MHz   */
                //0x00180E41, /*912.25 MHz   */
                0x00180E29, /*906.25 MHz   */
                0x00180E55, /*917.25 MHz   */
                //0x00180E49, /*914.25 MHz   */
                //0x00180E2D, /*907.25 MHz   */
                0x00180E59, /*918.25 MHz   */
                0x00180E51, /*916.25 MHz   */
                //0x00180E39, /*910.25 MHz   */
                //0x00180E3B, /*910.75 MHz   */
                //0x00180E2F, /*907.75 MHz   */
                0x00180E73, /*924.75 MHz   */
                //0x00180E37, /*909.75 MHz   */
                0x00180E5F, /*919.75 MHz   */
                0x00180E53, /*916.75 MHz   */
                //0x00180E45, /*913.25 MHz   */
                0x00180E6F, /*923.75 MHz   */
                //0x00180E31, /*908.25 MHz   */
                0x00180E77, /*925.75 MHz   */
                //0x00180E43, /*912.75 MHz   */
                0x00180E71, /*924.25 MHz   */
                0x00180E65, /*921.25 MHz   */
                0x00180E63, /*920.75 MHz   */
                0x00180E6B, /*922.75 MHz   */
                0x00180E1B, /*902.75 MHz   */
                0x00180E6D, /*923.25 MHz   */
            };
        /// <summary>
        /// Brazil2 Frequency Channel number
        /// </summary>
        private const uint BR2_CHN_CNT = 33;
        private readonly uint[] br2FreqSortedIdx = new uint[]{
            9, 1, 31,
            30, 3, 32,
            18, 16, 15,
            13, 5, 4,
            28, 21, 8,
            22, 2, 6,
            7, 12, 14,
            10, 27, 17,
            11, 25, 29,
            26, 20, 19,
            23, 0, 24,
        };

        private double[] BR3TableOfFreq = new double[]
            {
                902.75, // 0
                903.25, // 1
                903.75, // 2
                904.25, // 3
                904.75, // 4
                905.25, // 5
                905.75, // 6
                906.25, // 7
                906.75, // 8
            };
        private uint[] br3FreqTable = new uint[]
            {
                0x00180E1D, /*903.25 MHz   */
                0x00180E21, /*904.25 MHz   */
                0x00180E25, /*905.25 MHz   */
                0x00180E23, /*904.75 MHz   */
                0x00180E2B, /*906.75 MHz   */
                0x00180E1F, /*903.75 MHz   */
                0x00180E27, /*905.75 MHz   */
                0x00180E29, /*906.25 MHz   */
                0x00180E1B, /*902.75 MHz   */
            };
        /// <summary>
        /// Brazil3 Frequency Channel number
        /// </summary>
        private const uint BR3_CHN_CNT = 9;
        private readonly uint[] br3FreqSortedIdx = new uint[]{
            1, 3, 5, 4, 8, 2, 6, 7, 0
        };

        private double[] BR4TableOfFreq = new double[]
            {
                902.75,
                903.25,
                903.75,
                904.25,
            };
        private uint[] br4FreqTable = new uint[]
            {
                0x00180E1D, /*903.25 MHz   */
                0x00180E21, /*904.25 MHz   */
                0x00180E1F, /*903.75 MHz   */
                0x00180E1B, /*902.75 MHz   */
            };
        /// <summary>
        /// Brazil2 Frequency Channel number
        /// </summary>
        private const uint BR4_CHN_CNT = 4;
        private readonly uint[] br4FreqSortedIdx = new uint[]{
            1, 3, 2, 0
        };

        private double[] BR5TableOfFreq = new double[]
            {
                917.75, // 0
                918.25, // 1
                918.75, // 2
                919.25, // 3
                919.75, // 4
                920.25, // 5
                920.75, // 6
                921.25, // 7
                921.75, // 8
                922.25, // 9
                922.75, // 10
                923.25, // 11
                923.75, // 12
                924.25, // 13
            };
        private uint[] br5FreqTable = new uint[]
            {
                0x00180E61, /*920.25 MHz   */
                0x00180E5D, /*919.25 MHz   */
                0x00180E5B, /*918.75 MHz   */
                0x00180E57, /*917.75 MHz   */
                0x00180E67, /*921.75 MHz   */
                0x00180E69, /*922.25 MHz   */
                0x00180E59, /*918.25 MHz   */
                0x00180E5F, /*919.75 MHz   */
                0x00180E6F, /*923.75 MHz   */
                0x00180E71, /*924.25 MHz   */
                0x00180E65, /*921.25 MHz   */
                0x00180E63, /*920.75 MHz   */
                0x00180E6B, /*922.75 MHz   */
                0x00180E6D, /*923.25 MHz   */

            };
        /// <summary>
        /// Brazil2 Frequency Channel number
        /// </summary>
        private const uint BR5_CHN_CNT = 14;
        private readonly uint[] br5FreqSortedIdx = new uint[]{
            5, 3, 2, 0, 8, 9, 1, 4, 12, 13, 7, 6, 10, 11
        };

#endregion

#region Indonesia
        /// <summary>
        /// Indonesia Frequency Table
        /// </summary>
        private readonly double[] IDTableOfFreq = new double[]
        {
            923.25,
            923.75,
            924.25,
            924.75,
        };

        /*OK*/
        private readonly uint[] indonesiaFreqTable = new uint[]
        {
            0x00180E6D, /*923.25 MHz    */
            0x00180E6F, /*923.75 MHz    */
            0x00180E71, /*924.25 MHz    */
            0x00180E73, /*924.75 MHz    */

        };
        /// <summary>
        /// Indonesia Frequency Channel number
        /// </summary>
        private const uint ID_CHN_CNT = 4;
        private readonly uint[] indonesiaFreqSortedIdx = new uint[]{
            0,
            1,
            2,
            3
        };

#region UH1
        /// <summary>
        /// FCC UH Frequency Table 915-920
        /// </summary>
        private readonly double[] UH1TableOfFreq = new double[]
            {
                915.25,     // 0
                915.75,     // 1
                916.25,     // 2
                916.75,     // 3
                917.25,     // 4
                917.75,     // 5
                918.25,     // 6
                918.75,     // 7
                919.25,     // 8
                919.75,     // 9
            };
        /*OK*/
        private uint[] uh1FreqTable = new uint[]
        {
            0x00180E4F, /*915.75 MHz   */
            0x00180E4D, /*915.25 MHz   */
            0x00180E5D, /*919.25 MHz   */
            0x00180E5B, /*918.75 MHz   */
            0x00180E57, /*917.75 MHz   */
            0x00180E55, /*917.25 MHz   */
            0x00180E59, /*918.25 MHz   */
            0x00180E51, /*916.25 MHz   */
            0x00180E5F, /*919.75 MHz   */
            0x00180E53, /*916.75 MHz   */
        };
        /// <summary>
        /// FCC UH Frequency Channel number
        /// </summary>
        private const uint UH1_CHN_CNT = 10;
        private readonly uint[] uh1FreqSortedIdx = new uint[]{
            1, 0, 8, 7, 5, 4, 6, 2, 9, 3
        };
#endregion

#region UH2
        /// <summary>
        /// FCC UH Frequency Table 920-928
        /// </summary>
        private readonly double[] UH2TableOfFreq = new double[]
            {
                920.25,   // 0
                920.75,   // 1
                921.25,   // 2
                921.75,   // 3
                922.25,   // 4
                922.75,   // 5
                923.25,   // 6
                923.75,   // 7
                924.25,   // 8
                924.75,   // 9
                925.25,   // 10
                925.75,   // 11
                926.25,   // 12
                926.75,   // 13
                927.25,   // 14
            };
        /*OK*/
        private uint[] uh2FreqTable = new uint[]
        {
            0x00180E7B, /*926.75 MHz   */
            0x00180E79, /*926.25 MHz   */
            0x00180E7D, /*927.25 MHz   */
            0x00180E61, /*920.25 MHz   */
            0x00180E75, /*925.25 MHz   */
            0x00180E67, /*921.75 MHz   */
            0x00180E69, /*922.25 MHz   */
            0x00180E73, /*924.75 MHz   */
            0x00180E6F, /*923.75 MHz   */
            0x00180E77, /*925.75 MHz   */
            0x00180E71, /*924.25 MHz   */
            0x00180E65, /*921.25 MHz   */
            0x00180E63, /*920.75 MHz   */
            0x00180E6B, /*922.75 MHz   */
            0x00180E6D, /*923.25 MHz   */
        };
        /// <summary>
        /// FCC UH Frequency Channel number
        /// </summary>
        private const uint UH2_CHN_CNT = 15;
        private readonly uint[] uh2FreqSortedIdx = new uint[]{
            13, 12, 14, 0, 10, 3, 4, 9, 7, 11, 8, 2, 1, 5, 6,
        };
#endregion

#region LH

        private double[] LHTableOfFreq = new double[]
            {
                902.75, // 0
                903.25, // 1
                903.75, // 2
                904.25, // 3
                904.75, // 4
                905.25, // 5
                905.75, // 6
                906.25, // 7
                906.75, // 8
                907.25, // 9
                907.75, // 10
                908.25, // 11
                908.75, // 12
                909.25, // 13
                909.75, // 14
                910.25, // 15
                910.75, // 16
                911.25, // 17
                911.75, // 18
                912.25, // 19
                912.75, // 20
                913.25, // 21
                913.75, // 22
                914.25, // 23
                914.75, // 24
                915.25, // 25
                
                /*915.75,
                916.25,
                916.75,
                917.25,
                917.75,
                918.25,
                918.75,
                919.25,
                919.75,
                920.25,
                920.75,
                921.25,
                921.75,
                922.25,
                922.75,
                923.25,
                923.75,
                924.25,
                924.75,
                925.25,
                925.75,
                926.25,
                926.75,
                927.25,*/
            };
        private uint[] lhFreqTable = new uint[]
        {
            0x00180E1B, /*902.75 MHz   */
            0x00180E35, /*909.25 MHz   */
            0x00180E1D, /*903.25 MHz   */
            0x00180E37, /*909.75 MHz   */
            0x00180E1F, /*903.75 MHz   */
            0x00180E39, /*910.25 MHz   */
            0x00180E21, /*904.25 MHz   */
            0x00180E3B, /*910.75 MHz   */
            0x00180E23, /*904.75 MHz   */
            0x00180E3D, /*911.25 MHz   */
            0x00180E25, /*905.25 MHz   */
            0x00180E3F, /*911.75 MHz   */
            0x00180E27, /*905.75 MHz   */
            0x00180E41, /*912.25 MHz   */
            0x00180E29, /*906.25 MHz   */
            0x00180E43, /*912.75 MHz   */
            0x00180E2B, /*906.75 MHz   */
            0x00180E45, /*913.25 MHz   */
            0x00180E2D, /*907.25 MHz   */
            0x00180E47, /*913.75 MHz   */
            0x00180E2F, /*907.75 MHz   */
            0x00180E49, /*914.25 MHz   */
            0x00180E31, /*908.25 MHz   */
            0x00180E4B, /*914.75 MHz   */
            0x00180E33, /*908.75 MHz   */
            0x00180E4D, /*915.25 MHz   */


            //0x00180E4F, /*915.75 MHz   */
            //0x00180E7B, /*926.75 MHz   */
            //0x00180E79, /*926.25 MHz   */
            //0x00180E7D, /*927.25 MHz   */
            //0x00180E61, /*920.25 MHz   */
            //0x00180E5D, /*919.25 MHz   */
            //0x00180E5B, /*918.75 MHz   */
            //0x00180E57, /*917.75 MHz   */
            //0x00180E75, /*925.25 MHz   */
            //0x00180E67, /*921.75 MHz   */
            //0x00180E69, /*922.25 MHz   */
            //0x00180E55, /*917.25 MHz   */
            //0x00180E59, /*918.25 MHz   */
            //0x00180E51, /*916.25 MHz   */
            //0x00180E73, /*924.75 MHz   */
            //0x00180E5F, /*919.75 MHz   */
            //0x00180E53, /*916.75 MHz   */
            //0x00180E6F, /*923.75 MHz   */
            //0x00180E77, /*925.75 MHz   */
            //0x00180E71, /*924.25 MHz   */
            //0x00180E65, /*921.25 MHz   */
            //0x00180E63, /*920.75 MHz   */
            //0x00180E6B, /*922.75 MHz   */
            //0x00180E6D, /*923.25 MHz   */
        };
        /// <summary>
        /// Brazil1 Frequency Channel number
        /// </summary>
        private const uint LH_CHN_CNT = 26;
        private readonly uint[] lhFreqSortedIdx = new uint[]{
        0, 13, 1, 14, 2, 15, 3, 16, 4, 17, 5, 18, 6, 19, 7, 20, 8, 21, 9, 22, 10, 23, 11, 24, 12, 25 
            /*
 * 0, 22, 21, 23,
            9, 7, 6, 4,
            19, 12, 13, 3,
            5, 1, 18, 8,
            2, 16, 20, 17,
            11, 10, 14, 15,
*/
        };


        private double[] LH1TableOfFreq = new double[]
            {
                902.75, // 0
                903.25, // 1
                903.75, // 2
                904.25, // 3
                904.75, // 4
                905.25, // 5
                905.75, // 6
                906.25, // 7
                906.75, // 8
                907.25, // 9
                907.75, // 10
                908.25, // 11
                908.75, // 12
                909.25, // 13
            };
        private uint[] lh1FreqTable = new uint[]
        {
            0x00180E1B, /*902.75 MHz   */
            0x00180E35, /*909.25 MHz   */
            0x00180E1D, /*903.25 MHz   */
            0x00180E1F, /*903.75 MHz   */
            0x00180E21, /*904.25 MHz   */
            0x00180E23, /*904.75 MHz   */
            0x00180E25, /*905.25 MHz   */
            0x00180E27, /*905.75 MHz   */
            0x00180E29, /*906.25 MHz   */
            0x00180E2B, /*906.75 MHz   */
            0x00180E2D, /*907.25 MHz   */
            0x00180E2F, /*907.75 MHz   */
            0x00180E31, /*908.25 MHz   */
            0x00180E33, /*908.75 MHz   */
        };
        /// <summary>
        /// Brazil1 Frequency Channel number
        /// </summary>
        private const uint LH1_CHN_CNT = 14;
        private readonly uint[] lh1FreqSortedIdx = new uint[]{
        0, 13, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 
        };


        private double[] LH2TableOfFreq = new double[]
            {
                909.75, // 0
                910.25, // 1
                910.75, // 2
                911.25, // 3
                911.75, // 4
                912.25, // 5
                912.75, // 6
                913.25, // 7
                913.75, // 8
                914.25, // 9
                914.75, // 10
            };

        private uint[] lh2FreqTable = new uint[]
        {
            0x00180E37, /*909.75 MHz   */
            0x00180E39, /*910.25 MHz   */
            0x00180E3B, /*910.75 MHz   */
            0x00180E3D, /*911.25 MHz   */
            0x00180E3F, /*911.75 MHz   */
            0x00180E41, /*912.25 MHz   */
            0x00180E43, /*912.75 MHz   */
            0x00180E45, /*913.25 MHz   */
            0x00180E47, /*913.75 MHz   */
            0x00180E49, /*914.25 MHz   */
            0x00180E4B, /*914.75 MHz   */
        };
        /// <summary>
        /// Brazil1 Frequency Channel number
        /// </summary>
        private const uint LH2_CHN_CNT = 11;
        private readonly uint[] lh2FreqSortedIdx = new uint[]{
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
        };



#endregion

#endregion

#region JE

        private double[] JETableOfFreq = new double[]
        {
                915.25, // 0
                915.5,  // 1
                915.75, // 2
                916.0,  // 3
                916.25, // 4
                916.5,  // 5
                916.75, // 6
            };
        private uint[] jeFreqTable = new uint[]
        {
            0x00180E4D, /*915.25 MHz   */
            0x00180E51, /*916.25 MHz   */
            0x00180E4E, /*915.5 MHz   */
            0x00180E52, /*916.5 MHz   */
            0x00180E4F, /*915.75 MHz   */
            0x00180E53, /*916.75 MHz   */
            0x00180E50, /*916.0 MHz   */
        };
        /// <summary>
        /// Brazil1 Frequency Channel number
        /// </summary>
        private const uint JE_CHN_CNT = 7;
        private readonly uint[] jeFreqSortedIdx = new uint[]{
        0, 4, 1, 5, 2, 6, 3
        };

#endregion

#region BackoffTable
        private UInt32[] etsiBackoffTable = new uint[]
        {
            0x0000175a, /*       5978 usecs */
            0x000016d5, /*       5845 usecs */
            0x0000225a, /*       8794 usecs */
            0x0000219f, /*       8607 usecs */
            0x00001fdd, /*       8157 usecs */
            0x00001cb4, /*       7348 usecs */
            0x000026c9, /*       9929 usecs */
            0x000026c6, /*       9926 usecs */
            0x00001e66, /*       7782 usecs */
            0x0000140d, /*       5133 usecs */
            0x00001ead  /*       7853 usecs */
        };

        private UInt32[] japanBackoffTable = new uint[]
        {
            0x00001388, /*       5978 usecs */
            0x00001388, /*       5845 usecs */
            0x00001388, /*       8794 usecs */
            0x00001388, /*       8607 usecs */
            0x00001388, /*       8157 usecs */
            0x00001388, /*       7348 usecs */
            0x00001388, /*       9929 usecs */
            0x00001388, /*       9926 usecs */
            0x00001388, /*       7782 usecs */
            0x00001388, /*       5133 usecs */
            0x00001388  /*       7853 usecs */
        };
#endregion

#region PH

        private double[] PHTableOfFreq = new double[]
            {
                918.125, // 0
                918.375, // 1
                918.625, // 2
                918.875, // 3
                919.125, // 5
                919.375, // 6
                919.625, // 7
                919.875, // 8
            };
        private uint[] phFreqTable = new uint[]
        {
            0x00301CB1, /*918.125MHz   Channel 0*/
            0x00301CBB, /*919.375MHz   Channel 5*/
            0x00301CB7, /*918.875MHz   Channel 3*/
            0x00301CBF, /*919.875MHz   Channel 7*/
            0x00301CB3, /*918.375MHz   Channel 1*/
            0x00301CBD, /*919.625MHz   Channel 6*/
            0x00301CB5, /*918.625MHz   Channel 2*/
            0x00301CB9, /*919.125MHz   Channel 4*/
        };
        /// <summary>
        /// Brazil1 Frequency Channel number
        /// </summary>
        private const uint PH_CHN_CNT = 8;
        private readonly uint[] phFreqSortedIdx = new uint[]{
            0, 5, 3, 7, 1, 6, 2, 4
        };

#region ETSIUPPERBAND

        private double[] ETSIUPPERBANDTableOfFreq = new double[]
        {
            916.3,
            917.5,
            918.7,
            //919.9,
        };
        private uint[] etsiupperbandFreqTable = new uint[]
        {
            0x003C23CB, /*916.3 MHz   */
            0x003C23D7, /*917.5 MHz   */
            0x003C23E3, /*918.7 MHz   */
            0x003C23E3, /*918.7 MHz   */
            //0x003C23EF, /*919.9 MHz   */
        };
        /// <summary>
        /// Brazil1 Frequency Channel number
        /// </summary>
        private const uint ETSIUPPERBAND_CHN_CNT = 3;
        private readonly uint[] etsiupperbandFreqSortedIdx = new uint[]{
            0, 1, 2//, 3
        };

#endregion

#region NZ

        private double[] NZTableOfFreq = new double[]
        {
            920.25,
            920.75,
            921.25,
            921.75,
            922.25,
            922.75,
            923.25,
            923.75,
            924.25,
            924.75,
            925.25,
            925.75,
            926.25,
            926.75,
            927.25,
            927.75
        };
        private uint[] nzFreqTable = new uint[]
        {
    0x00180E65, /*921.25 MHz   2*/
    0x00180E73, /*924.75MHz   9*/
    0x00180E69, /*922.25MHz   4*/
    0x00180E79, /*926.25MHz   12*/
    0x00180E6B, /*922.75MHz   5*/
    0x00180E6F, /*923.75MHz   7*/
    0x00180E67, /*921.75 MHz   3*/
    0x00180E7B, /*926.75MHz   13*/
    0x00180E77, /*925.75MHz   11*/
    0x00180E71, /*924.25MHz   8*/
    0x00180E7D, /*927.25MHz   14*/
    0x00180E61, /*920.25 MHz   0*/
    0x00180E7F, /*927.75MHz   15*/
    0x00180E75, /*925.25MHz   10*/
    0x00180E63, /*920.75 MHz   1*/
    0x00180E6D, /*923.25MHz   6*/
        };
        /// <summary>
        /// Brazil1 Frequency Channel number
        /// </summary>
        private const uint NZ_CHN_CNT = 16;
        private readonly uint[] nzFreqSortedIdx = new uint[]{
            2, 9, 4, 12, 5, 7, 3, 13, 11, 8, 14, 0, 15, 10, 1, 6
        };

#endregion


#region VE

        private readonly double[] VETableOfFreq = new double[]
        {
            922.75,// 0
            923.25,
            923.75,
            924.25,
            924.75,
            925.25,// 5
            925.75,
            926.25,
            926.75,
            927.25,// 9
        };

        private uint[] veFreqTable = new uint[]
        {
            0x00180E77, /*925.75 MHz  6 */
            0x00180E6B, /*922.75 MHz  0 */
            0x00180E7D, /*927.25 MHz  9 */
            0x00180E75, /*925.25 MHz  5 */
            0x00180E6D, /*923.25 MHz  1 */
            0x00180E7B, /*926.75 MHz  8 */
            0x00180E73, /*924.75 MHz  4 */
            0x00180E6F, /*923.75 MHz  2 */
            0x00180E79, /*926.25 MHz  7 */
            0x00180E71, /*924.25 MHz  3 */
};
        /// <summary>
        /// FCC Frequency Channel number
        /// </summary>
        private const uint VE_CHN_CNT = 10;
        private readonly uint[] veFreqSortedIdx = new uint[]{
            6, 0, 9, 5, 1,
            8, 4, 2, 7, 3
        };

#endregion

#region BA

        private readonly double[] BATableOfFreq = new double[]
        {
            925.25,
            925.75,
            926.25,
            926.75
        };

        private uint[] baFreqTable = new uint[]
        {
            0x00180E75, /*925.25 MHz  0 */
            0x00180E77, /*925.75 MHz  1 */
            0x00180E79, /*926.25 MHz  2 */
            0x00180E7B, /*926.75 MHz  3 */
        };

        /// <summary>
        /// BA Frequency Channel number
        /// </summary>
        private const uint BA_CHN_CNT = 4;
        private readonly uint[] baFreqSortedIdx = new uint[]{
            0, 1, 2, 3
        };

#endregion
        
#endregion

#endregion


        /// <summary>
        /// Set Frequency Band - Basic Function
        /// </summary>
        /// <param name="m_radioIndex"></param>
        /// <param name="frequencySelector"></param>
        /// <param name="config"></param>
        /// <param name="multdiv"></param>
        /// <param name="pllcc"></param>
        /// <returns></returns>
        private Result SetFrequencyBand (UInt32 frequencySelector, BandState config, UInt32 multdiv, UInt32 pllcc)
        {
            MacWriteRegister(MACREGISTER.HST_RFTC_FRQCH_SEL /*SELECTOR_ADDRESS*/, frequencySelector);

            MacWriteRegister(MACREGISTER.HST_RFTC_FRQCH_CFG /*CONFIG_ADDRESS*/, (uint)config);

            if (config == BandState.ENABLE)
            {
                MacWriteRegister(MACREGISTER.HST_RFTC_FRQCH_DESC_PLLDIVMULT /*MULTDIV_ADDRESS*/, multdiv);

                MacWriteRegister(MACREGISTER.HST_RFTC_FRQCH_DESC_PLLDACCTL /*PLLCC_ADDRESS*/, pllcc);
            }

            return Result.OK;
        }

        private uint FreqChnCnt(RegionCode prof)
        {
            switch (prof)
            {
                case RegionCode.AR:
                case RegionCode.CL:
                case RegionCode.CO:
                case RegionCode.CR:
                case RegionCode.DO:
                case RegionCode.PA:
                case RegionCode.UY:
                case RegionCode.FCC:
                    return FCC_CHN_CNT;
                case RegionCode.CN:
                    return CN_CHN_CNT;
                case RegionCode.TW:
                    return TW_CHN_CNT;
                case RegionCode.KR:
                    return KR_CHN_CNT;
                case RegionCode.HK:
                    return OFCA_CHN_CNT;
                case RegionCode.SG:
                case RegionCode.TH:
                case RegionCode.VI:
                    return HK_CHN_CNT;
                case RegionCode.AU:
                    return AUS_CHN_CNT;
                case RegionCode.MY:
                    return MYS_CHN_CNT;
                case RegionCode.G800:
                case RegionCode.ETSI:
                    return ETSI_CHN_CNT;
                case RegionCode.IN:
                    return IDA_CHN_CNT;
                case RegionCode.JP:
                    if (m_oem_special_country_version == 0x2A4A5036)
                        return JPN2012_CHN_CNT;
                    else
                        return JPN2019_CHN_CNT;
                case RegionCode.ZA:
                    return ZA_CHN_CNT;
                case RegionCode.BR1:
                    return BR1_CHN_CNT;
                case RegionCode.PE:
                case RegionCode.BR2:
                    return BR2_CHN_CNT;
                case RegionCode.BR3:
                    return BR3_CHN_CNT;
                case RegionCode.BR4:
                    return BR4_CHN_CNT;
                case RegionCode.BR5:
                    return BR5_CHN_CNT;
                case RegionCode.ID:
                    return ID_CHN_CNT;
                case RegionCode.JE:
                    return JE_CHN_CNT;
                case RegionCode.PH:
                    return PH_CHN_CNT;
                case RegionCode.ETSIUPPERBAND:
                    return ETSIUPPERBAND_CHN_CNT;
                case RegionCode.NZ:
                    return NZ_CHN_CNT;
                case RegionCode.UH1:
                    return UH1_CHN_CNT;
                case RegionCode.UH2:
                    return UH2_CHN_CNT;
                case RegionCode.LH:
                    return LH_CHN_CNT;
                case RegionCode.LH1:
                    return LH1_CHN_CNT;
                case RegionCode.LH2:
                    return LH2_CHN_CNT;
                case RegionCode.VE:
                    return VE_CHN_CNT;
                case RegionCode.BA:
                    return BA_CHN_CNT;
                default:
                    return 0;
                    //break;
            }
            //return 0;
        }

        private uint[] FreqTable(RegionCode prof)
        {
            switch (prof)
            {
                case RegionCode.AR:
                case RegionCode.CL:
                case RegionCode.CO:
                case RegionCode.CR:
                case RegionCode.DO:
                case RegionCode.PA:
                case RegionCode.UY:
                case RegionCode.FCC:
                    switch (m_oem_table_version)
                    {
                        default:
                            return fccFreqTable;

                        case 0x20170001:
                            return fccFreqTable_Ver20170001;
                    }
                case RegionCode.CN:
                    return cnFreqTable;
                    return cn12FreqTable;
                case RegionCode.TW:
                    return twFreqTable;
                case RegionCode.KR:
                    return krFreqTable;
                case RegionCode.HK:
                    return ofcaFreqTable;
                case RegionCode.SG:
                case RegionCode.TH:
                case RegionCode.VI:
                    return hkFreqTable;
                case RegionCode.AU:
                    return AusFreqTable;
                case RegionCode.MY:
                    return mysFreqTable;
                case RegionCode.G800:
                case RegionCode.ETSI:
                    return etsiFreqTable;
                case RegionCode.IN:
                    return indiaFreqTable;
                case RegionCode.JP:
                    if (m_oem_special_country_version == 0x2A4A5036)
                        return jpn2012FreqTable;
                    else
                        return jpn2019FreqTable;
                case RegionCode.ZA:
                    return zaFreqTable;
                case RegionCode.BR1:
                    return br1FreqTable;
                case RegionCode.PE:
                case RegionCode.BR2:
                    return br2FreqTable;
                case RegionCode.BR3:
                    return br3FreqTable;
                case RegionCode.BR4:
                    return br4FreqTable;
                case RegionCode.BR5:
                    return br5FreqTable;
                case RegionCode.ID:
                    return indonesiaFreqTable;
                case RegionCode.JE:
                    return jeFreqTable;
                case RegionCode.PH:
                    return phFreqTable;
                case RegionCode.ETSIUPPERBAND:
                    return etsiupperbandFreqTable;
                case RegionCode.NZ:
                    return nzFreqTable;
                case RegionCode.UH1:
                    return uh1FreqTable;
                case RegionCode.UH2:
                    return uh2FreqTable;
                case RegionCode.LH:
                    return lhFreqTable;
                case RegionCode.LH1:
                    return lh1FreqTable;
                case RegionCode.LH2:
                    return lh2FreqTable;
                case RegionCode.VE:
                    return veFreqTable;
                case RegionCode.BA:
                    return baFreqTable;
                default:
                    return null;
                    //break;
            }
            //return null;
        }

        private bool FreqChnWithinRange(uint Channel, RegionCode region)
        {
            uint ChnCnt = FreqChnCnt(region);
            if (ChnCnt < 0)
                return false;
            if (Channel >= 0 && Channel < ChnCnt)
            {
                return true;
            }
            return false;
        }

        private int FreqSortedIdxTbls(RegionCode Prof, uint Channel)
        {
            uint TotalCnt = FreqChnCnt(Prof);
            uint[] freqIndex = FreqIndex(Prof);
            if (!FreqChnWithinRange(Channel, Prof) || freqIndex == null)
                return -1;
            for (int i = 0; i < TotalCnt; i++)
            {
                if (freqIndex[i] == Channel)
                {
                    return i;
                }
            }
            return -1;
        }

        private uint GetPllcc(RegionCode prof)
        {
            switch (prof)
            {
                case RegionCode.G800:
                case RegionCode.ETSI:
                case RegionCode.IN:
                    return 0x14070400;
            }

            return 0x14070200;
            //return pllvalue;
        }

        private uint[] FreqIndex(RegionCode prof)
        {
            switch (prof)
            {
                case RegionCode.AR:
                case RegionCode.CL:
                case RegionCode.CO:
                case RegionCode.CR:
                case RegionCode.DO:
                case RegionCode.PA:
                case RegionCode.UY:
                case RegionCode.FCC:
                    switch (m_oem_table_version)
                    {
                        default:
                            return fccFreqSortedIdx;

                        case 0x20170001:
                            return fccFreqSortedIdx_Ver20170001;
                    }
                case RegionCode.CN:
                    return cnFreqSortedIdx;
                case RegionCode.TW:
                    return twFreqSortedIdx;
                case RegionCode.KR:
                    return krFreqSortedIdx;
                case RegionCode.HK:
                    return ofcaFreqSortedIdx;
                case RegionCode.SG:
                case RegionCode.TH:
                case RegionCode.VI:
                    return hkFreqSortedIdx;
                case RegionCode.AU:
                    return ausFreqSortedIdx;
                case RegionCode.MY:
                    return mysFreqSortedIdx;
                case RegionCode.G800:
                case RegionCode.ETSI:
                    return etsiFreqSortedIdx;
                case RegionCode.IN:
                    return indiaFreqSortedIdx;
                case RegionCode.JP:
                    if (m_oem_special_country_version == 0x2A4A5036)
                        return jpn2012FreqSortedIdx;
                    else
                        return jpn2019FreqSortedIdx;
                case RegionCode.ZA:
                    return zaFreqSortedIdx;
                case RegionCode.BR1:
                    return br1FreqSortedIdx;
                case RegionCode.PE:
                case RegionCode.BR2:
                    return br2FreqSortedIdx;
                case RegionCode.BR3:
                    return br3FreqSortedIdx;
                case RegionCode.BR4:
                    return br4FreqSortedIdx;
                case RegionCode.BR5:
                    return br5FreqSortedIdx;
                case RegionCode.ID:
                    return indonesiaFreqSortedIdx;
                case RegionCode.JE:
                    return jeFreqSortedIdx;
                case RegionCode.PH:
                    return phFreqSortedIdx;
                case RegionCode.ETSIUPPERBAND:
                    return etsiupperbandFreqSortedIdx;
                case RegionCode.NZ:
                    return nzFreqSortedIdx;
                case RegionCode.UH1:
                    return uh1FreqSortedIdx;
                case RegionCode.UH2:
                    return uh2FreqSortedIdx;
                case RegionCode.LH:
                    return lhFreqSortedIdx;
                case RegionCode.LH1:
                    return lh1FreqSortedIdx;
                case RegionCode.LH2:
                    return lh2FreqSortedIdx;
                case RegionCode.VE:
                    return veFreqSortedIdx;
                case RegionCode.BA:
                    return baFreqSortedIdx;
            }

            return null;
        }

        private Result SetRadioLBT(LBT enable)
        {
            //ushort Reg = 0x0301; // HST_PROTSCH_SMCFG
            uint Val = 0;
            MacReadRegister(MACREGISTER.HST_PROTSCH_SMCFG /*Reg*/, ref Val);

            if (enable == LBT.ON) /* Bit 0 */
                Val |= 0x00000001;
            else
                Val &= 0xFFFFFFFE;

            MacWriteRegister(MACREGISTER.HST_PROTSCH_SMCFG /*Reg*/, Val);

            //m_save_enable_lbt = enable;
            return Result.OK;
        }

        /// <summary>
        /// Get frequency table on specific region
        /// </summary>
        /// <param name="region">Region Code</param>
        /// <returns></returns>
        public double[] GetAvailableFrequencyTable(FrequencyBand.RegionCode region)
        {
            switch (region)
            {
                case RegionCode.AU:
                    return AUSTableOfFreq;
                case RegionCode.CN:
                    return CHNTableOfFreq;
                case RegionCode.ETSI:
                case RegionCode.G800:
                    return ETSITableOfFreq;
                case RegionCode.IN:
                    return IDATableOfFreq;
                case RegionCode.AR:
                case RegionCode.CL:
                case RegionCode.CO:
                case RegionCode.CR:
                case RegionCode.DO:
                case RegionCode.PA:
                case RegionCode.UY:
                case RegionCode.FCC:
                    return FCCTableOfFreq;
                case RegionCode.HK:
                    return OFCATableOfFreq;
                case RegionCode.SG:
                case RegionCode.TH:
                case RegionCode.VI:
                    return HKTableOfFreq;
                case RegionCode.JP:
                    if (m_oem_special_country_version == 0x2A4A5036)
                        return JPN2012TableOfFreq;
                    else
                        return JPN2019TableOfFreq;
                case RegionCode.KR:
                    return KRTableOfFreq;
                case RegionCode.MY:
                    return MYSTableOfFreq;
                case RegionCode.TW:
                    return TWTableOfFreq;
                case RegionCode.ZA:
                    return ZATableOfFreq;
                case RegionCode.BR1:
                    return BR1TableOfFreq;
                case RegionCode.PE:
                case RegionCode.BR2:
                    return BR2TableOfFreq;
                case RegionCode.BR3:
                    return BR3TableOfFreq;
                case RegionCode.BR4:
                    return BR4TableOfFreq;
                case RegionCode.BR5:
                    return BR5TableOfFreq;
                case RegionCode.ID:
                    return IDTableOfFreq;
                case RegionCode.JE:
                    return JETableOfFreq;
                case RegionCode.PH:
                    return PHTableOfFreq;
                case RegionCode.ETSIUPPERBAND:
                    return ETSIUPPERBANDTableOfFreq;
                case RegionCode.NZ:
                    return NZTableOfFreq;
                case RegionCode.UH1:
                    return UH1TableOfFreq;
                case RegionCode.UH2:
                    return UH2TableOfFreq;
                case RegionCode.LH:
                    return LHTableOfFreq;
                case RegionCode.LH1:
                    return LH1TableOfFreq;
                case RegionCode.LH2:
                    return LH2TableOfFreq;
                case RegionCode.VE:
                    return VETableOfFreq;
                case RegionCode.BA:
                    return BATableOfFreq;
                default:
                    return new double[0];
            }
        }


        private static uint[] BasicDIVRAT = new uint[] { 0x0010, 0x0018, 0x0030, 0x003c, 0x0048 };


        static public UInt32 FrequenceToPll(double freq)
        {
            UInt32 pll;

            foreach (uint divrat in BasicDIVRAT)
            {
                pll = FrequenceToPll(freq, divrat);

                if (pll != 0)
                    return pll;
            }

            throw new InvalidOperationException("can not cal pll value, please check BasicDIVRAT");
        }

        static public UInt32 FrequenceToPll(double freq, uint divrat)
        {
            if (divrat == 0)
                return FrequenceToPll(freq);

            double fd = freq * divrat;

            if ((fd % 6) == 0)
            {
                UInt32 pllHight = divrat << 16;
                UInt32 pllLow = (UInt32)(fd / 6);
                return (pllHight | pllLow);
            }

            return 0;
        }

        static public UInt32[] GetPllValues(double[] FrequencyTable)
        {
            UInt32[] pllTable = new UInt32[FrequencyTable.Length];
            UInt32 divrat = 0;

            try
            {
                pllTable[0] = FrequenceToPll(FrequencyTable[0]);
                divrat = pllTable[0] >> 16;

                for (int i = 1; i < FrequencyTable.Length; i++)
                    pllTable[i] = FrequenceToPll(FrequencyTable[i], divrat);

                return pllTable;
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("ERROR : can not get pll table");
            }
            return null;
        }

    }
}

#if new
{
    public class FREQUENCYDATA
    {
        int channel;
        double frequency;
        UInt16 pplvalue;
    }

    public class FREQUENCYSET
    {
        public string country;
        public FREQUENCYDATA [] frequencyData;
    }

    // Israeli
    FREQUENCYSET israeliFrequencySet {
        country = "Israeli";
        frequencyData = new FREQUENCYDATA()[]{ { 0, 915.5, 0x00180E4E },
                                               { 1, 915.7, 0x003C23C5 },
                                               { 2, 915.9, 0x003C23C7 },
                                               { 3, 916.1, 0x003C23C9 },
                                               { 4, 916.3, 0x003C23CB },
                                               { 5, 916.5, 0x003C23CD } }

}
#endif
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Private.Inventory.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        //private void StartInventory()
        //{
        //    _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.INV), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);

            //_deviceHandler.rfid._dataBuffer.Clear();
            /*
            // Create a timer that waits one second, then invokes every second.
            Xamarin.Forms.Device.StartTimer(TimeSpan.FromMilliseconds(2000), () => {
                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0, 0xf000, 0x000f), (UInt32)SENDREMARK.INVENTORY);
                return true;
            });
            */
        //}

		private void TagRangingThreadProc_CS108()
		{
            _tagRangingParms = m_rdr_opt_parms.TagRanging.Clone();

            uint Value = 0;

			CSLibrary.Structures.InternalTagRangingParms parms = new CSLibrary.Structures.InternalTagRangingParms();
			parms.flags = m_rdr_opt_parms.TagRanging.flags;
			parms.tagStopCount = m_rdr_opt_parms.TagRanging.tagStopCount;

			// Set MultiBanks Info
			MacReadRegister(MACREGISTER.HST_INV_CFG, ref Value);

			Value &= 0xfff5fcff;
			if (m_rdr_opt_parms.TagRanging.multibanks != 0)
				Value |= (m_rdr_opt_parms.TagRanging.multibanks & (uint)0x03) << 16;

			if (m_rdr_opt_parms.TagRanging.QTMode == true)
				Value |= 0x00080000; // bit 19

            Value &= ~(0x03f00000U); // Set delay time to 0

            if (m_rdr_opt_parms.TagRanging.compactmode)
            {
                Value |= _INVENTORYDELAYTIME;
                Value |= (1 << 26); // bit 26
                MacWriteRegister(MACREGISTER.INV_CYCLE_DELAY, _InventoryCycleDelay);
            }
            else
            {
                Value |= (30 << 20);
                Value &= ~(1U << 26); // bit 26
                MacWriteRegister(MACREGISTER.INV_CYCLE_DELAY, 0);
            }

            MacWriteRegister(MACREGISTER.HST_INV_CFG, Value);

            Value = 0;
            if (m_rdr_opt_parms.TagRanging.focus)
                Value |= 0x10;
            if (m_rdr_opt_parms.TagRanging.fastid)
                Value |= 0x20;
            MacWriteRegister(MACREGISTER.HST_IMPINJ_EXTENSIONS, Value);

            // Set up the access bank register
            Value = (UInt32)(m_rdr_opt_parms.TagRanging.bank1) | (UInt32)(((int)m_rdr_opt_parms.TagRanging.bank2) << 2);
			MacWriteRegister(MACREGISTER.HST_TAGACC_BANK, Value);

			// Set up the access pointer register (tells the offset)
			Value = (UInt32)((m_rdr_opt_parms.TagRanging.offset1 & 0xffff) | ((m_rdr_opt_parms.TagRanging.offset2 & 0xffff) << 16));
			MacWriteRegister(MACREGISTER.HST_TAGACC_PTR, Value);

			// Set up the access count register (i.e., number values to read)
			Value = (UInt32)((0xFF & m_rdr_opt_parms.TagRanging.count1) | ((0xFF & m_rdr_opt_parms.TagRanging.count2) << 8));
			MacWriteRegister(MACREGISTER.HST_TAGACC_CNT, Value);

			// Set up the access password
			Value = (UInt32)(m_rdr_opt_parms.TagRanging.accessPassword);
			MacWriteRegister(MACREGISTER.HST_TAGACC_ACCPWD, Value);

			// Set Toggle off, if QT Mode. 
			if (m_rdr_opt_parms.TagRanging.QTMode == true)
			{
				uint RegValue = 0;

				for (uint cnt = 0; cnt < 4; cnt++)
				{
					MacWriteRegister(MACREGISTER.HST_INV_SEL, cnt);
					MacReadRegister(MACREGISTER.HST_INV_ALG_PARM_2, ref RegValue);
					Value &= 0xfffffffe;
					MacWriteRegister(MACREGISTER.HST_INV_ALG_PARM_2, Value);
				}
			}

			Start18K6CRequest(m_rdr_opt_parms.TagRanging.tagStopCount, parms.flags);

			_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.INV), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
			//m_Result = COMM_HostCommand(HST_CMD.INV);
		}

        private void PreTagRangingThreadProc_CS108()
        {
            _tagRangingParms = m_rdr_opt_parms.TagRanging.Clone();

            uint Value = 0;

            CSLibrary.Structures.InternalTagRangingParms parms = new CSLibrary.Structures.InternalTagRangingParms();
            parms.flags = m_rdr_opt_parms.TagRanging.flags;
            parms.tagStopCount = m_rdr_opt_parms.TagRanging.tagStopCount;

            // Set MultiBanks Info
            MacReadRegister(MACREGISTER.HST_INV_CFG, ref Value);

            Value &= 0xfff0fcff;

            Value |= (1 << 18); // enable CRC checking

            if (m_rdr_opt_parms.TagRanging.multibanks != 0)
                Value |= (m_rdr_opt_parms.TagRanging.multibanks & (uint)0x03) << 16;

            if (m_rdr_opt_parms.TagRanging.QTMode == true)
                Value |= (1 << 19); // bit 19

            Value &= ~(0x03f00000U); // Set delay time to 0

            if (m_rdr_opt_parms.TagRanging.compactmode)
            {
                Value |= _INVENTORYDELAYTIME;
                Value |= (1 << 26); // bit 26
                MacWriteRegister(MACREGISTER.INV_CYCLE_DELAY, _InventoryCycleDelay);
            }
            else
            {
                Value |= (30 << 20);
                Value &= ~(1U << 26); // bit 26
                MacWriteRegister(MACREGISTER.INV_CYCLE_DELAY, 0);
            }

            MacWriteRegister(MACREGISTER.HST_INV_CFG, Value);

            Value = 0;
            if (m_rdr_opt_parms.TagRanging.focus)
                Value |= 0x10;
            if (m_rdr_opt_parms.TagRanging.fastid)
                Value |= 0x20;
            MacWriteRegister(MACREGISTER.HST_IMPINJ_EXTENSIONS, Value);

            // Set up the access bank register
            Value = (UInt32)(m_rdr_opt_parms.TagRanging.bank1) | (UInt32)(((int)m_rdr_opt_parms.TagRanging.bank2) << 2);
            MacWriteRegister(MACREGISTER.HST_TAGACC_BANK, Value);

            // Set up the access pointer register (tells the offset)
            Value = (UInt32)((m_rdr_opt_parms.TagRanging.offset1 & 0xffff) | ((m_rdr_opt_parms.TagRanging.offset2 & 0xffff) << 16));
            MacWriteRegister(MACREGISTER.HST_TAGACC_PTR, Value);

            // Set up the access count register (i.e., number values to read)
            Value = (UInt32)((0xFF & m_rdr_opt_parms.TagRanging.count1) | ((0xFF & m_rdr_opt_parms.TagRanging.count2) << 8));
            MacWriteRegister(MACREGISTER.HST_TAGACC_CNT, Value);

            // Set up the access password
            Value = (UInt32)(m_rdr_opt_parms.TagRanging.accessPassword);
            MacWriteRegister(MACREGISTER.HST_TAGACC_ACCPWD, Value);

            // Set Toggle off, if QT Mode. 
            if (m_rdr_opt_parms.TagRanging.QTMode == true)
            {
                uint RegValue = 0;

                for (uint cnt = 0; cnt < 4; cnt++)
                {
                    MacWriteRegister(MACREGISTER.HST_INV_SEL, cnt);
                    MacReadRegister(MACREGISTER.HST_INV_ALG_PARM_2, ref RegValue);
                    Value &= 0xfffffffe;
                    MacWriteRegister(MACREGISTER.HST_INV_ALG_PARM_2, Value);
                }
            }

            Start18K6CRequest(m_rdr_opt_parms.TagRanging.tagStopCount, parms.flags);
        }

        private void ExeTagRangingThreadProc_CS108()
        {
            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.INV), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
        }

        private void TagSearchOneTagThreadProc_CS108()
        {
            // FireStateChangedEvent(RFState.BUSY);

            UInt32 Value = 0;

            // disable compact mode
            MacReadRegister(MACREGISTER.HST_INV_CFG, ref Value);

            Value &= ~(0x03f00000U); // Set delay time to 0
            Value |= (30 << 20);
            Value &= ~(1U << 26); // bit 26
            MacWriteRegister(MACREGISTER.INV_CYCLE_DELAY, 0);
            MacWriteRegister(MACREGISTER.HST_INV_CFG, Value);

            CSLibrary.Structures.InternalTagSearchOneParms parms = new CSLibrary.Structures.InternalTagSearchOneParms();
            parms.avgRssi = m_rdr_opt_parms.TagSearchOne.avgRssi;

            //                m_Result =  TagSearchOne(parms);
            Start18K6CRequest(0, CSLibrary.Constants.SelectFlags.SELECT);

            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.INV), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);

            // FireStateChangedEvent(RFState.IDLE);
        }

        private void PreTagSearchOneTagThreadProc_CS108()
        {
            UInt32 Value = 0;

            // disable compact mode
            MacReadRegister(MACREGISTER.HST_INV_CFG, ref Value);
            Value &= ~(0x03f00000U); // Set delay time to 0
            Value |= (30 << 20);
            Value &= ~(1U << 26); // bit 26
            MacWriteRegister(MACREGISTER.INV_CYCLE_DELAY, 0);
            MacWriteRegister(MACREGISTER.HST_INV_CFG, Value);

            CSLibrary.Structures.InternalTagSearchOneParms parms = new CSLibrary.Structures.InternalTagSearchOneParms();
            parms.avgRssi = m_rdr_opt_parms.TagSearchOne.avgRssi;

            //                m_Result =  TagSearchOne(parms);
            Start18K6CRequest(0, CSLibrary.Constants.SelectFlags.SELECT);
        }

        private void ExeTagSearchOneTagThreadProc_CS108()
        {
            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.INV), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Private.OEM.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;

namespace CSLibrary
{
    using static RFIDDEVICE;

    public partial class RFIDReader
    {
        uint m_oem_table_version;

        // 0x02 = Country Code
        // 0x04 = PCB assembly Code(0)
        // 0x05 = PCB assembly Code(1)
        // 0x06 = PCB assembly Code(2)
        // 0x07 = PCB assembly Code(3)
        // 0x0B = OEM table version
        // 0x8E = Special Country Version
        // 0x8F = Frequency Modification Flag
        // 0x9D = 0: Hopping, 1: non-Hopping
        // 0xA3 = 0: Low Power Mode, 1: High Power Mode (allow 32dBm)
        // 0xA4 = Model Code
        // 0xA5 = Max Output Power
        //        static readonly UInt32[] oemAddress = new UInt32[] { 0x02, 0x04, 0x05, 0x06, 0x07, 0x0B, 0x8E, 0x8F, 0x9D, 0xA3, 0xA4, 0xA5 };

        static readonly UInt32[] oemAddress = new UInt32[] { 0x02, 0x0B, 0x8E, 0x8F, 0x9D, 0xA3, 0xA4, 0x04, 0x05, 0x06, 0x07, 0xA5 };
        UInt32[] oemValue = new UInt32[oemAddress.Length];

        void ReadReaderOEMData()
        {
            for (int cnt = 0; cnt < oemAddress.Length; cnt++)
            {
                MacReadOemData(oemAddress[cnt], ref oemValue[cnt]);
            }
        }

        bool StoreOEMData(UInt32 address, UInt32 value)
        {
            int cnt;

            for (cnt = 0; cnt < oemAddress.Length; cnt++)
            {
                if (oemAddress[cnt] == address)
                {
                    oemValue[cnt] = value;
                    break;
                }
            }

            if (cnt == oemAddress.Length)
                return false;


            // All OEM data finish, then do frequence initialize
            if (cnt == oemAddress.Length - 1)
            {
                m_oem_country_code = oemValue[0];                  // 0x02
                m_oem_table_version = oemValue[1];                  // 0x0B
                m_oem_special_country_version = (uint)oemValue[2];  // 0x8e
                m_oem_freq_modification_flag = (uint)oemValue[3];    // 0x8f
                m_oem_machine = (oemValue[6] == 0) ? MODEL.CS108 : (MODEL)oemValue[6];               // 0xA4

                {
                    uint[] data = new uint[4];

                    data[0] = oemValue[7];
                    data[1] = oemValue[8];
                    data[2] = oemValue[9];
                    data[3] = oemValue[10];

                    m_PCBAssemblyCode = uint32ArrayToString(data).Replace("\0", "");
                }

                InitDefaultChannel_CS108();
                GenCountryList();
                SetDefaultAntennaList();
                FireStateChangedEvent(RFState.INITIALIZATION_COMPLETE);
                FireStateChangedEvent(RFState.IDLE);
            }

            return true;
        }

        bool GetOEMData(UInt32 address, ref UInt32 value)
        {
            int cnt;

            for (cnt = 0; cnt < oemAddress.Length; cnt++)
            {
                if (oemAddress[cnt] == address)
                {
                    value = oemValue[cnt];
                    return true;
                }
            }

            return false;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Private.PowerManager.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;

namespace CSLibrary
{
	public partial class RFIDReader
	{
		internal bool _SetRFIDToStandbyMode = true;
	}
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Private.Read.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        const int MAX_RD_CNT = 253; // max 253, old version 0x20

        private void Setup18K6CReadRegisters_CS108(UInt32 bank, UInt32 offset, UInt32 count)
        {
            // Set up the access bank register
            MacWriteRegister(MACREGISTER.HST_TAGACC_BANK, bank);

            // Set up the access pointer register (tells the offset)
            MacWriteRegister(MACREGISTER.HST_TAGACC_PTR, offset);

            // Set up the access count register (i.e., number values to read)
            MacWriteRegister(MACREGISTER.HST_TAGACC_CNT, count);
        }

        private int Start18K6CRead_CS108(uint bank, uint offset, uint count, UInt16[] data, uint accessPassword, uint retry, CSLibrary.Constants.SelectFlags flags)
        {
            // Perform the common 18K6C tag operation setup
            Start18K6CRequest(retry, flags);

            Setup18K6CReadRegisters(bank, offset, count);

            // Set up the access password register
            MacWriteRegister(MACREGISTER.HST_TAGACC_ACCPWD, accessPassword);

            // Issue the read command
            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.READ), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (UInt32)CurrentOperation);

            return 0;
        } //  Start18K6CRead

        private bool CUST_18K6CTagRead_CS108(CSLibrary.Constants.MemoryBank bank, int offset, int count, UInt16[] data, UInt32 password, /*UInt32 retry, */CSLibrary.Constants.SelectFlags flags)
        {
            if (count > MAX_RD_CNT)
                return false;       // too many data

            Start18K6CRead((uint)bank, (uint)(offset), (uint)count, data, password, 1, flags);

            return true;
        }

        private void ReadThreadProc_CS108()
        {
            ushort[] readbuf = new ushort[2];

            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                CurrentOperationResult = CSLibrary.Constants.Result.NO_TAG_FOUND;

                m_rdr_opt_parms.TagRead.m_pData = new UInt16[m_rdr_opt_parms.TagRead.count];

                m_Result = CSLibrary.Constants.Result.OK;

                if (CUST_18K6CTagRead(
                    m_rdr_opt_parms.TagRead.bank,
                    m_rdr_opt_parms.TagRead.offset,
                    m_rdr_opt_parms.TagRead.count,
                    m_rdr_opt_parms.TagRead.m_pData,
                    m_rdr_opt_parms.TagRead.accessPassword,
                    CSLibrary.Constants.SelectFlags.SELECT) != true)
                    m_Result = CSLibrary.Constants.Result.FAILURE;
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.ReadThreadProc()", ex);
#endif
            }
            finally
            {
            }
        }

        private void TagReadPCThreadProc_CS108()
        {
            ushort[] readbuf = new ushort[1];

            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                CurrentOperationResult = CSLibrary.Constants.Result.NO_TAG_FOUND;

                m_Result = CSLibrary.Constants.Result.OK;

                if (CUST_18K6CTagRead(
                    CSLibrary.Constants.MemoryBank.BANK1,
                    PC_START_OFFSET,
                    ONE_WORD_LEN,
                    readbuf,
                    m_rdr_opt_parms.TagReadPC.accessPassword,
//                    m_rdr_opt_parms.TagReadPC.retryCount,
                    CSLibrary.Constants.SelectFlags.SELECT) == true)
                    m_rdr_opt_parms.TagReadPC.m_pc = readbuf[0];
                else
                    m_Result = CSLibrary.Constants.Result.FAILURE;
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagReadPCThreadProc()", ex);
#endif
            }
            finally
            {
                /*                FireAccessCompletedEvent(
                                    new OnAccessCompletedEventArgs(
                                    m_Result == CSLibrary.Constants.Result.OK,
                                    CSLibrary.Constants.Bank.PC,
                                    CSLibrary.Constants.TagAccess.READ,
                                    m_rdr_opt_parms.TagReadPC.pc));

                                FireStateChangedEvent(CSLibrary.Constants.RFState.IDLE);
                */
            }
        }

        private void TagReadEPCThreadProc_CS108()
        {
            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                CurrentOperationResult = CSLibrary.Constants.Result.NO_TAG_FOUND;

                m_Result = CSLibrary.Constants.Result.OK;

                if (CUST_18K6CTagRead(
                    CSLibrary.Constants.MemoryBank.EPC,
                    (ushort)(EPC_START_OFFSET + m_rdr_opt_parms.TagReadEPC.offset),
                    m_rdr_opt_parms.TagReadEPC.count,
                    m_rdr_opt_parms.TagReadEPC.m_epc,
                    m_rdr_opt_parms.TagReadEPC.accessPassword,
//                    m_rdr_opt_parms.TagReadEPC.retryCount,
                    CSLibrary.Constants.SelectFlags.SELECT) != true)
                    m_Result = CSLibrary.Constants.Result.FAILURE;
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagReadEPCThreadProc()", ex);
#endif
            }
            finally
            {
                /*
                                FireAccessCompletedEvent(
                                    new OnAccessCompletedEventArgs(
                                    m_Result == CSLibrary.Constants.Result.OK,
                                    CSLibrary.Constants.Bank.EPC,
                                    CSLibrary.Constants.TagAccess.READ,
                                    m_rdr_opt_parms.TagReadEPC.epc));

                                FireStateChangedEvent(CSLibrary.Constants.RFState.IDLE);
                */
            }
        }

        private void TagReadAccPwdThreadProc_CS108()
        {
            ushort[] readbuf = new ushort[2];

            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                m_Result = CSLibrary.Constants.Result.OK;

                if (CUST_18K6CTagRead(
                    CSLibrary.Constants.MemoryBank.RESERVED,
                    ACC_PWD_START_OFFSET,
                    TWO_WORD_LEN,
                    readbuf,
                    m_rdr_opt_parms.TagReadAccPwd.accessPassword,
//                    m_rdr_opt_parms.TagReadAccPwd.retryCount,
                    CSLibrary.Constants.SelectFlags.SELECT) == true)
                    m_rdr_opt_parms.TagReadAccPwd.m_password = (uint)(readbuf[0] << 16 | readbuf[1]);
                else
                    m_Result = CSLibrary.Constants.Result.FAILURE;
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagReadAccPwdThreadProc()", ex);
#endif
            }
            finally
            {
 /*               FireAccessCompletedEvent(
                    new OnAccessCompletedEventArgs(
                    m_Result == CSLibrary.Constants.Result.OK,
                    CSLibrary.Constants.Bank.ACC_PWD,
                    CSLibrary.Constants.TagAccess.READ,
                    m_rdr_opt_parms.TagReadAccPwd.password));

                FireStateChangedEvent(CSLibrary.Constants.RFState.IDLE);
*/            }
        }

        private void TagReadKillPwdThreadProc_CS108()
        {
            ushort[] readbuf = new ushort[2];

            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                //                m_Result = TagReadKillPwd(m_rdr_opt_parms.TagReadKillPwd);
                m_Result = CSLibrary.Constants.Result.OK;

                if (CUST_18K6CTagRead(
                    CSLibrary.Constants.MemoryBank.RESERVED,
                    KILL_PWD_START_OFFSET,
                    TWO_WORD_LEN,
                    readbuf,
                    m_rdr_opt_parms.TagReadKillPwd.accessPassword,
                    //m_rdr_opt_parms.TagReadKillPwd.retryCount,
                    CSLibrary.Constants.SelectFlags.SELECT) == true)
                    m_rdr_opt_parms.TagReadKillPwd.m_password = (uint)(readbuf[0] << 16 | readbuf[1]);
                else
                    m_Result = CSLibrary.Constants.Result.FAILURE;

            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagReadKillPwdThreadProc()", ex);
#endif
            }
            finally
            {
                /*
                                FireAccessCompletedEvent(
                                    new OnAccessCompletedEventArgs(
                                    m_Result == CSLibrary.Constants.Result.OK,
                                    CSLibrary.Constants.Bank.KILL_PWD,
                                    CSLibrary.Constants.TagAccess.READ,
                                    m_rdr_opt_parms.TagReadKillPwd.password));

                                FireStateChangedEvent(CSLibrary.Constants.RFState.IDLE);
                */
            }
        }

        private void TagReadTidThreadProc_CS108()
        {
            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                CurrentOperationResult = CSLibrary.Constants.Result.NO_TAG_FOUND;

                m_Result = CSLibrary.Constants.Result.OK;

                if (CUST_18K6CTagRead(
                    CSLibrary.Constants.MemoryBank.TID,
                    m_rdr_opt_parms.TagReadTid.offset,
                    m_rdr_opt_parms.TagReadTid.count,
                    m_rdr_opt_parms.TagReadTid.pData,
                    m_rdr_opt_parms.TagReadTid.accessPassword,
                    //m_rdr_opt_parms.TagReadTid.retryCount,
                    CSLibrary.Constants.SelectFlags.SELECT) != true)
                    m_Result = CSLibrary.Constants.Result.FAILURE;
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagReadTidThreadProc()", ex);
#endif
            }
            finally
            {
                /*
                                FireAccessCompletedEvent(
                                    new OnAccessCompletedEventArgs(
                                    m_Result == CSLibrary.Constants.Result.OK,
                                    CSLibrary.Constants.Bank.TID,
                                    CSLibrary.Constants.TagAccess.READ,
                                    m_rdr_opt_parms.TagReadTid.tid));

                                FireStateChangedEvent(CSLibrary.Constants.RFState.IDLE);
                */
            }
        }

        private void TagReadUsrMemThreadProc_CS108()
        {
            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                CurrentOperationResult = CSLibrary.Constants.Result.NO_TAG_FOUND;

                m_rdr_opt_parms.TagReadUser.m_pData = new UInt16[m_rdr_opt_parms.TagReadUser.count];

                m_Result = CSLibrary.Constants.Result.OK;

                if (CUST_18K6CTagRead(
                    CSLibrary.Constants.MemoryBank.USER,
                    m_rdr_opt_parms.TagReadUser.offset,
                    m_rdr_opt_parms.TagReadUser.count,
                    m_rdr_opt_parms.TagReadUser.m_pData,
                    m_rdr_opt_parms.TagReadUser.accessPassword,
                    //m_rdr_opt_parms.TagReadUser.retryCount,
                    CSLibrary.Constants.SelectFlags.SELECT) != true)
                    m_Result = CSLibrary.Constants.Result.FAILURE;
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagReadUsrMemThreadProc()", ex);
#endif
            }
            finally
            {
                /*                FireAccessCompletedEvent(
                                    new OnAccessCompletedEventArgs(
                                    m_Result == CSLibrary.Constants.Result.OK,
                                    Bank.USER,
                                    TagAccess.READ,
                                    m_rdr_opt_parms.TagReadUser.pData));

                                FireStateChangedEvent(CSLibrary.Constants.RFState.IDLE);
                */
            }
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Private.Select.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        private void TagSelected_CS108()
        {
            try
            {
                _tagSelectedParms = (Structures.TagSelectedParms)m_rdr_opt_parms.TagSelected.Clone();

                UInt32 value = 0;

                MacReadRegister(MACREGISTER.HST_TAGACC_DESC_CFG, ref value);
                value |= 0x0001U; // Enable Verify after write
                MacWriteRegister(MACREGISTER.HST_TAGACC_DESC_CFG, value);

                MacReadRegister(MACREGISTER.HST_QUERY_CFG, ref value);
                value &= ~0x0200U; // Enable Ucode Parallel encoding
                MacWriteRegister(MACREGISTER.HST_QUERY_CFG, value);

                SetOperationMode(CSLibrary.Constants.RadioOperationMode.NONCONTINUOUS);
                SetTagGroup(CSLibrary.Constants.Selected.ASSERTED, CSLibrary.Constants.Session.S0, CSLibrary.Constants.SessionTarget.A);
                SetSingulationAlgorithmParms(CSLibrary.Constants.SingulationAlgorithm.FIXEDQ, new CSLibrary.Structures.FixedQParms
                    (
                    m_rdr_opt_parms.TagSelected.Qvalue,//QValue
                    0x5, //Retry
                    (uint)((m_rdr_opt_parms.TagSelected.flags & CSLibrary.Constants.SelectMaskFlags.ENABLE_TOGGLE) == CSLibrary.Constants.SelectMaskFlags.ENABLE_TOGGLE ? 1 : 0),//toggle
                    0)//repeatUntilNoUnit
                    );

                CSLibrary.Structures.SelectCriterion[] sel = new CSLibrary.Structures.SelectCriterion[1];
                sel[0] = new CSLibrary.Structures.SelectCriterion();
                sel[0].action = new CSLibrary.Structures.SelectAction(CSLibrary.Constants.Target.SELECTED,
                    (m_rdr_opt_parms.TagSelected.flags & CSLibrary.Constants.SelectMaskFlags.ENABLE_NON_MATCH) == CSLibrary.Constants.SelectMaskFlags.ENABLE_NON_MATCH ?
                    CSLibrary.Constants.Action.DSLINVB_ASLINVA : CSLibrary.Constants.Action.ASLINVA_DSLINVB, 0);


                if (m_rdr_opt_parms.TagSelected.bank == CSLibrary.Constants.MemoryBank.EPC)
                {
                    sel[0].mask = new CSLibrary.Structures.SelectMask(
                        m_rdr_opt_parms.TagSelected.bank,
                        (uint)((m_rdr_opt_parms.TagSelected.flags & CSLibrary.Constants.SelectMaskFlags.ENABLE_PC_MASK) == CSLibrary.Constants.SelectMaskFlags.ENABLE_PC_MASK ? 16 : 32 + m_rdr_opt_parms.TagSelected.epcMaskOffset),
                        m_rdr_opt_parms.TagSelected.epcMaskLength,
                        m_rdr_opt_parms.TagSelected.epcMask.ToBytes());
                }
                else
                {
                    sel[0].mask = new CSLibrary.Structures.SelectMask(
                        m_rdr_opt_parms.TagSelected.bank,
                        m_rdr_opt_parms.TagSelected.MaskOffset,
                        m_rdr_opt_parms.TagSelected.MaskLength,
                        m_rdr_opt_parms.TagSelected.Mask);
                }
                if ((m_Result = SetSelectCriteria_CS108(sel)) != CSLibrary.Constants.Result.OK)
                {
                    //goto EXIT;
                }
            }
            catch (System.Exception ex)
            {
#if DEBUG
                //CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagSelected()", ex);
#endif
                m_Result = CSLibrary.Constants.Result.SYSTEM_CATCH_EXCEPTION;
            }
        }

        private void TagSelectedDYNQ_CS108()
        {
            try
            {
                _tagSelectedParms = (Structures.TagSelectedParms)m_rdr_opt_parms.TagSelected.Clone();

                UInt32 value = 0;

                MacReadRegister(MACREGISTER.HST_TAGACC_DESC_CFG, ref value);
                value |= 0x0001U; // Enable Verify after write
                MacWriteRegister(MACREGISTER.HST_TAGACC_DESC_CFG, value);

                MacReadRegister(MACREGISTER.HST_QUERY_CFG, ref value);
                value &= ~0x0200U; // Enable Ucode Parallel encoding
                MacWriteRegister(MACREGISTER.HST_QUERY_CFG, value);

                SetOperationMode_CS108(CSLibrary.Constants.RadioOperationMode.NONCONTINUOUS);
                SetTagGroup_CS108(CSLibrary.Constants.Selected.ASSERTED, CSLibrary.Constants.Session.S0, CSLibrary.Constants.SessionTarget.A);
                {
                    CSLibrary.Structures.DynamicQParms param = new CSLibrary.Structures.DynamicQParms();

                    param.startQValue = m_rdr_opt_parms.TagSelected.Qvalue;
                    param.toggleTarget = (uint)((m_rdr_opt_parms.TagSelected.flags & CSLibrary.Constants.SelectMaskFlags.ENABLE_TOGGLE) == CSLibrary.Constants.SelectMaskFlags.ENABLE_TOGGLE ? 1 : 0);
                    param.retryCount = 0x05;

                    SetSingulationAlgorithmParms_CS108(CSLibrary.Constants.SingulationAlgorithm.DYNAMICQ, param);
                }

                CSLibrary.Structures.SelectCriterion[] sel = new CSLibrary.Structures.SelectCriterion[1];
                sel[0] = new CSLibrary.Structures.SelectCriterion();
                sel[0].action = new CSLibrary.Structures.SelectAction(CSLibrary.Constants.Target.SELECTED,
                    (m_rdr_opt_parms.TagSelected.flags & CSLibrary.Constants.SelectMaskFlags.ENABLE_NON_MATCH) == CSLibrary.Constants.SelectMaskFlags.ENABLE_NON_MATCH ?
                    CSLibrary.Constants.Action.DSLINVB_ASLINVA : CSLibrary.Constants.Action.ASLINVA_DSLINVB, 0);

                if (m_rdr_opt_parms.TagSelected.bank == CSLibrary.Constants.MemoryBank.EPC)
                {
                    sel[0].mask = new CSLibrary.Structures.SelectMask(
                        m_rdr_opt_parms.TagSelected.bank,
                        (uint)((m_rdr_opt_parms.TagSelected.flags & CSLibrary.Constants.SelectMaskFlags.ENABLE_PC_MASK) == CSLibrary.Constants.SelectMaskFlags.ENABLE_PC_MASK ? 16 : 32 + m_rdr_opt_parms.TagSelected.epcMaskOffset),
                        m_rdr_opt_parms.TagSelected.epcMaskLength,
                        m_rdr_opt_parms.TagSelected.epcMask.ToBytes());
                }
                else
                {
                    sel[0].mask = new CSLibrary.Structures.SelectMask(
                        m_rdr_opt_parms.TagSelected.bank,
                        m_rdr_opt_parms.TagSelected.MaskOffset,
                        m_rdr_opt_parms.TagSelected.MaskLength,
                        m_rdr_opt_parms.TagSelected.Mask);
                }
                if ((m_Result = SetSelectCriteria_CS108(sel)) != CSLibrary.Constants.Result.OK)
                {
                    //goto EXIT;
                }
            }
            catch (System.Exception ex)
            {
#if DEBUG
                //CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagSelected()", ex);
#endif
                m_Result = CSLibrary.Constants.Result.SYSTEM_CATCH_EXCEPTION;
            }
        }

        /// <summary>
        /// Only set first EPC ID and length (register 0x804-0x807)
        /// </summary>
        private void FastTagSelected_CS108()
        {
            uint registerValue;

            //SelectCriterion pCriterion = SC.pCriteria[index];
            //SelectMask pMask = pCriterion.mask;
            //SelectAction pAction = pCriterion.action;

            // Instruct the MAC as to which select mask we want to work with
            MacWriteRegister(MACREGISTER.HST_TAGMSK_DESC_SEL, 0);

            // Create the HST_TAGMSK_LEN register and write it to the MAC
            registerValue = (uint)(m_rdr_opt_parms.TagSelected.epcMaskLength);
            MacWriteRegister(MACREGISTER.HST_TAGMSK_LEN, registerValue);

            // Now write the MAC's mask registers
            WriteMacMaskRegisters((ushort)MACREGISTER.HST_TAGMSK_0_3, m_rdr_opt_parms.TagSelected.epcMaskLength, m_rdr_opt_parms.TagSelected.epcMask.ToBytes());
            // Set up the selection criteria

        }

        private void PreFilter_CS108()
        {
            try
            {
                UInt32 value = 0;

                MacReadRegister(MACREGISTER.HST_TAGACC_DESC_CFG, ref value);
                value |= 0x0001U; // Enable Verify after write
                MacWriteRegister(MACREGISTER.HST_TAGACC_DESC_CFG, value);

                MacReadRegister(MACREGISTER.HST_QUERY_CFG, ref value);
                value &= ~0x0200U; // Enable Ucode Parallel encoding
                MacWriteRegister(MACREGISTER.HST_QUERY_CFG, value);

                CSLibrary.Structures.SelectCriterion[] sel = new CSLibrary.Structures.SelectCriterion[1];
                sel[0] = new CSLibrary.Structures.SelectCriterion();
                sel[0].action = new CSLibrary.Structures.SelectAction(CSLibrary.Constants.Target.SELECTED,
                    (m_rdr_opt_parms.TagSelected.flags & CSLibrary.Constants.SelectMaskFlags.ENABLE_NON_MATCH) == CSLibrary.Constants.SelectMaskFlags.ENABLE_NON_MATCH ?
                    CSLibrary.Constants.Action.DSLINVB_ASLINVA : CSLibrary.Constants.Action.ASLINVA_DSLINVB, 0);

                //SetTagGroup(CSLibrary.Constants.Selected.ASSERTED, CSLibrary.Constants.Session.S0, CSLibrary.Constants.SessionTarget.A);
                SetTagGroup_CS108(CSLibrary.Constants.Selected.ASSERTED);

                if (m_rdr_opt_parms.TagSelected.bank == CSLibrary.Constants.MemoryBank.EPC)
                {
                    sel[0].mask = new CSLibrary.Structures.SelectMask(
                        m_rdr_opt_parms.TagSelected.bank,
                        (uint)((m_rdr_opt_parms.TagSelected.flags & CSLibrary.Constants.SelectMaskFlags.ENABLE_PC_MASK) == CSLibrary.Constants.SelectMaskFlags.ENABLE_PC_MASK ? 16 : 32 + m_rdr_opt_parms.TagSelected.epcMaskOffset),
                        m_rdr_opt_parms.TagSelected.epcMaskLength,
                        m_rdr_opt_parms.TagSelected.epcMask.ToBytes());
                }
                else
                {
                    sel[0].mask = new CSLibrary.Structures.SelectMask(
                        m_rdr_opt_parms.TagSelected.bank,
                        m_rdr_opt_parms.TagSelected.MaskOffset,
                        m_rdr_opt_parms.TagSelected.MaskLength,
                        m_rdr_opt_parms.TagSelected.Mask);
                }
                if ((m_Result = SetSelectCriteria_CS108(sel)) != CSLibrary.Constants.Result.OK)
                {
                    //goto EXIT;
                }
            }
            catch (System.Exception ex)
            {
#if DEBUG
                //CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagSelected()", ex);
#endif
                m_Result = CSLibrary.Constants.Result.SYSTEM_CATCH_EXCEPTION;
            }
        }

        private void SetMaskThreadProc_CS108()
        {
            try
            {
                //FireStateChangedEvent(RFState.BUSY);

                if (m_rdr_opt_parms.TagGeneralSelected.ParallelEncoding)
                {
                    UInt32 value = 0;

                    MacReadRegister(MACREGISTER.HST_TAGACC_DESC_CFG, ref value);
                    value &= ~0x0001U; // Disable Verify after write
                    MacWriteRegister(MACREGISTER.HST_TAGACC_DESC_CFG, value);

                    MacReadRegister(MACREGISTER.HST_QUERY_CFG, ref value);
                    value |= 0x0200; // Enable Ucode Parallel encoding
                    MacWriteRegister(MACREGISTER.HST_QUERY_CFG, value);
                }
                else
                {
                    UInt32 value = 0;

                    MacReadRegister(MACREGISTER.HST_TAGACC_DESC_CFG, ref value);
                    value |= 0x0001U; // Enable Verify after write
                    MacWriteRegister(MACREGISTER.HST_TAGACC_DESC_CFG, value);

                    MacReadRegister(MACREGISTER.HST_QUERY_CFG, ref value);
                    value &= ~0x0200U; // Enable Ucode Parallel encoding
                    MacWriteRegister(MACREGISTER.HST_QUERY_CFG, value);
                }

                CSLibrary.Structures.SelectCriterion[] sel = new CSLibrary.Structures.SelectCriterion[1];
                sel[0] = new CSLibrary.Structures.SelectCriterion();
                sel[0].action = new CSLibrary.Structures.SelectAction(CSLibrary.Constants.Target.SELECTED,
                    (m_rdr_opt_parms.TagGeneralSelected.flags & CSLibrary.Constants.SelectMaskFlags.ENABLE_NON_MATCH) == CSLibrary.Constants.SelectMaskFlags.ENABLE_NON_MATCH ?
                    CSLibrary.Constants.Action.DSLINVB_ASLINVA : CSLibrary.Constants.Action.ASLINVA_DSLINVB, 0);


                if (m_rdr_opt_parms.TagGeneralSelected.bank == CSLibrary.Constants.MemoryBank.EPC)
                {
                    sel[0].mask = new CSLibrary.Structures.SelectMask(
                        m_rdr_opt_parms.TagGeneralSelected.bank,
                        (uint)((m_rdr_opt_parms.TagGeneralSelected.flags & CSLibrary.Constants.SelectMaskFlags.ENABLE_PC_MASK) == CSLibrary.Constants.SelectMaskFlags.ENABLE_PC_MASK ? 16 : 32 + m_rdr_opt_parms.TagSelected.epcMaskOffset),
                        m_rdr_opt_parms.TagGeneralSelected.epcMaskLength,
                        m_rdr_opt_parms.TagGeneralSelected.epcMask.ToBytes());
                }
                else
                {
                    sel[0].mask = new CSLibrary.Structures.SelectMask(
                        m_rdr_opt_parms.TagGeneralSelected.bank,
                        m_rdr_opt_parms.TagGeneralSelected.MaskOffset,
                        m_rdr_opt_parms.TagGeneralSelected.MaskLength,
                        m_rdr_opt_parms.TagGeneralSelected.Mask);
                }
                if ((m_Result = SetSelectCriteria_CS108(sel)) != CSLibrary.Constants.Result.OK)
                {
                    goto EXIT;
                }
            }
            catch (System.Exception ex)
            {
#if DEBUG
                //CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagSelected()", ex);
#endif
                m_Result = CSLibrary.Constants.Result.SYSTEM_CATCH_EXCEPTION;
            }

            EXIT:

            var abc = 10;

            //FireStateChangedEvent(RFState.IDLE);
        }


    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Private.Write.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        const int MAX_WR_CNT_CS108 = 0x20;

        void Setup18K6CWriteRegisters_CS108(CSLibrary.Constants.MemoryBank WriteBank, uint WriteOffset, uint WriteSize, UInt16[] WriteBuf, uint BufOffset)
        {
            int offset;
            int pcnt = 0;

            // Set up the tag bank register (tells where to write the data)
            MacWriteRegister(MACREGISTER.HST_TAGACC_BANK, (uint)WriteBank);

            // Set the offset
            //MacWriteRegister(MACREGISTER.HST_TAGACC_PTR, WriteOffset);
            MacWriteRegister(MACREGISTER.HST_TAGACC_PTR, 0);

            // Set up the access count register (i.e., number of words to write)
            MacWriteRegister(MACREGISTER.HST_TAGACC_CNT, WriteSize);

            // Set up the HST_TAGWRDAT_N registers.  Fill up a bank at a time.
            for (UInt32 registerBank = 0; WriteSize > 0; registerBank++)
            {
                uint value = 0;

                // Indicate which bank of tag write registers we are going to fill
                MacWriteRegister(MACREGISTER.HST_TAGWRDAT_SEL, registerBank);

                /*
				MacReadRegister(MACREGISTER.MAC_ERROR, ref value);

				if (value == HOSTIF_ERR_SELECTORBNDS)
				{
					MacClearError();
					return;
				}
				*/

                // Write the values to the bank until either the bank is full or we run out of data
                UInt16 registerAddress = (UInt16)MACREGISTER.HST_TAGWRDAT_0;
                offset = 0;

                while ((WriteSize > 0) && (offset < 16 /*RFID_NUM_TAGWRDAT_REGS_PER_BANK*/))
                {
                    // Set up the register and then write it to the MAC
                    UInt32 registerValue = (uint)(WriteBuf[BufOffset + pcnt] | ((WriteOffset + pcnt) << 16));

                    MacWriteRegister((MACREGISTER)(registerAddress), registerValue);

                    pcnt++;
                    registerAddress++;
                    offset++;
                    WriteSize--;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="bank"></param>
        /// <param name="offset"></param>
        /// <param name="count"></param>
        /// <param name="data"></param>
        /// <param name="password"></param>
        /// <param name="retry"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        private CSLibrary.Constants.Result CUST_18K6CTagWrite_CS108(
            CSLibrary.Constants.MemoryBank bank,
            UInt32 offset,
            UInt32 count,
            UInt16[] data,
            UInt32 password,
            CSLibrary.Constants.SelectFlags flags
        )
        {
            if (count > MAX_WR_CNT)
                return CSLibrary.Constants.Result.DEVICE_NOT_SUPPORT;       // too many data


            MacWriteRegister(MACREGISTER.HST_TAGACC_ACCPWD, password);
            Start18K6CRequest(1, flags);
            MacWriteRegister(MACREGISTER.HST_TAGACC_DESC_CFG  /*0xA01*/, (31 << 1) | 0x01); // Enable write verify and set retry count
                                                                                            //MacWriteRegister(MACREGISTER.HST_TAGACC_DESC_CFG  /*0xA01*/, 0x1ff); // Enable write verify and set retry count
            Setup18K6CWriteRegisters(bank, offset, count, data, 0);
            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.WRITE), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (UInt32)CurrentOperation);

            return CSLibrary.Constants.Result.OK;
        }

        private void WriteThreadProc_CS108()
        {
            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                UInt16[] readData = new UInt16[m_rdr_opt_parms.TagWrite.count];
                UInt16[] writeData = m_rdr_opt_parms.TagWrite.pData;
                UInt16[] readCmp = new UInt16[MAX_WR_CNT];
                bool status;

                m_Result = CSLibrary.Constants.Result.OK;

                m_Result = CUST_18K6CTagWrite(
                    m_rdr_opt_parms.TagWrite.bank,
                    (uint)(m_rdr_opt_parms.TagWrite.offset),
                    m_rdr_opt_parms.TagWrite.count,
                    writeData,
                    m_rdr_opt_parms.TagWrite.accessPassword,
                    CSLibrary.Constants.SelectFlags.SELECT);
            }
            catch (System.Exception ex)
            {
#if DEBUG
                //                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagWriteUsrMemThreadProc()", ex);
#endif
            }
            finally
            {
            }
        }

        private void TagWritePCThreadProc_CS108()
        {
            UInt16[] readData = new UInt16[1];
            UInt16[] writeData = new UInt16[1];

            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                //                m_Result = TagWritePC(m_rdr_opt_parms.TagWritePC);

                writeData[0] = m_rdr_opt_parms.TagWritePC.pc;
                                m_Result = CUST_18K6CTagWrite(
                                    CSLibrary.Constants.MemoryBank.EPC,
                                    PC_START_OFFSET,
                                    ONE_WORD_LEN,
                                    writeData,
                                    m_rdr_opt_parms.TagWritePC.accessPassword,
                                    //m_rdr_opt_parms.TagWritePC.retryCount,
                                    //m_rdr_opt_parms.TagWritePC.writeRetryCount,
                                    CSLibrary.Constants.SelectFlags.SELECT);
                }
                catch (System.Exception ex)
                {
    #if DEBUG
    //                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagWritePCThreadProc()", ex);
    #endif
                }
                finally
                {
/*                            FireAccessCompletedEvent(
                        new OnAccessCompletedEventArgs(
                        m_Result == Result.OK,
                        Bank.PC,
                        TagAccess.WRITE,
                        new S_PC(m_rdr_opt_parms.TagWritePC.pc)));

                    FireStateChangedEvent(RFState.IDLE);
*/              }
        }

        private void TagWriteEPCThreadProc_CS108()
        {
            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                UInt16[] readData = new UInt16[m_rdr_opt_parms.TagWriteEPC.count];
                UInt16[] writeData = m_rdr_opt_parms.TagWriteEPC.epc.ToUshorts();
                UInt16[] readCmp = new UInt16[MAX_WR_CNT];
                bool status;

                m_Result = CSLibrary.Constants.Result.OK;

                m_Result = CUST_18K6CTagWrite(
                    CSLibrary.Constants.MemoryBank.EPC,
                    (uint)(EPC_START_OFFSET + m_rdr_opt_parms.TagWriteEPC.offset),
                    m_rdr_opt_parms.TagWriteEPC.count,
                    writeData,
                    m_rdr_opt_parms.TagWriteEPC.accessPassword,
                    //m_rdr_opt_parms.TagWriteEPC.retryCount,
                    //m_rdr_opt_parms.TagWriteEPC.writeRetryCount,
                    CSLibrary.Constants.SelectFlags.SELECT);
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagWriteEPCThreadProc()", ex);
#endif
            }
            finally
            {
/*                FireAccessCompletedEvent(
                    new OnAccessCompletedEventArgs(
                    m_Result == Result.OK,
                    Bank.EPC,
                    TagAccess.WRITE,
                    m_rdr_opt_parms.TagWriteEPC.epc));

                FireStateChangedEvent(RFState.IDLE);
*/            }
        }

        private void TagWriteAccPwdThreadProc_CS108()
        {
            UInt16[] writeData = new UInt16[2];

            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                //                m_Result = TagWriteAccPwd(m_rdr_opt_parms.TagWriteAccPwd);
                writeData[0] = (ushort)(m_rdr_opt_parms.TagWriteAccPwd.password >> 16);
                writeData[1] = (ushort)m_rdr_opt_parms.TagWriteAccPwd.password;

                m_Result = CUST_18K6CTagWrite(
                    CSLibrary.Constants.MemoryBank.RESERVED,
                    ACC_PWD_START_OFFSET,
                    TWO_WORD_LEN,
                    writeData,
                    m_rdr_opt_parms.TagWriteAccPwd.accessPassword,
                    //m_rdr_opt_parms.TagWriteAccPwd.retryCount,
                    //m_rdr_opt_parms.TagWriteAccPwd.writeRetryCount,
                    CSLibrary.Constants.SelectFlags.SELECT);
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagWriteAccPwdThreadProc()", ex);
#endif
            }
            finally
            {
                /*
                FireAccessCompletedEvent(
                    new OnAccessCompletedEventArgs(
                    m_Result == Result.OK,
                    Bank.ACC_PWD,
                    TagAccess.WRITE,
                    new S_PWD(m_rdr_opt_parms.TagWriteAccPwd.password)));

                FireStateChangedEvent(RFState.IDLE);*/
            }
        }

        private void TagWriteKillPwdThreadProc_CS108()
        {
            UInt16[] writeData = new UInt16[2];

            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                //m_Result = TagWriteKillPwd(m_rdr_opt_parms.TagWriteKillPwd);

                writeData[0] = (UInt16)(m_rdr_opt_parms.TagWriteKillPwd.password >> 16);
                writeData[1] = (UInt16)(m_rdr_opt_parms.TagWriteKillPwd.password);

                m_Result = CUST_18K6CTagWrite(
                    CSLibrary.Constants.MemoryBank.RESERVED,
                    KILL_PWD_START_OFFSET,
                    TWO_WORD_LEN,
                    writeData,
                    m_rdr_opt_parms.TagWriteKillPwd.accessPassword,
                    //m_rdr_opt_parms.TagWriteKillPwd.retryCount,
                    //m_rdr_opt_parms.TagWriteKillPwd.writeRetryCount,
                    CSLibrary.Constants.SelectFlags.SELECT);
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagWriteKillPwdThreadProc()", ex);
#endif
            }
            finally
            {
/*                FireAccessCompletedEvent(
                    new OnAccessCompletedEventArgs(
                    m_Result == Result.OK,
                    Bank.KILL_PWD,
                    TagAccess.WRITE,
                    new S_PWD(m_rdr_opt_parms.TagWriteKillPwd.password)));

                FireStateChangedEvent(RFState.IDLE);
*/            }
        }

        private void TagWriteUsrMemThreadProc_CS108()
        {
            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                UInt16[] readData = new UInt16[m_rdr_opt_parms.TagWriteUser.count];
                UInt16[] writeData = m_rdr_opt_parms.TagWriteUser.pData;
                UInt16[] readCmp = new UInt16[MAX_WR_CNT];
                bool status;

                m_Result = CSLibrary.Constants.Result.OK;

                m_Result = CUST_18K6CTagWrite(
                    CSLibrary.Constants.MemoryBank.USER,
                    (uint)(m_rdr_opt_parms.TagWriteUser.offset),
                    m_rdr_opt_parms.TagWriteUser.count,
                    writeData,
                    m_rdr_opt_parms.TagWriteUser.accessPassword,
                    //m_rdr_opt_parms.TagWriteUser.retryCount,
                    //m_rdr_opt_parms.TagWriteUser.writeRetryCount,
                    CSLibrary.Constants.SelectFlags.SELECT);
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagWriteUsrMemThreadProc()", ex);
#endif
            }
            finally
            {
/*                FireAccessCompletedEvent(
                    new OnAccessCompletedEventArgs(
                    m_Result == Result.OK,
                    Bank.USER,
                    TagAccess.WRITE,
                    new S_DATA(m_rdr_opt_parms.TagWriteUser.pData)));

                FireStateChangedEvent(RFState.IDLE);
*/            }
        }

        private void BlockWriteThreadProc_CS108()
        {
            if (m_rdr_opt_parms.TagBlockWrite.retryCount > 31)
            {
                m_Result = Constants.Result.INVALID_PARAMETER;
                return;
            }

            if (m_rdr_opt_parms.TagBlockWrite.count > 255)
            {
                m_Result = Constants.Result.INVALID_PARAMETER;
                return;
            }

            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                m_Result = CSLibrary.Constants.Result.FAILURE;

                MacWriteRegister(MACREGISTER.HST_TAGACC_ACCPWD, m_rdr_opt_parms.TagBlockWrite.accessPassword);
                Start18K6CRequest(1, m_rdr_opt_parms.TagBlockWrite.flags);
                MacWriteRegister(MACREGISTER.HST_TAGACC_DESC_CFG, 0x01 | (m_rdr_opt_parms.TagBlockWrite.retryCount << 1)); // Enable write verify and set retry count

                // Set up the tag bank register (tells where to write the data)
                MacWriteRegister(MACREGISTER.HST_TAGACC_BANK, (uint)m_rdr_opt_parms.TagBlockWrite.bank);

                // Set the offset
                MacWriteRegister(MACREGISTER.HST_TAGACC_PTR, m_rdr_opt_parms.TagBlockWrite.offset);

                // Set up the access count register (i.e., number of words to write)
                MacWriteRegister(MACREGISTER.HST_TAGACC_CNT, m_rdr_opt_parms.TagBlockWrite.count);

                ushort DataSize = m_rdr_opt_parms.TagBlockWrite.count;
                ushort WriteSize = DataSize;
                // Write the values to the bank until either the bank is full or we run out of data
                ushort registerAddress = (UInt16)MACREGISTER.HST_TAGWRDAT_0;
                UInt32 registerBank = 0;
                int pcnt = 0;

                // Set up the HST_TAGWRDAT_N registers.  Fill up a bank at a time.
                for (registerBank = 0; DataSize > 0; registerBank++)
                {
                    // Indicate which bank of tag write registers we are going to fill
                    MacWriteRegister(MACREGISTER.HST_TAGWRDAT_SEL, registerBank);

                    // Write the values to the bank until either the bank is full or we run out of data
                    registerAddress = (UInt16)MACREGISTER.HST_TAGWRDAT_0;

                    Debug.WriteLine("1. datasize:" + DataSize + " writesieze:" + WriteSize);
                    if (DataSize >= 32)
                    {
                        WriteSize = 32;
                        DataSize -= 32;
                    }
                    else
                    {
                        WriteSize = DataSize;
                        DataSize = 0;
                    }
                    Debug.WriteLine("2. datasize:" + DataSize + " writesieze:" + WriteSize);

                    while (WriteSize > 1)
                    {
                        // Set up the register and then write it to the MAC
                        UInt32 registerValue = (UInt32)((UInt32)m_rdr_opt_parms.TagBlockWrite.data[pcnt + 1] | (((UInt32)m_rdr_opt_parms.TagBlockWrite.data[pcnt]) << 16));

                        MacWriteRegister((MACREGISTER)(registerAddress), registerValue);

                        pcnt += 2;
                        registerAddress++;
                        WriteSize -= 2;
                    }

                    if (WriteSize == 1)
                    {
                        // Set up the register and then write it to the MAC
                        UInt32 registerValue = (uint)((UInt32)m_rdr_opt_parms.TagBlockWrite.data[pcnt] << 16);

                        MacWriteRegister((MACREGISTER)(registerAddress), registerValue);
                    }
                }

                _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.BLOCKWRITE), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (UInt32)CurrentOperation);

                m_Result = CSLibrary.Constants.Result.OK;
            }
            catch (System.Exception ex)
            {
            }
            finally
            {
            }
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.Algorithm.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    using Constants;
    using Structures;

    public partial class RFIDReader
    {
        /// <summary>
        /// Allows the application to set the currently-active singulation 
        /// algorithm (i.e., the one that is used when performing a tag-
        /// protocol operation (e.g., inventory, tag read, etc.)).  The 
        /// currently-active singulation algorithm may not be changed while a 
        /// radio module is executing a tag-protocol operation. 
        /// </summary>
        /// <param name="SingulationAlgorithm">
        /// The singulation algorithm that is to be used for 
        /// subsequent tag-access operations.  If this 
        /// parameter does not represent a valid 
        /// singulation algorithm, 
        /// RFID_ERROR_INVALID_PARAMETER is returned. </param>
        public Result SetCurrentSingulationAlgorithm_CS108(SingulationAlgorithm SingulationAlgorithm)
        {
            UInt32 value = 0;

            if (SingulationAlgorithm == SingulationAlgorithm.UNKNOWN)
                return Result.INVALID_PARAMETER;

            MacReadRegister(MACREGISTER.HST_INV_CFG, ref value);

            value &= ~0x3fU;
            value |= (UInt32)SingulationAlgorithm;

            MacWriteRegister(MACREGISTER.HST_INV_CFG, value);

            return Result.OK;
        }

        /// <summary>
        /// Get Current Singulation Algorithm
        /// </summary>
        /// <param name="SingulationAlgorithm"></param>
        /// <returns></returns>
        public Result GetCurrentSingulationAlgorithm_CS108(ref SingulationAlgorithm SingulationAlgorithm)
        {
            UInt32 value = 0;

            MacReadRegister(MACREGISTER.HST_INV_CFG, ref value);
            value &= 0x3fU;
            SingulationAlgorithm = (SingulationAlgorithm)value;
            return Result.OK;
        }

        /// <summary>
        /// SetSingulationAlgorithmParms
        /// </summary>
        /// <param name="alg"></param>
        /// <param name="parms"></param>
        /// <returns></returns>
        public Result SetSingulationAlgorithmParms_CS108(SingulationAlgorithm alg, SingulationAlgorithmParms parms)
        {
            const uint RFID_18K6C_SINGULATION_ALGORITHM_FIXEDQ = 0;
            const uint RFID_18K6C_SINGULATION_ALGORITHM_DYNAMICQ = 3;

            if (alg == SingulationAlgorithm.UNKNOWN)
                return Result.INVALID_PARAMETER;

            try
            {
                switch (alg)
                {
                    case SingulationAlgorithm.FIXEDQ:
                        {
                            FixedQParms p = (FixedQParms)parms;
                            // Write the inventory algorithm parameter registers
                            MacWriteRegister(MACREGISTER.HST_INV_SEL, RFID_18K6C_SINGULATION_ALGORITHM_FIXEDQ);
                            MacWriteRegister(MACREGISTER.HST_INV_ALG_PARM_0, p.qValue);
                            MacWriteRegister(MACREGISTER.HST_INV_ALG_PARM_1, p.retryCount);
                            MacWriteRegister(MACREGISTER.HST_INV_ALG_PARM_2,
                                (uint)(p.toggleTarget != 0 ? 1 : 0) |
                                (uint)(p.repeatUntilNoTags != 0 ? 2 : 0));
                            MacWriteRegister(MACREGISTER.HST_INV_ALG_PARM_3, 0);
                        }
                        break;

                    case SingulationAlgorithm.DYNAMICQ:
                        {
                            DynamicQParms p = (DynamicQParms)parms;
                            // Write the inventory algorithm parameter registers.  For register
                            // zero, remember to preserve values that we aren't exposing
                            MacWriteRegister(MACREGISTER.HST_INV_SEL, RFID_18K6C_SINGULATION_ALGORITHM_DYNAMICQ);
                            MacWriteRegister(MACREGISTER.HST_INV_ALG_PARM_0, p.startQValue | (p.maxQValue << 4) | (p.minQValue << 8) | (p.thresholdMultiplier << 12));
                            MacWriteRegister(MACREGISTER.HST_INV_ALG_PARM_1, p.retryCount);
                            MacWriteRegister(MACREGISTER.HST_INV_ALG_PARM_2, (uint)(p.toggleTarget != 0 ? 1 : 0));
                            MacWriteRegister(MACREGISTER.HST_INV_ALG_PARM_3, 0);
                        }
                        break;

                    default:
                        return Result.INVALID_PARAMETER;
                } // switch (algorithm)
            }
            catch (Exception ex)
            {

            }

            return (m_Result = SetCurrentSingulationAlgorithm_CS108(alg));
        }

        /// <summary>
        /// GetSingulationAlgorithmParms
        /// </summary>
        /// <param name="alg"></param>
        /// <param name="parms"></param>
        /// <returns></returns>
        public Result GetSingulationAlgorithmParms_CS108(SingulationAlgorithm alg, SingulationAlgorithmParms parms)
        {
            const int RFID_18K6C_SINGULATION_ALGORITHM_FIXEDQ = 0;
            const int RFID_18K6C_SINGULATION_ALGORITHM_DYNAMICQ = 3;
            UInt32 parm0Register = 0;
            UInt32 parm1Register = 0;
            UInt32 parm2Register = 0;

            switch (alg)
            {
                case SingulationAlgorithm.FIXEDQ:
                    {
                        FixedQParms m_fixedQ = (FixedQParms)parms;

                        // Tell the MAC which singulation algorithm selector to use and then
                        // read the singulation algorithm registers
                        MacWriteRegister(MACREGISTER.HST_INV_SEL, RFID_18K6C_SINGULATION_ALGORITHM_FIXEDQ);
                        MacReadRegister(MACREGISTER.HST_INV_ALG_PARM_0, ref parm0Register);
                        MacReadRegister(MACREGISTER.HST_INV_ALG_PARM_1, ref parm1Register);
                        MacReadRegister(MACREGISTER.HST_INV_ALG_PARM_2, ref parm2Register);

                        // Set up the fixed Q singulation algorithm structure
                        //m_fixedQ.length = sizeof(FixedQParms);
                        m_fixedQ.qValue = parm0Register & 0x0f;
                        m_fixedQ.retryCount = parm1Register & 0xff;
                        m_fixedQ.toggleTarget = (parm2Register & 0x01) != 0 ? (uint)1 : (uint)0;
                        m_fixedQ.repeatUntilNoTags = (parm2Register & 0x02) != 0 ? (uint)1 : (uint)0;
                    }
                    break;

                case SingulationAlgorithm.DYNAMICQ:
                    {
                        DynamicQParms m_dynQ = (DynamicQParms)parms;

                        // Tell the MAC which singulation algorithm selector to use and then
                        // read the singulation algorithm registers
                        MacWriteRegister(MACREGISTER.HST_INV_SEL, RFID_18K6C_SINGULATION_ALGORITHM_DYNAMICQ);

                        MacReadRegister(MACREGISTER.HST_INV_ALG_PARM_0, ref parm0Register);
                        MacReadRegister(MACREGISTER.HST_INV_ALG_PARM_1, ref parm1Register);
                        MacReadRegister(MACREGISTER.HST_INV_ALG_PARM_2, ref parm2Register);

                        // Extract the dynamic-Q with Q-adjustment threshold singulation algorithm
                        // parameters
                        //m_dynQ.length = sizeof(DynamicQParms);
                        m_dynQ.startQValue = parm0Register & 0x0f;
                        m_dynQ.minQValue = (parm0Register >> 8) & 0x0f;
                        m_dynQ.maxQValue = (parm0Register >> 4) & 0x0f;
                        m_dynQ.thresholdMultiplier = (parm0Register >> 12) & 0x3f;
                        m_dynQ.retryCount = parm1Register;
                        m_dynQ.toggleTarget = (parm2Register & 0x01) != 0 ? (uint)1 : (uint)0;
                    }
                    break;

                default:
                    return Result.INVALID_PARAMETER;
            }

            return Result.OK;
        }
        /// <summary>
        /// Get FixedQ Singulation Algorithm
        /// </summary>
        /// <param name="fixedQ"></param>
        /// <returns></returns>
        public Result GetFixedQParms_CS108(FixedQParms fixedQ)
        {
            return (m_Result = GetSingulationAlgorithmParms_CS108(SingulationAlgorithm.FIXEDQ, fixedQ));
        }
        /// <summary>
        /// The  parameters  for  the  fixed-Q  algorithm,  MAC  singulation  algorithm  0
        /// If running a same operation, it only need to config once times
        /// </summary>
        /// <param name="QValue">The Q value to use.  Valid values are 0-15, inclusive.</param>
        /// <param name="RetryCount">Specifies the number of times to try another execution 
        /// of the singulation algorithm for the specified 
        /// session/target before either toggling the target (if 
        /// toggleTarget is non-zero) or terminating the 
        /// inventory/tag access operation.  Valid values are 0-
        /// 255, inclusive. Valid values are 0-255, inclusive.</param>
        /// <param name="ToggleTarget"> A non-zero value indicates that the target should
        /// be toggled.A zero value indicates that the target should not be toggled.
        /// Note that if the target is toggled, retryCount and repeatUntilNoTags will also apply
        /// to the new target. </param>
        /// <param name="RepeatUnitNoTags">A flag that indicates whether or not the singulation 
        /// algorithm should continue performing inventory rounds 
        /// until no tags are singulated.  A non-zero value indicates 
        /// that, for each execution of the singulation algorithm, 
        /// inventory rounds should be performed until no tags are 
        /// singulated.  A zero value indicates that a single 
        /// inventory round should be performed for each 
        /// execution of the singulation algorithm.</param>
        public Result SetFixedQParms_CS108(uint QValue, uint RetryCount, uint ToggleTarget, uint RepeatUnitNoTags)
        {
            FixedQParms FixedQParm = new FixedQParms();
            FixedQParm.qValue = QValue;      //if only 1 tag read and write, otherwise use 7
            FixedQParm.retryCount = RetryCount;
            FixedQParm.toggleTarget = ToggleTarget;
            FixedQParm.repeatUntilNoTags = RepeatUnitNoTags;

            return (m_Result = SetSingulationAlgorithmParms_CS108(SingulationAlgorithm.FIXEDQ, FixedQParm));
        }
        /// <summary>
        /// The  parameters  for  the  fixed-Q  algorithm,  MAC  singulation  algorithm  0
        /// If running a same operation, it only need to config once times
        /// </summary>
        /// <returns></returns>
        public Result SetFixedQParms_CS108(FixedQParms fixedQParm)
        {
            return (m_Result = SetSingulationAlgorithmParms_CS108(SingulationAlgorithm.FIXEDQ, fixedQParm));
        }
        /// <summary>
        /// The  parameters  for  the  fixed-Q  algorithm,  MAC  singulation  algorithm  0
        /// If running a same operation, it only need to config once times
        /// </summary>
        /// <returns></returns>
        public Result SetFixedQParms_CS108()
        {
            FixedQParms FixedQParm = new FixedQParms();
            FixedQParm.qValue = 7;      //if only 1 tag read and write, otherwise use 7
            FixedQParm.retryCount = 0;
            FixedQParm.toggleTarget = 1;
            FixedQParm.repeatUntilNoTags = 1;

            return (m_Result = SetSingulationAlgorithmParms_CS108(SingulationAlgorithm.FIXEDQ, FixedQParm));
        }

        /// <summary>
        /// Get DynamicQ Singulation Algorithm
        /// </summary>
        /// <param name="parms"></param>
        /// <returns></returns>
        public Result GetDynamicQParms_CS108(DynamicQParms parms)
        {
            return (m_Result = GetSingulationAlgorithmParms_CS108(SingulationAlgorithm.DYNAMICQ, parms));
        }
        /// <summary>
        /// The parameters for the dynamic-Q algorithm with application-controlled Q-adjustment-threshold, MAC singulation algorithm 3
        /// </summary>
        /// <param name="StartQValue">The starting Q value to use.  Valid values are 0-15, inclusive.  
        /// startQValue must be greater than or equal to minQValue and 
        /// less than or equal to maxQValue. </param>
        /// <param name="MinQValue">The minimum Q value to use.  Valid values are 0-15, inclusive.  
        /// minQValue must be less than or equal to startQValue and 
        /// maxQValue. </param>
        /// <param name="MaxQValue">The maximum Q value to use.  Valid values are 0-15, inclusive.  
        /// maxQValue must be greater than or equal to startQValue and 
        /// minQValue. </param>
        /// <param name="RetryCount">Specifies the number of times to try another execution of 
        /// the singulation algorithm for the specified session/target 
        /// before either toggling the target (if toggleTarget is non-
        /// zero) or terminating the inventory/tag access operation.  
        /// Valid values are 0-255, inclusive. </param>
        /// <param name="ThresholdMultiplier">The multiplier, specified in units of fourths (i.e., 0.25), that will be 
        /// applied to the Q-adjustment threshold as part of the dynamic-Q 
        /// algorithm.  For example, a value of 7 represents a multiplier of 
        /// 1.75.  See [MAC-EDS] for specifics on how the Q-adjustment 
        /// threshold is used in the dynamic Q algorithm.  Valid values are 0-
        /// 255, inclusive. </param>
        /// <param name="ToggleTarget">A flag that indicates if, after performing the inventory cycle for the 
        /// specified target (i.e., A or B), if the target should be toggled (i.e., 
        /// A to B or B to A) and another inventory cycle run.  A non-zero 
        /// value indicates that the target should be toggled.  A zero value 
        /// indicates that the target should not be toggled.  Note that if the 
        /// target is toggled, retryCount and maxQueryRepCount will 
        /// also apply to the new target. </param>
        public Result SetDynamicQParms_CS108(uint StartQValue, uint MinQValue, uint MaxQValue, uint RetryCount, uint ThresholdMultiplier, uint ToggleTarget)
        {
            DynamicQParms dynParm = new DynamicQParms();
            dynParm.startQValue = StartQValue;
            dynParm.maxQValue = MaxQValue;      //if only 1 tag read and write, otherwise use 7
            dynParm.minQValue = MinQValue;
            dynParm.retryCount = RetryCount;
            dynParm.thresholdMultiplier = ThresholdMultiplier;
            dynParm.toggleTarget = ToggleTarget;

            return (m_Result = SetSingulationAlgorithmParms_CS108(SingulationAlgorithm.DYNAMICQ, dynParm));
        }
        /// <summary>
        /// The parameters for the dynamic-Q algorithm with application-controlled Q-adjustment-threshold, MAC singulation algorithm 3
        /// </summary>
        /// <returns></returns>
        public Result SetDynamicQParms_CS108(DynamicQParms dynParm)
        {
            return (m_Result = SetSingulationAlgorithmParms_CS108(SingulationAlgorithm.DYNAMICQ, dynParm));
        }
        /// <summary>
        /// The parameters for the dynamic-Q algorithm with application-controlled Q-adjustment-threshold, MAC singulation algorithm 3
        /// </summary>
        /// <returns></returns>
        public Result SetDynamicQParms_CS108()
        {
            DynamicQParms dynParm = new DynamicQParms();
            dynParm.startQValue = 7;
            dynParm.maxQValue = 15;      //if only 1 tag read and write, otherwise use 7
            dynParm.minQValue = 0;
            dynParm.retryCount = 0;
            dynParm.thresholdMultiplier = 4;
            dynParm.toggleTarget = 1;

            return (m_Result = SetSingulationAlgorithmParms_CS108(SingulationAlgorithm.DYNAMICQ, dynParm));
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.Antenna.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Text;

using CSLibrary.Constants;
using CSLibrary.Structures;


namespace CSLibrary
{
    using Constants;
    using Structures;

    public partial class RFIDReader
    {
        const uint HOSTIF_ERR_SELECTORBNDS = 0x010E;
        public Result AntennaPortSetState_CS108(UInt32 antennaPort, AntennaPortState state)
        {
            uint registerValue = 0;

            // First, tell the MAC which antenna descriptors we'll be reading and
            // verify that it was a valid selector
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_SEL, antennaPort);

            /*
            MacReadRegister(MACREGISTER.MAC_ERROR, ref registerValue);

            if (registerValue == HOSTIF_ERR_SELECTORBNDS)
            {
                MacClearError();
                return Result.INVALID_PARAMETER;
            }
            */

            // Read the current value of the anteann port configuration
            MacReadRegister(MACREGISTER.HST_ANT_DESC_CFG, ref registerValue);

            // Now set the enabled bit appropriately
            switch (state)
            {
                case AntennaPortState.DISABLED:
                    {
                        registerValue &= ~((uint)1);
                        break;
                    } // case RFID_ANTENNA_PORT_STATE_DISABLED
                case AntennaPortState.ENABLED:
                    {
                        registerValue |= 1;
                        break;
                    } // case RFID_ANTENNA_PORT_STATE_ENABLED
                default:
                    return Result.INVALID_PARAMETER;
            } // switch (state)

            // Write back the configuration register
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_CFG, registerValue);

            return Result.OK;

        } // Radio::SetAntennaPortState
    }
}

#if oldcode
namespace CSLibrary
{
    public partial class RFIDReader
    {
        //AntennaList m_AntennaList = nullnew AntennaList(AntennaList.DEFAULT_ANTENNA_LIST, true);
        AntennaList m_AntennaList = null;

        public AntennaList AntennaList
        {
            get { lock (m_AntennaList) return m_AntennaList; }
            set { lock (m_AntennaList) m_AntennaList = value; }
        }

        public Result SetDefaultAntennaList()
        {
            //DEBUG_WriteLine(DEBUGLEVEL.API, "HighLevelInterface.SetDefaultAntennaList()");
            
            m_AntennaList = new AntennaList();

            switch (m_oem_machine)
            {
                case Machine.CS108:
                default:
                    m_AntennaList.Add(new Antenna(0, AntennaPortState.ENABLED, 300, 0, 0x2000, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    break;

                case Machine.CS203X:
                    m_AntennaList.Add(new Antenna(0, AntennaPortState.ENABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(1, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    break;

                case Machine.CS463:
                    m_AntennaList.Add(new Antenna(0, AntennaPortState.ENABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(1, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(2, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(3, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    break;

                case Machine.CS468X:
                case Machine.CS468XJ:
                    m_AntennaList.Add(new Antenna(0, AntennaPortState.ENABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(1, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(2, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(3, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(4, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(5, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(6, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(7, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(8, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(9, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(10, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(11, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(12, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(13, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(14, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(15, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    break;
            }

            try
            {
                int i;
                //m_AntennaList = new AntennaList(AntennaList.DEFAULT_ANTENNA_LIST, true);
                for (i = 0; i < m_AntennaList.Count; i++)
                {
                    if (m_AntennaList[i].PowerLevel > GetSoftwareMaxPowerLevel(m_save_region_code))
                        m_AntennaList[i].PowerLevel = GetSoftwareMaxPowerLevel(m_save_region_code);

                    SetAntennaPortStatus((uint)i, m_AntennaList[i].AntennaStatus);
                    SetAntennaPortConfiguration((uint)i, m_AntennaList[i].AntennaConfig);
                }

                for (; i < 16; i++)
                {
                    AntennaPortSetState((uint)i, AntennaPortState.DISABLED);
                    //SetAntennaPortState((uint)i, AntennaPortState.DISABLED);  
                }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("HighLevelInterface.SetDefaultAntennaList() : " + ex.Message);
                //DEBUG_WriteLine(DEBUGLEVEL.API, "HighLevelInterface.SetDefaultAntennaList() : " + ex.Message);
                //CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.SetDefaultAntennaList()", ex);
            }

            return Result.OK;
        }

        /// <summary>
        /// Retrieves the status of the requested logical antenna port for a 
        /// particular radio module.  The antenna-port status cannot be 
        /// retrieved while a radio module is executing a tag-protocol 
        /// operation. 
        /// </summary>
        /// <param name="portStatus"></param>
        /// <returns></returns>
        public Result GetAntennaPortStatus(AntennaPortStatus portStatus)
        {
            return (m_Result = AntennaPortGetStatus(0, portStatus));
        }

        /// <summary>
        /// Retrieves the status of the requested logical antenna port for a 
        /// particular radio module.  The antenna-port status cannot be 
        /// retrieved while a radio module is executing a tag-protocol 
        /// operation. 
        /// </summary>
        /// <param name="port">antenna port</param>
        /// <param name="portStatus"></param>
        /// <returns></returns>
        public Result GetAntennaPortStatus(uint port, AntennaPortStatus portStatus)
        {
            return (m_Result = AntennaPortGetStatus(port, portStatus));
        }

        public Result AntennaPortGetStatus(uint port, AntennaPortStatus portStatus)
        {
            UInt32 registerValue = 0;

            // First, tell the MAC which antenna descriptors we'll be reading and
            // verify that it was a valid selector
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_SEL, port);

            /*
            MacReadRegister(MACREGISTER.MAC_ERROR, ref registerValue);

            if (registerValue == HOSTIF_ERR_SELECTORBNDS)
            {
                MacClearError();
                return Result.INVALID_PARAMETER;
            }
            */

            // Get the state of the antenna
            MacReadRegister(MACREGISTER.HST_ANT_DESC_CFG, ref registerValue);

            portStatus.state = ((registerValue & 0x01) != 0x00 ? AntennaPortState.ENABLED : AntennaPortState.DISABLED);
            portStatus.enableLocalInv = (registerValue & (1 << 1)) != 00;
            portStatus.inv_algo = (SingulationAlgorithm)(registerValue >> 2 & 0x03);
            portStatus.startQ = registerValue >> 4 & 0x0f;
            portStatus.enableLocalProfile = (registerValue & (1 << 8)) != 00;
            portStatus.profile = registerValue >> 9 & 0x0f;
            portStatus.enableLocalFreq = (registerValue & (1 << 13)) != 00;
            portStatus.freqChn = registerValue >> 14 & 0x3f;

            // Now read the anteanna sense value
            MacReadRegister(MACREGISTER.MAC_ANT_DESC_STAT, ref registerValue);
            portStatus.antennaSenseValue = registerValue;

            return Result.OK;
        }

        /// <summary>
        /// Retrieves the status of the requested logical antenna port for a 
        /// particular radio module.  The antenna-port status cannot be 
        /// retrieved while a radio module is executing a tag-protocol 
        /// operation. 
        /// </summary>
        /// <param name="portStatus"></param>
        /// <returns></returns>
        public Result SetAntennaPortStatus(AntennaPortStatus portStatus)
        {
            return (m_Result = AntennaPortSetStatus(0, portStatus));
        }

        /// <summary>
        /// Retrieves the status of the requested logical antenna port for a 
        /// particular radio module.  The antenna-port status cannot be 
        /// retrieved while a radio module is executing a tag-protocol 
        /// operation. 
        /// </summary>
        /// <param name="port">antenna port</param>
        /// <param name="portStatus"></param>
        /// <returns></returns>
        public Result SetAntennaPortStatus(uint port, AntennaPortStatus portStatus)
        {
            m_AntennaList[(int)port].AntennaStatus = portStatus;

            return (m_Result = AntennaPortSetStatus(port, portStatus));
        }

        public Result AntennaPortSetStatus(uint port, AntennaPortStatus portStatus)
        {
            UInt32 registerValue = 0;

            // First, tell the MAC which antenna descriptors we'll be reading and
            // verify that it was a valid selector
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_SEL, port);

            /*MacReadRegister(MACREGISTER.MAC_ERROR, ref registerValue);

            if (registerValue == HOSTIF_ERR_SELECTORBNDS)
            {
                MacClearError();
                return Result.INVALID_PARAMETER;
            }
            */

            // Read the current value of the anteann port configuration
            MacReadRegister(MACREGISTER.HST_ANT_DESC_CFG, ref registerValue);

            registerValue &= 0xfff00000;

            // Now set the enabled bit appropriately
            switch (portStatus.state)
            {
                case AntennaPortState.DISABLED:
                    {
                        //HST_ANT_DESC_CFG_SET_DISABLED//(registerValue);
                        registerValue &= ~((uint)1);
                        break;
                    } // case RFID_ANTENNA_PORT_STATE_DISABLED
                case AntennaPortState.ENABLED:
                    {
                        //HST_ANT_DESC_CFG_SET_ENABLED(registerValue);
                        registerValue |= 1;
                        break;
                    } // case RFID_ANTENNA_PORT_STATE_ENABLED
                default:
                    {
                        return Result.INVALID_PARAMETER;
                        break;
                    } // default
            } // switch (state)

            if (portStatus.easAlarm)
            {
                registerValue |= 1U << 20;
            }
            else
            {
                registerValue &= ~(1U << 20);
            }

            if (portStatus.enableLocalInv)
            {
                //HST_ANT_DESC_CFG_SET_LOCAL_INV(registerValue);
                //HST_ANT_DESC_CFG_SET_INV_ALGO(registerValue, pStatus->inv_algo);
                //HST_ANT_DESC_CFG_SET_STARTQ(registerValue, pStatus->startQ);
                registerValue |= 1 << 1;
                registerValue |= (uint)portStatus.inv_algo << 2;
                registerValue |= (uint)portStatus.startQ << 4;
            }
            else
            {
                //HST_ANT_DESC_CFG_SET_GLOBAL_INV(registerValue);
                registerValue &= ~((uint)1 << 1);
            }

            if (portStatus.enableLocalProfile)
            {
                //HST_ANT_DESC_CFG_SET_LOCAL_PROFILE(registerValue);
                //HST_ANT_DESC_CFG_SET_PROFILE(registerValue, pStatus->profile);
                registerValue |= (uint)1 << 8;
                registerValue |= (uint)portStatus.profile << 9;
            }
            else
            {
                //HST_ANT_DESC_CFG_SET_GLOBAL_PROFILE(registerValue);
                registerValue &= ~((uint)1 << 8);
            }

            if (portStatus.enableLocalFreq)
            {
                //HST_ANT_DESC_CFG_SET_LOCAL_FREQ(registerValue);
                //HST_ANT_DESC_CFG_SET_FREQ_CHN(registerValue, pStatus->freqChn);
                registerValue |= (uint)1 << 13;
                registerValue |= (uint)portStatus.freqChn << 14;
            }
            else
            {
                //HST_ANT_DESC_CFG_SET_GLOBAL_FREQ(registerValue);
                registerValue &= ~((uint)1 << 13);
            }

            // Write back the configuration register
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_CFG, registerValue);

            return Result.OK;
        }

        /// <summary>
        /// Allows an application to specify whether or not a radio module's 
        /// logical antenna port is enabled for subsequent tag operations.  The 
        /// antenna-port state cannot be set while a radio module is executing 
        /// a tag-protocol operation. 
        /// </summary>
        /// <param name="portState">The new state of the logical antenna port. </param>
        /// <returns></returns>
        public Result SetAntennaPortState(AntennaPortState portState)
        {
            if (portState == AntennaPortState.UNKNOWN)
                return Result.INVALID_PARAMETER;

            return (m_Result = AntennaPortSetState(0, portState));
        }

        /// <summary>
        /// Allows an application to specify whether or not a radio module's 
        /// logical antenna port is enabled for subsequent tag operations.  The 
        /// antenna-port state cannot be set while a radio module is executing 
        /// a tag-protocol operation. 
        /// </summary>
        /// <param name="port">antenna port</param>
        /// <param name="portState">The new state of the logical antenna port.</param>
        /// <returns></returns>
        public Result SetAntennaPortState(uint port, AntennaPortState portState)
        {
            if (portState == AntennaPortState.UNKNOWN)
                return Result.INVALID_PARAMETER;

            m_AntennaList[(int)port].State = portState;

            return (m_Result = AntennaPortSetState(port, portState));
        }

        const uint HOSTIF_ERR_SELECTORBNDS = 0x010E;
        public Result AntennaPortSetState(UInt32 antennaPort, AntennaPortState state)
        {
            uint registerValue = 0;

            // First, tell the MAC which antenna descriptors we'll be reading and
            // verify that it was a valid selector
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_SEL, antennaPort);

            /*
            MacReadRegister(MACREGISTER.MAC_ERROR, ref registerValue);

            if (registerValue == HOSTIF_ERR_SELECTORBNDS)
            {
                MacClearError();
                return Result.INVALID_PARAMETER;
            }
            */

            // Read the current value of the anteann port configuration
            MacReadRegister(MACREGISTER.HST_ANT_DESC_CFG, ref registerValue);

            // Now set the enabled bit appropriately
            switch (state)
            {
                case AntennaPortState.DISABLED:
                    {
                        registerValue &= ~((uint)1);
                        break;
                    } // case RFID_ANTENNA_PORT_STATE_DISABLED
                case AntennaPortState.ENABLED:
                    {
                        registerValue |= 1;
                        break;
                    } // case RFID_ANTENNA_PORT_STATE_ENABLED
                default:
                    return Result.INVALID_PARAMETER;
            } // switch (state)

            // Write back the configuration register
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_CFG, registerValue);

            return Result.OK;

        } // Radio::SetAntennaPortState


        /// <summary>
        /// Allows an application to retrieve a single logical antenna port's 
        /// configuration parameters  e.g., dwell time, power level, and 
        /// number of inventory cycles.  Even if the logical antenna port is 
        /// disabled, an application is allowed to retrieve these configuration 
        /// parameters.  Retrieving configuration parameters does not cause a 
        /// logical antenna port to be automatically enabled; the application 
        /// must still enable the logical antenna port via 
        /// RFID_AntennaPortSetState.  The antenna-port configuration 
        /// cannot be retrieved while a radio module is executing a tag-
        /// protocol operation. 
        /// </summary>
        /// <param name="antenna">A structure that upon return will 
        /// contain the antenna-port configuration 
        /// parameters. </param>
        /// <returns>
        /// </returns>
        public Result GetAntennaPortConfiguration(ref AntennaPortConfig antenna)
        {
            AntennaPortGetConfiguration(0, antenna);

            return Result.OK;
        }

        /// <summary>
        /// Allows an application to retrieve a single logical antenna port's 
        /// configuration parameters  e.g., dwell time, power level, and 
        /// number of inventory cycles.  Even if the logical antenna port is 
        /// disabled, an application is allowed to retrieve these configuration 
        /// parameters.  Retrieving configuration parameters does not cause a 
        /// logical antenna port to be automatically enabled; the application 
        /// must still enable the logical antenna port via 
        /// RFID_AntennaPortSetState.  The antenna-port configuration 
        /// cannot be retrieved while a radio module is executing a tag-
        /// protocol operation. 
        /// </summary>
        /// <param name="port">antenna-port</param>
        /// <param name="antenna">A structure that upon return will 
        /// contain the antenna-port configuration 
        /// parameters. </param>
        /// <returns>
        /// </returns>
        public Result GetAntennaPortConfiguration(uint port, ref AntennaPortConfig antenna)
        {
            AntennaPortGetConfiguration(port, antenna);

            return Result.OK;
        }

        Result AntennaPortGetConfiguration(uint port, AntennaPortConfig antenna)
        {
            UInt32 registerValue = 0;

            // First, tell the MAC which antenna descriptors we'll be reading and
            // verify that it was a valid selector
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_SEL, port);

            /*
            MacReadRegister(MACREGISTER.MAC_ERROR, ref registerValue);

            if (registerValue == HOSTIF_ERR_SELECTORBNDS)
            {
                MacClearError();
                return Result.INVALID_PARAMETER;
            }
            */

            // Read the antenna dwell time, RF power, inventory cycle count, and 
            // sense resistor registers
            MacReadRegister(MACREGISTER.HST_ANT_DESC_DWELL, ref antenna.dwellTime);
            MacReadRegister(MACREGISTER.HST_ANT_DESC_RFPOWER, ref antenna.powerLevel);
            MacReadRegister(MACREGISTER.HST_ANT_DESC_INV_CNT, ref antenna.numberInventoryCycles);
            //MacReadRegister(MacRegister.HST_RFTC_ANTSENSRESTHRSH, ref antenna.antennaSenseThreshold);

            return Result.OK;
        }

        /// <summary>
        /// Allows an application to configure several parameters for a single 
        /// logical antenna port e.g.,  dwell time, power level, and number 
        /// of inventory cycles.  Even if the logical antenna port is disabled, 
        /// an application is allowed to set these configuration parameters.  
        /// Setting configuration parameters does not cause a logical antenna 
        /// port to be automatically enabled; the application must still enable 
        /// the logical antenna port via RFID_AntennaPortSetState.  The 
        /// antenna-port configuration cannot be set while a radio module is 
        /// executing a tag-protocol operation. 
        /// NOTE:  Since RFID_AntennaPortSetConfiguration sets all of the 
        /// configuration parameters that are present in the 
        /// RFID_ANTENNA_PORT_CONFIG structure, if an application wishes to 
        /// leave some parameters unchanged, the application should first call 
        /// RFID_AntennaPortGetConfiguration to retrieve the current 
        /// settings, update the values in the structure that are to be 
        /// changed, and then call RFID_AntennaPortSetConfiguration. 
        /// </summary>
        /// <param name="antenna">A structure that contains the 
        /// antenna-port configuration parameters.  This 
        /// parameter must not be NULL.  In version 1.1, 
        /// the physicalRxPort and physicalTxPort 
        /// fields must be the same. </param>
        /// <returns></returns>
        public Result SetAntennaPortConfiguration(AntennaPortConfig antenna)
        {
            if (antenna == null)
                return Result.INVALID_PARAMETER;

            return (m_Result = AntennaPortSetConfiguration(0, antenna));
        }

        /// <summary>
        /// Allows an application to configure several parameters for a single 
        /// logical antenna port e.g.,  dwell time, power level, and number 
        /// of inventory cycles.  Even if the logical antenna port is disabled, 
        /// an application is allowed to set these configuration parameters.  
        /// Setting configuration parameters does not cause a logical antenna 
        /// port to be automatically enabled; the application must still enable 
        /// the logical antenna port via RFID_AntennaPortSetState.  The 
        /// antenna-port configuration cannot be set while a radio module is 
        /// executing a tag-protocol operation. 
        /// NOTE:  Since RFID_AntennaPortSetConfiguration sets all of the 
        /// configuration parameters that are present in the 
        /// RFID_ANTENNA_PORT_CONFIG structure, if an application wishes to 
        /// leave some parameters unchanged, the application should first call 
        /// RFID_AntennaPortGetConfiguration to retrieve the current 
        /// settings, update the values in the structure that are to be 
        /// changed, and then call RFID_AntennaPortSetConfiguration. 
        /// </summary>
        /// <param name="port">antenna-port</param>
        /// <param name="antenna">A structure that contains the 
        /// antenna-port configuration parameters.  This 
        /// parameter must not be NULL.  In version 1.1, 
        /// the physicalRxPort and physicalTxPort 
        /// fields must be the same. </param>
        /// <returns></returns>
        public Result SetAntennaPortConfiguration(uint port, AntennaPortConfig antenna)
        {
            if (antenna == null)
                return Result.INVALID_PARAMETER;

            if (antenna.powerLevel > GetSoftwareMaxPowerLevel(m_save_region_code))
                return (m_Result = Result.INVALID_PARAMETER);

            m_AntennaList[(int)port].AntennaConfig = antenna;

            return (m_Result = AntennaPortSetConfiguration(port, antenna));
        }

        private Result SetAntennaPortConfiguration(uint virtual_port, uint physical_port)
        {
            AntennaPortConfig antenna = new AntennaPortConfig();

            if ((m_Result = AntennaPortGetConfiguration(virtual_port, antenna)) != Result.OK)
                return m_Result;

            return (m_Result = AntennaPortSetConfiguration(virtual_port, antenna));
        }

        Result AntennaPortSetConfiguration(uint port, AntennaPortConfig antenna)
        {
            UInt32 registerValue = 0;

            // First, tell the MAC which antenna descriptors we'll be reading and
            // verify that it was a valid selector
            MacWriteRegister( MACREGISTER.HST_ANT_DESC_SEL, port);

            /*
            MacReadRegister(MACREGISTER.MAC_ERROR, ref registerValue);

            if (registerValue == HOSTIF_ERR_SELECTORBNDS)
            {
                MacClearError();
                return Result.INVALID_PARAMETER;
            }
            */

            // Write the antenna dwell, RF power, inventory cycle count, and sense
            // resistor threshold registers
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_DWELL, antenna.dwellTime);

            MacWriteRegister(MACREGISTER.HST_ANT_DESC_RFPOWER, antenna.powerLevel);

            MacWriteRegister(MACREGISTER.HST_ANT_DESC_INV_CNT, antenna.numberInventoryCycles);

            return Result.OK;
        }

        public uint GetAntennaPort()
        {
            return (uint)m_AntennaList.Count;
		}

    }
}
#endif
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.Country.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;

namespace CSLibrary
{
    using static FrequencyBand;
    using static FrequencyBand_CS710S;

    public partial class RFIDReader
    {
        /*
        /// <summary>
        /// If true, it can only set to hopping channel.
        /// </summary>
        internal bool IsHoppingChannelOnly
        {
            get { return m_oem_freq_modification_flag != 0x00; }
        }

        /// <summary>
        /// If true, it can only set to fixed channel.
        /// Otherwise, both fixed and hopping can be set.
        /// </summary>
        internal bool IsFixedChannelOnly_CS108
        {
            get { return (m_oem_country_code == 1 | m_save_country_code == 3 | m_save_country_code == 8 | m_save_country_code == 9); }
        }

        /// <summary>
        /// Get Fixed frequency channel
        /// </summary>
        internal bool IsFixedChannel_CS108
        {
            get { { return m_save_fixed_channel; } }
        }
        */

        /// <summary>
        /// GetCountryCode
        /// </summary>
        /// <returns>Result</returns>
        public Result GetCountryCode(ref uint code)
        {
            code = m_oem_country_code;

            if (code < 0 || code > 8)
                return Result.INVALID_OEM_COUNTRY_CODE;

            return Result.OK;
        }

        /// <summary>
        /// Available region you can use
        /// </summary>
        public List<RegionCode> GetActiveRegionCode()
        {
            //DEBUG_WriteLine(DEBUGLEVEL.API, "HighLevelInterface.GetActiveRegionCode()");

            return m_save_country_list;
        }

        /// <summary>
        /// Get Region Profile
        /// </summary>
        public RegionCode SelectedRegionCode
        {
            get { return m_save_region_code; }
        }

        // Get Active Country Name List
        private string[] GetActiveRegionNameList_CS108()
        {
            return m_save_country_list_name.ToArray();
        }

        private bool IsHopping_CS108(string CountryName)
        {
            var item = FrequencyBand.frequencySet.Find(i => i.name.Equals(CountryName));

            if (item == null)
            {
                return false;
            }

            return (item.hopping);
        }

        private bool IsHopping_CS108(RegionCode region)
        {
            var item = FrequencyBand.frequencySet.Find(i => i.code == region);

            if (item == null)
            {
                return false;
            }

            return (item.hopping);
        }

        public bool IsFixed_CS108(string CountryName)
        {
            var item = FrequencyBand_CS710S.frequencySet.Find(i => i.name.Equals(CountryName));

            if (item == null)
            {
                return false;
            }

            return (item.hopping == "Fixed");
        }

        private Result SetRegion_CS108(string CountryName, int Channel = -1)                                        // Select Country Frequency with channel if fixed
        {
            foreach (var i in FrequencyBand.frequencySet)
                if (i.name == CountryName)
                {
                    if (i.hopping)
                        return SetHoppingChannels(i.code);

                    return SetFixedChannel(i.code, (uint)Channel);
                }

            return Result.FAILURE;
        }

        private double[] GetAvailableFrequencyTable_CS108(string CountryName)									// Get Available frequency table with country code
        {
            foreach (var i in FrequencyBand.frequencySet)
                if (i.name.Equals(CountryName))
                    return GetAvailableFrequencyTable_CS108(i.code);

            return null;
        }

        private List<double> GetCurrentFrequencyTable_CS108()														// Get frequency table on current selected region
        {
            return (new List<double>(GetAvailableFrequencyTable_CS108(m_save_region_code)));
        }

        private string GetCurrentCountry_CS108()
        {
            foreach (var i in FrequencyBand.frequencySet)
                if (i.code == m_save_region_code)
                    return i.name;

            return null;
        }

        private Result SetCountry_CS108(int CountryIndex, int Channel = 0)
        {
            try
            {
                double[] freqTable = GetAvailableFrequencyTable(CountryIndex).ToArray();
                UInt32[] pllTable = GetPllValues(freqTable);

                if (IsHoppingChannel(CountryIndex))
                {
                    int[] channelOrder = new int[pllTable.Length];

                    // set random channel order
                    {
                        Random rnd = new Random();
                        int rndChannnel;
                        int val;

                        for (int i = 0; i < pllTable.Length; i++)
                            channelOrder[i] = i;

                        for (int i = 0; i < pllTable.Length; i++)
                        {
                            rndChannnel = rnd.Next(pllTable.Length);

                            if (i != rndChannnel)
                            {
                                val = channelOrder[i];
                                channelOrder[i] = channelOrder[rndChannnel];
                                channelOrder[rndChannnel] = val;
                            }
                        }
                    }

                    //Enable channels
                    for (uint i = 0; i < pllTable.Length; i++)
                        SetFrequencyBand(i, BandState.ENABLE, pllTable[channelOrder[i]], GetPllcc(RegionCode.FCC));

                    //Disable channels
                    for (uint i = (uint)pllTable.Length; i < 50; i++)
                        SetFrequencyBand(i, BandState.DISABLE, 0, 0);

                    SetRadioLBT(LBT.OFF);

                    currentInventoryFreqRevIndex = (uint [])(object)channelOrder;

                    return Result.OK;
                }
                else
                {
                    //Enable channels
                    SetFrequencyBand(0, BandState.ENABLE, pllTable[Channel], GetPllcc(RegionCode.FCC));

                    //Disable channels
                    for (uint i = 1; i < 50; i++)
                        SetFrequencyBand(i, BandState.DISABLE, 0, 0);

                    SetRadioLBT(LBT.OFF);

                    return Result.OK;
                }
            }
            catch (Exception ex)
            {
                return Result.FAILURE;
            }

            return Result.OK;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.FrequencyChannel.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;
using CSLibrary.Structures;
using static CSLibrary.FrequencyBand;

namespace CSLibrary
{
    public partial class RFIDReader
    {

        /*
        /// <summary>
        /// Get Current Selected Frequency Channel
        /// </summary>
        public uint SelectedChannel
        {
            get { return m_save_selected_freq m_save_freq_channel; }
        }

        /// <summary>
        /// Get current seelcted Country
        /// </summary>
        public double SelectedFrequencyBand
        {
            get { return   m_save_selected_freq; }
        }
        */

        /// <summary>
        /// Set Fixed Frequency Channel
        /// All region can be used to set a fixed channel
        /// </summary>
        /// <param name="prof">Region Code</param>
        /// <param name="channel">Channel number start from zero, you can get the available channels 
        /// from CSLibrary.HighLevelInterface.AvailableFrequencyTable(CSLibrary.Constants.RegionCode)</param>
        public Result SetFixedChannel(RegionCode prof = RegionCode.CURRENT, uint channel = 0)
        {
            bool m_save_fixed_channel = !FrequencyBand.frequencySet.Find(i => i.code == prof).hopping;

            if (m_save_fixed_channel)
                return Result.INVALID_PARAMETER;

            if (m_save_fixed_channel == true && m_save_region_code == prof && m_save_freq_channel == channel)
            {
                if (currentInventoryFreqRevIndex == null)
                    currentInventoryFreqRevIndex = new uint[1] { channel };
                return Result.OK;
            }

            uint Reg0x700 = 0;

            //DEBUG_WriteLine(DEBUGLEVEL.API, "HighLevelInterface.SetFixedChannel(RegionCode prof, uint channel, LBT LBTcfg)");

            if (!GetActiveRegionCode().Contains(prof))
                return Result.INVALID_PARAMETER;

            // disable agile mode
            MacReadRegister(MACREGISTER.HST_ANT_CYCLES /*0x700*/, ref Reg0x700);
            Reg0x700 &= ~0x01000000U;
            MacWriteRegister(MACREGISTER.HST_ANT_CYCLES /*0x700*/, Reg0x700);

            //AGAIN:
            //try
            {
                //Result status = Result.OK;
                uint TotalCnt = FreqChnCnt(prof);
                uint[] freqTable = FreqTable(prof);
                uint i = 0;

                // Check Parameters
                if (!FreqChnWithinRange(channel, prof) || freqTable == null)
                    return Result.INVALID_PARAMETER;

                int Index = FreqSortedIdxTbls(prof, channel);
                if (Index < 0)
                    return Result.INVALID_PARAMETER;

                //Enable channel
                SetFrequencyBand(0, BandState.ENABLE, freqTable[Index], GetPllcc(prof));
                //ThrowException(SetFrequencyBand((uint)Index, BandState.ENABLE, freqTable[Index], GetPllcc(prof)));
                //ThrowException(SetFrequencyBand(0, BandState.ENABLE, freqTable[Index]));
                i = 1;

                //Disable channels
                for (uint j = i; j < MAXFRECHANNEL; j++)
                {
                    SetFrequencyBand(j, BandState.DISABLE, 0, 0);
                }

                SetRadioLBT(LBT.OFF);

                m_save_countryname = FrequencyBand.GetRegionName(prof);
                m_save_region_code = prof;
                m_save_freq_channel = (int)channel;

                //m_save_region_code = prof;
                //m_save_freq_channel = (int)channel;
                //m_save_fixed_channel = true;
                //m_save_agile_channel = false;
                //m_save_selected_freq = GetAvailableFrequencyTable(prof)[channel];

            }
#if nouse
            catch (ReaderException ex)
            {
                //if (FireIfReset(ex.ErrorCode) == Result.OK)
                //{
                //    goto AGAIN;
                //}
            }
            catch
            {
                m_Result = Result.SYSTEM_CATCH_EXCEPTION;
            }
#endif

            currentInventoryFreqRevIndex = new uint[1] { channel };

            return Result.OK;
            //return m_Result;
        }

        /// <summary>
        /// Set to the specific frequency profile
        /// </summary>
        /// <param name="prof">Country Profile</param>
        /// <returns>Result</returns>
        public Result SetHoppingChannels(RegionCode prof)
        {
            bool m_save_fixed_channel = !FrequencyBand.frequencySet.Find(i => i.code == prof).hopping;

            if (m_save_fixed_channel || !GetActiveRegionCode().Contains(prof))
                return Result.INVALID_PARAMETER;

            if (!m_save_fixed_channel && m_save_region_code == prof)
            {
                if (currentInventoryFreqRevIndex == null)
                    currentInventoryFreqRevIndex = FreqIndex(m_save_region_code);
                return Result.OK;
            }

            uint TotalCnt = FreqChnCnt(prof);
            uint[] freqTable = FreqTable(prof);

            //Enable channels
            for (uint i = 0; i < TotalCnt; i++)
            {
                SetFrequencyBand(i, BandState.ENABLE, freqTable[i], GetPllcc(prof));
            }

            //Disable channels
            for (uint i = TotalCnt; i < 50; i++)
            {
                SetFrequencyBand(i, BandState.DISABLE, 0, 0);
            }

            SetRadioLBT(LBT.OFF);

            m_save_countryname = FrequencyBand.GetRegionName(prof);
            m_save_region_code = prof;
            m_save_freq_channel = -1;

            //m_save_region_code = prof;
            //m_save_freq_channel = -1;
            //m_save_agile_channel = false;
            m_Result = Result.OK;

            currentInventoryFreqRevIndex = FreqIndex(m_save_region_code);

            return Result.OK;
        }

        /// <summary>
        /// Reset current frequency profile
        /// </summary>
        /// <returns></returns>
        public Result SetHoppingChannels()
        {
            return SetHoppingChannels(m_save_region_code);
        }

        /// <summary>
        /// Set to frequency agile mode
        /// </summary>
        /// <param name="prof">Country Profile</param>
        /// <returns>Result</returns>
        private Result SetAgileChannels(RegionCode prof)
        {
            bool m_save_fixed_channel = !FrequencyBand.frequencySet.Find(i => i.code == prof).hopping;

            if (!m_save_fixed_channel && m_save_region_code == prof)
            {
                if (currentInventoryFreqRevIndex == null)
                    currentInventoryFreqRevIndex = FreqIndex(m_save_region_code);
                return Result.OK;
            }

            uint Reg0x700 = 0;

            if (!GetActiveRegionCode().Contains(prof) || (prof != RegionCode.ETSI && prof != RegionCode.JP))
                return Result.INVALID_PARAMETER;

            uint TotalCnt = FreqChnCnt(prof);
            uint[] freqTable = FreqTable(prof);

            //Enable channels
            for (uint i = 0; i < TotalCnt; i++)
            {
                SetFrequencyBand(i, BandState.ENABLE, freqTable[i], GetPllcc(prof));
            }
            //Disable channels
            for (uint i = TotalCnt; i < 50; i++)
            {
                SetFrequencyBand(i, BandState.DISABLE, 0, 0);
            }

            SetRadioLBT(LBT.OFF);

            m_save_region_code = prof;
            m_save_fixed_channel = false;
            //m_save_agile_channel = true;

            MacReadRegister(MACREGISTER.HST_ANT_CYCLES /*0x700*/, ref Reg0x700);
            Reg0x700 |= 0x01000000U;
            MacWriteRegister(MACREGISTER.HST_ANT_CYCLES /*0x700*/, Reg0x700);

            currentInventoryFreqRevIndex = FreqIndex(m_save_region_code);
            return Result.OK;
        }

        internal Result InitDefaultChannel_CS108()
        {
            var defaulRegion = CSLibrary.DEVICE.GetDefauleRegion((int)m_oem_country_code, (int)m_oem_special_country_version);
            var hopping = CSLibrary.FrequencyBand.HoppingAvalibable(defaulRegion);

            if (hopping)
                m_save_freq_channel = -1;
            else
                m_save_freq_channel = 0;

            m_save_countryname = FrequencyBand.GetRegionName(defaulRegion);
            m_save_region_code = defaulRegion;

            return Result.OK;
        }

        internal Result SetDefaultChannel_CS108()
        {
            //m_save_freq_channel = 0;
            var defaulRegion = CSLibrary.DEVICE.GetDefauleRegion((int)m_oem_country_code, (int)m_oem_special_country_version);
            var hopping = CSLibrary.FrequencyBand.HoppingAvalibable(defaulRegion);

            if (hopping)
            {
                SetHoppingChannels(defaulRegion);
            }
            else
            {
                SetFixedChannel(defaulRegion, 0);
            }

            return Result.OK;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.Operation.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        internal void StopOperation_CS108()
        {
            //HighLevelInterface._debugBLEHold = false;
            byte[] cmd = { 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, cmd, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA2);
        }

        internal Result StartOperation_CS108(Operation opertion)
        {
            CurrentOperation = opertion;

            // Clear inventory compatmode
            if (opertion != Operation.TAG_EXERANGING)
            {
                UInt32 Value = 0;

                // Clear inventory compatmode
                MacReadRegister(MACREGISTER.HST_INV_CFG, ref Value);
                Value &= ~(1U << 26); // bit 26
                Value &= ~(3U << 16); // bit 16,17
                MacWriteRegister(MACREGISTER.INV_CYCLE_DELAY, 0);
                MacWriteRegister(MACREGISTER.HST_INV_CFG, Value);
            }

            InventoryDebug.Clear();
            switch (opertion)
            {
                case Operation.Kiloway_RANGING:
                case Operation.TAG_RANGING: // Enable get battery level by interrupt
                    _deviceHandler.battery.EnableAutoBatteryLevel();
                    TagRangingThreadProc_CS108();
                    break;

                case Operation.TAG_PRERANGING: // Enable get battery level by interrupt
                    PreTagRangingThreadProc_CS108();
                    break;

                case Operation.TAG_EXERANGING: // Enable get battery level by interrupt
                    CurrentOperation = Operation.TAG_RANGING;
                    _deviceHandler.battery.EnableAutoBatteryLevel();
                    PreTagRangingThreadProc_CS108(); // fix multibank can not work when selectd tag
                    ExeTagRangingThreadProc_CS108();
                    break;

                case Operation.TAG_SEARCHING: // Enable get battery level by interrupt
                    _deviceHandler.battery.EnableAutoBatteryLevel();
                    TagSearchOneTagThreadProc_CS108();
                    break;

                case Operation.TAG_PRESEARCHING:
                    PreTagSearchOneTagThreadProc_CS108();
                    break;

                case Operation.TAG_EXESEARCHING: // Enable get battery level by interrupt
                    CurrentOperation = Operation.TAG_SEARCHING;
                    _deviceHandler.battery.EnableAutoBatteryLevel();
                    ExeTagSearchOneTagThreadProc_CS108();
                    break;

                case Operation.TAG_SELECTED:
                    TagSelected_CS108();
                    break;

                case Operation.TAG_SELECTEDDYNQ:
                    TagSelectedDYNQ_CS108();
                    break;

                case Operation.TAG_FASTSELECTED:
                    FastTagSelected_CS108();
                    break;

                case Operation.TAG_GENERALSELECTED:
                    SetMaskThreadProc_CS108();
                    break;

                case Operation.TAG_PREFILTER:
                    PreFilter_CS108();
                    break;

                case Operation.TAG_READ:
                    ReadThreadProc_CS108();
                    break;

                case Operation.TAG_READ_PC:
                    TagReadPCThreadProc_CS108();
                    break;

                case Operation.TAG_READ_EPC:
                    TagReadEPCThreadProc_CS108();
                    break;

                case Operation.TAG_READ_ACC_PWD:
                    TagReadAccPwdThreadProc_CS108();
                    break;

                case Operation.TAG_READ_KILL_PWD:
                    TagReadKillPwdThreadProc_CS108();
                    break;

                case Operation.TAG_READ_TID:
                    TagReadTidThreadProc_CS108();
                    break;

                case Operation.TAG_READ_USER:
                    TagReadUsrMemThreadProc_CS108();
                    break;

                case Operation.TAG_WRITE:
                    WriteThreadProc_CS108();
                    break;

                case Operation.TAG_WRITE_PC:
                    TagWritePCThreadProc_CS108();
                    break;

                case Operation.TAG_WRITE_EPC:
                    TagWriteEPCThreadProc_CS108();
                    break;

                case Operation.TAG_WRITE_ACC_PWD:
                    TagWriteAccPwdThreadProc_CS108();
                    break;

                case Operation.TAG_WRITE_KILL_PWD:
                    TagWriteKillPwdThreadProc_CS108();
                    break;

                case Operation.TAG_WRITE_USER:
                    TagWriteUsrMemThreadProc_CS108();
                    break;

                case Operation.TAG_BLOCK_WRITE:
                    BlockWriteThreadProc_CS108();
                    break;

                case Operation.TAG_LOCK:
                    TagLockThreadProc_CS108();
                    break;

                case Operation.TAG_BLOCK_PERMALOCK:
                    TagBlockLockThreadProc_CS108();
                    break;

                case Operation.TAG_KILL:
                    TagKillThreadProc_CS108();
                    break;

                case Operation.TAG_AUTHENTICATE:
                    TagAuthenticateThreadProc_CS108();
                    break;

                case Operation.TAG_READBUFFER:
                    TagReadBufferThreadProc_CS108();
                    break;

                case Operation.TAG_UNTRACEABLE:
                    TagUntraceableThreadProc_CS108();
                    break;

                case Operation.FM13DT_READMEMORY:
                    FM13DTReadMemoryThreadProc_CS108();
                    break;

                case Operation.FM13DT_WRITEMEMORY:
                    FM13DTWriteMemoryThreadProc_CS108();
                    break;

                case Operation.FM13DT_READREGISTER:
                    FM13DTReadRegThreadProc_CS108();
                    break;

                case Operation.FM13DT_WRITEREGISTER:
                    FM13DTWriteRegThreadProc_CS108();
                    break;

               case Operation.FM13DT_AUTH:
                    FM13DTAuthThreadProc_CS108();
                    break;

                case Operation.FM13DT_GETTEMP:
                    FM13DTGetTempThreadProc_CS108();
                    break;

                case Operation.FM13DT_STARTLOG:
                    FM13DTStartLogThreadProc_CS108();
                    break;

                case Operation.FM13DT_STOPLOG:
                    FM13DTStopLogChkThreadProc_CS108();
                    break;

                case Operation.FM13DT_DEEPSLEEP:
                    FM13DTDeepSleepThreadProc_CS108();
                    break;

                case Operation.FM13DT_OPMODECHK:
                    FM13DTOpModeChkThreadProc_CS108();
                    break;

                case Operation.FM13DT_INITIALREGFILE:
                    FM13DTInitialRegFileThreadProc_CS108();
                    break;

                case Operation.FM13DT_LEDCTRL:
                    FM13DTLedCtrlThreadProc_CS108();
                    break;

                case Operation.QT_COMMAND:
                    //QT_CommandProc_CS108();
                    break;

                default:
                    return Result.NOT_SUPPORTED;
            }

            return Result.OK;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.Power.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    using static RFIDDEVICE;
    using static FrequencyBand;
    using Constants;

    public partial class RFIDReader
    {
        /// <summary>
        /// Get Power Level
        /// </summary>
        public Result GetPowerLevel_CS108(ref uint pwrlvl)
        {
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_SEL, 0);
            MacReadRegister(MACREGISTER.HST_ANT_DESC_RFPOWER, ref pwrlvl);

            return Result.OK;
        }

        public Result SetPowerLevel_CS108(uint pwrlevel, uint port = 0)
        {
            if (pwrlevel > 330)
                pwrlevel = 330;

            MacWriteRegister(MACREGISTER.HST_ANT_DESC_SEL, port);         // select antenna
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_RFPOWER, pwrlevel);

            return Result.OK;
        }

        public Result SetPowerLevel_CS108(int pwrlevel, uint port = 0)
        {
            if (pwrlevel < 0)
                return Result.INVALID_PARAMETER;

            return SetPowerLevel_CS108((uint)pwrlevel, port);
        }

        public Result SetPowerLevel_CS108(UInt32 [] pwrlevel)
        {
            Result r;

            for (uint cnt = 0; cnt < pwrlevel.Length; cnt++)
                if ((r = SetPowerLevel_CS108(pwrlevel[cnt], cnt)) != Result.OK)
                    return r;

            return Result.OK;
        }

        /// <summary>
        /// Available Maximum Power you can set on specific region
        /// </summary>
        private uint GetSoftwareMaxPowerLevel_CS108(RegionCode region)
        {
            // MAX Power 32dB
            if ((m_oem_hipower == 1) ||
                (m_oem_machine == MODEL.CS468INT) ||
                (m_oem_machine == MODEL.CS463) ||
                (m_oem_machine == MODEL.CS469) ||
                (region == RegionCode.IN) ||
                (region == RegionCode.G800) ||
                (m_oem_machine == MODEL.CS209) ||
                (m_oem_machine == MODEL.CS103) ||
                (m_oem_machine == MODEL.CS108)
                )
                return 320;

            // MAX Power 27.5dB
            if ((m_oem_machine == MODEL.CS101 && region == RegionCode.ETSI) ||
                (m_oem_machine == MODEL.CS203 && region == RegionCode.JP))
                return 275;

            return 300;
        }

        /// <summary>
        /// Set Power Sequencing (only for CS108)
        /// </summary>
        /// <param name="numberofPower"></param>
        /// <param name="power"></param>
        /// <param name="dwell"></param>
        /// <returns></returns>
        public Result SetPowerSequencing_CS108(int numberofPower, uint[] power = null, uint[] dwell = null)
        {
            if (numberofPower == 0)
            {
                try
                {
                    int i;
                    for (i = 0; i < m_AntennaList.Count; i++)
                    {
                        if (m_AntennaList[i].PowerLevel > GetSoftwareMaxPowerLevel(m_save_region_code))
                            m_AntennaList[i].PowerLevel = GetSoftwareMaxPowerLevel(m_save_region_code);

                        SetAntennaPortStatus((uint)i, m_AntennaList[i].AntennaStatus);
                        SetAntennaPortConfiguration((uint)i, m_AntennaList[i].AntennaConfig);
                    }

                    for (; i < 16; i++)
                    {
                        AntennaPortSetState((uint)i, AntennaPortState.DISABLED);
                    }
                }
                catch (Exception ex)
                {
                    CSLibrary.Debug.WriteLine("Set Antenna Configuration Fail : " + ex.Message);
                }
                return Result.OK;
            }

            if (power == null || dwell == null || power.Length < numberofPower || dwell.Length < numberofPower)
            {
                return Result.INVALID_PARAMETER;
            }

            {
                uint i;

                for (i = 0; i < numberofPower; i++)
                {
                    AntennaPortSetState((uint)i, AntennaPortState.ENABLED);
                    SetPowerLevel_CS108(power[i], i);
                    SetInventoryDuration_CS108(dwell[i], i);
                }

                for (; i < 16; i++)
                {
                    AntennaPortSetState((uint)i, AntennaPortState.DISABLED);
                }
            }

            return Result.OK;
        }

    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.Profile.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;

namespace CSLibrary
{
    using static FrequencyBand;

    public partial class RFIDReader
    {
        internal string[] _profileNameList_CS108 = {
            "  0. Multipath Interference Resistance",
            "  1. Range/Dense Reader",
            "  2. Range/Throughput/Dense Reader",
            "  3. Max Throughput"
        };


        public uint[] GetActiveLinkProfile_CS108(RegionCode region)
        {
            switch (region)
            {
                case RegionCode.KR:
                    return new uint[] { 0, 1, 2 };

                case RegionCode.JP:
                    return new uint[] { 1, 2 };

                default:
                    return new uint[] { 0, 1, 2, 3 };
            }
        }

        public string[] GetActiveLinkProfileName_CS108(RegionCode region)
        {
            switch (region)
            {
                case RegionCode.KR:
                    return new string[] { _profileNameList_CS108[0], _profileNameList_CS108[1], _profileNameList_CS108[2] };

                case RegionCode.JP:
                    return new string[] { _profileNameList_CS108[1], _profileNameList_CS108[2] };

                default:
                    return _profileNameList_CS108;
            }
        }

        /// <summary>
        /// Current selected frequency
        /// </summary>
        public uint SelectedLinkProfile_CS108
        {
            get
            {
                uint link = 0;
                GetCurrentLinkProfile_CS108(ref link);
                return link;
            }
        }

        /// <summary>
        /// Allows the application to set the current link profile for the radio 
        /// module.  A link profile will remain in effect until changed by a 
        /// subsequent call to RFID_RadioSetCurrentLinkProfile.  The 
        /// current link profile cannot be set while a radio module is executing 
        /// a tag-protocol operation. 
        /// </summary>
        /// <param name="profile">
        /// The link profile to make the current link profile.  If this 
        /// parameter does not represent a valid link profile, 
        /// RFID_ERROR_INVALID_PARAMETER is returned. </param>
        /// <returns></returns>
        public Result SetCurrentLinkProfile_CS108(uint profile)
        {
            //DEBUG_WriteLine(DEBUGLEVEL.API, "HighLevelInterface.SetCurrentLinkProfile(uint profile)");

            MacWriteRegister(MACREGISTER.HST_RFTC_CURRENT_PROFILE, profile);
            _deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.UPDATELINKPROFILE), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE);
            SetLNA(m_save_rflna_high_comp, m_save_rflna_gain, m_save_iflna_gain, m_save_ifagc_gain);

            return Result.OK;
        }

        /// <summary>
        ///  Allows the application to retrieve the current link profile for the 
        ///  radio module.  The current link profile cannot be retrieved while a 
        ///  radio module is executing a tag-protocol operation. 
        /// </summary>
        /// <returns></returns>
        public Result GetCurrentLinkProfile_CS108(ref uint link)
        {
            MacReadRegister(MACREGISTER.HST_RFTC_CURRENT_PROFILE, ref link);

            return Result.OK;
        }

    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.RSSIFilter.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        public Result SetRSSIFilter_CS108(RSSIFILTERTYPE type)
        {
            UInt32 value = 0;
            UInt32 setting = 0;

            switch (type)
            {
                case RSSIFILTERTYPE.DISABLE:
                    setting = 0;
                    break;

                case RSSIFILTERTYPE.RSSI:
                    setting = 1;
                    break;

                /*case RSSIFILTERTYPE.NB_RSSI:
                    setting = 1;
                    break;*/
            }

            MacReadRegister(MACREGISTER.HST_INV_RSSI_FILTERING_CONFIG, ref value);
            value &= 0xfffffff0;
            value |= (uint)(setting);
            MacWriteRegister(MACREGISTER.HST_INV_RSSI_FILTERING_CONFIG, value);

            return Result.OK;
        }

        public Result SetRSSIFilter_CS108(RSSIFILTERTYPE type, RSSIFILTEROPTION option, double threshold_dbV)
        {
            UInt32 value;
            UInt32 typeSettingValue = 0;
            UInt32 optionSettingValue = 0;

            switch (type)
            {
                case RSSIFILTERTYPE.DISABLE:
                    typeSettingValue = 0;
                    break;

                case RSSIFILTERTYPE.RSSI:
                    typeSettingValue = 1;
                    break;

                    /*                case RSSIFILTERTYPE.RSSI:
                                        typeSettingValue = 2;
                                        break;

                                    case RSSIFILTERTYPE.NB_RSSI:
                                        typeSettingValue = 1;
                                        break;
                    */
            }

            switch (option)
            {
                case RSSIFILTEROPTION.DISABLE:
                    typeSettingValue = 0;
                    optionSettingValue = 0;
                    break;

                case RSSIFILTEROPTION.LESSOREQUAL:
                    optionSettingValue = 0;
                    break;

                case RSSIFILTEROPTION.GREATEROREQUAL:
                    optionSettingValue = 1;
                    break;
            }

            value = (uint)(typeSettingValue) | ((uint)(optionSettingValue) << 4);
            MacWriteRegister(MACREGISTER.HST_INV_RSSI_FILTERING_CONFIG, value);

            value = (uint)encodeNarrowBandRSSI (threshold_dbV);
            MacWriteRegister(MACREGISTER.HST_INV_RSSI_FILTERING_THRESHOLD, value);

            return Result.OK;
        }

        private int encodeNarrowBandRSSI(double dRSSI)
        {
            double dValue = dRSSI / 20;
            dValue = Math.Pow(10, dValue);
            int exponent = 0;

            //if (false) appendToLog("exponent = " + exponent + ", dValue = " + dValue);

            while ((dValue + 0.5) >= 2)
            {
                dValue /= 2; exponent++;
                //if (false) appendToLog("exponent = " + exponent + ", dValue = " + dValue);
            }

            dValue--;

            int mantissa = (int)((dValue * 8) + 0.5);
            int iValue = ((exponent & 0x1F) << 3) | (mantissa & 0x7);
            return iValue;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS108/ClassRFID.Public.SetLNA.cs">
using System;
using System.Collections.Generic;
using System.Text;

using CSLibrary.Constants;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        private int m_save_rflna_high_comp = 1;
        private int m_save_rflna_gain = 1;
        private int m_save_iflna_gain = 24;
        private int m_save_ifagc_gain = -6;

        /// <summary>
        /// RF LNA compression mode = 0, 1
        /// RF LNA Gain = 1, 7, 13
        /// IF LNA Gain = 6, 12, 18, 24
        /// AGC Gain = -12, -6, 0, 6
        /// </summary>
        /// <param name="rflna_high_comp_norm"></param>
        /// <param name="rflna_gain_norm"></param>
        /// <param name="iflna_gain_norm"></param>
        /// <param name="ifagc_gain_norm"></param>
        /// <param name="ifagc_gain_norm"></param>
        /// <returns></returns>
        public Result SetLNA_CS108(int rflna_high_comp, int rflna_gain, int iflna_gain, int ifagc_gain)
        {
            if (rflna_high_comp != 00 && rflna_high_comp != 1)
                return Result.INVALID_PARAMETER;

            if (rflna_gain != 1 && rflna_gain != 7 && rflna_gain != 13)
                return Result.INVALID_PARAMETER;

            if (iflna_gain != 6 && iflna_gain != 12 && iflna_gain != 18 && iflna_gain != 24)
                return Result.INVALID_PARAMETER;

            if (ifagc_gain != -12 && ifagc_gain != -6 && ifagc_gain != 0 && ifagc_gain != 6)
                return Result.INVALID_PARAMETER;

            m_save_rflna_high_comp = rflna_high_comp;
            m_save_rflna_gain = rflna_gain;
            m_save_iflna_gain = iflna_gain;
            m_save_ifagc_gain = ifagc_gain;

            int rflna_high_comp_norm = rflna_high_comp;
            int rflna_gain_norm = 0;
            int iflna_gain_norm = 0;
            int ifagc_gain_norm = 0;

            switch (rflna_gain)
            {
                case 1:
                    rflna_gain_norm = 0;
                    break;
                case 7:
                    rflna_gain_norm = 2;
                    break;
                case 13:
                    rflna_gain_norm = 3;
                    break;
            }

            switch (iflna_gain)
            {
                case 24:
                    iflna_gain_norm = 0;
                    break;
                case 18:
                    iflna_gain_norm = 1;
                    break;
                case 12:
                    iflna_gain_norm = 3;
                    break;
                case 6:
                    iflna_gain_norm = 7;
                    break;
            }

            switch (ifagc_gain)
            {
                case -12:
                    ifagc_gain_norm = 0;
                    break;
                case -6:
                    ifagc_gain_norm = 4;
                    break;
                case 0:
                    ifagc_gain_norm = 6;
                    break;
                case 6:
                    ifagc_gain_norm = 7;
                    break;
            }

            int value = rflna_high_comp_norm << 8 |
                rflna_gain_norm << 6 |
                iflna_gain_norm << 3 |
                ifagc_gain_norm;

            return MacBypassWriteRegister(0x450, (UInt16)(value));
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/Antenna/Antenna.cs">
//#if CS468
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;
namespace CSLibrary
{
    using CSLibrary.Constants;
    using CSLibrary.Structures;

    /// <summary>
    /// Antenna
    /// </summary>
#if NETCFDESIGNTIME
    [System.ComponentModel.TypeConverter(typeof(AntennaTypeConverter))]
#endif
    public class Antenna
        :
        Object
    {

        // According to MAC EDS ~ phy port number allocated 2 bits only

        //public static readonly UInt32 RX_PHY_MINIMUM = 0;
        //public static readonly UInt32 TX_PHY_MINIMUM = RX_PHY_MINIMUM;

        //public static readonly UInt32 RX_PHY_MAXIMUM = 3;
        //public static readonly UInt32 TX_PHY_MAXIMUM = RX_PHY_MAXIMUM;

        // According to MAC EDS ~ caveat RX logical must == TX logical
        // for the current version...
        /// <summary>
        /// RX_LOGICAL_MINIMUM
        /// </summary>
        public static readonly UInt32 RX_LOGICAL_MINIMUM = 0;
        /// <summary>
        /// TX_LOGICAL_MINIMUM
        /// </summary>
        public static readonly UInt32 TX_LOGICAL_MINIMUM = 0;
        /// <summary>
        /// RX_LOGICAL_MAXIMUM
        /// </summary>
        public static readonly UInt32 RX_LOGICAL_MAXIMUM = 15;
        /// <summary>
        /// TX_LOGICAL_MAXIMUM
        /// </summary>
        public static readonly UInt32 TX_LOGICAL_MAXIMUM = 15;

        // According to previous app default settings
        /// <summary>
        /// POWER_MINIMUM
        /// </summary>
        public static readonly UInt32 POWER_MINIMUM = 1;
        /// <summary>
        /// POWER_MAXIMUM
        /// </summary>
        public static readonly UInt32 POWER_MAXIMUM = 300;


        public UInt32 port = 0;
        AntennaPortStatus antennaStatus;

        public AntennaPortStatus AntennaStatus
        {
            get { return antennaStatus; }
            set { antennaStatus = value; }
        }
        AntennaPortConfig antennaConfig;

        public AntennaPortConfig AntennaConfig
        {
            get { return antennaConfig; }
            set { antennaConfig = value; }
        }
        /// <summary>
        /// Constructor
        /// </summary>
        public Antenna() : this(0) { }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="port"></param>
        public Antenna
        (
            UInt32 port
        )
            :
            base()
        {
            this.port = port;
            this.antennaStatus = new AntennaPortStatus();
            this.antennaConfig = new AntennaPortConfig();
        }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="port"></param>
        /// <param name="state"></param>
        /// <param name="powerLevel"></param>
        /// <param name="dwellTime"></param>
        /// <param name="numberInventoryCycles"></param>
        /// <param name="antennaSenseThreshold"></param>
        public Antenna
        (
            UInt32 port,
            AntennaPortState state,
            UInt32 powerLevel,
            UInt32 dwellTime,
            UInt32 numberInventoryCycles,

            Boolean easAlarm,
            Boolean enableLocalInv,
            SingulationAlgorithm invAlgo,
            UInt32 startQ,
            Boolean enableLocalProfile,
            UInt32 linkProfile,
            Boolean enableLocalFreq,
            UInt32 freqChannel,

            UInt32 antennaSenseThreshold
        )
            :
            base()
        {
            this.port = port;
            this.antennaStatus = new AntennaPortStatus();
            this.antennaConfig = new AntennaPortConfig();

            this.State = state;
            this.EnableLocalFreq = enableLocalFreq;
            this.EASAlarm = easAlarm;
            this.EnableLocalInv = enableLocalInv;
            this.EnableLocalProfile = enableLocalProfile;
            this.InventoryAlgorithm = invAlgo;
            this.StartQ = startQ;
            this.LinkProfile = linkProfile;
            this.FreqChannel = freqChannel;
            this.PowerLevel = powerLevel;
            this.DwellTime = dwellTime;
            this.NumberInventoryCycles = numberInventoryCycles;
            this.AntennaSenseThreshold = antennaSenseThreshold;
        }

        /// <summary>
        /// Copy Constructor
        /// </summary>
        /// <param name="antenna"></param>
        public Antenna
        (
            Antenna antenna
        )
            :
            this(0)
        {
            this.Copy(antenna);
        }


        /// <summary>
        /// Copy from Antenna
        /// </summary>
        /// <param name="from"></param>
        public void Copy(Antenna from)
        {
            this.port = from.Port;

            this.antennaStatus = (from.antennaStatus);
            this.antennaConfig = (from.antennaConfig);
        }

        /// <summary>
        /// Check equal
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(System.Object obj)
        {
            if (null == obj)
            {
                return false;
            }

            Antenna rhs = obj as Antenna;

            if (null == (System.Object)rhs)
            {
                return false;
            }

            return this.Equals(rhs);
        }

        /// <summary>
        /// Check equal
        /// </summary>
        /// <param name="rhs"></param>
        /// <returns></returns>
        public bool Equals(Antenna rhs)
        {
            if (null == (System.Object)rhs)
            {
                return false;
            }

            return
                   this.port == rhs.port
                && this.antennaStatus.Equals(rhs.antennaStatus)
                && this.antennaConfig.Equals(rhs.antennaStatus);
        }

        /// <summary>
        /// TODO: provide real hash return value
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        /// <summary>
        /// Antenna port number
        /// </summary>
        [XmlElement()]
        public UInt32 Port
        {
            get
            {
                return this.port;
            }
        }
        /// <summary>
        /// Get the state of the logical antenna port. 
        /// </summary>
        [XmlIgnore]
        public AntennaPortState State
        {
            get
            {
                return this.antennaStatus.state;
            }
            set
            {
                this.antennaStatus.state = value;
            }
        }
//#if CS468
        /// <summary>
        /// EAS Alarm
        /// </summary>
        [XmlIgnore]
        public Boolean EASAlarm
        {
            get { return this.antennaStatus.easAlarm; }
            set { this.antennaStatus.easAlarm = value; }
        }

        /// <summary>
        /// Enable local inventory parameter
        /// </summary>
        [XmlIgnore]
        public Boolean EnableLocalInv
        {
            get { return this.antennaStatus.enableLocalInv; }
            set { this.antennaStatus.enableLocalInv = value; }
        }
        /// <summary>
        /// Enable local link profile
        /// </summary>
        [XmlIgnore]
        public Boolean EnableLocalProfile
        {
            get { return this.antennaStatus.enableLocalProfile; }
            set { this.antennaStatus.enableLocalProfile = value; }
        }
        /// <summary>
        /// Enable local frequency
        /// </summary>
        [XmlIgnore]
        public Boolean EnableLocalFreq
        {
            get { return this.antennaStatus.enableLocalFreq; }
            set { this.antennaStatus.enableLocalFreq = value; }
        }
        /// <summary>
        /// Inventory algorithm
        /// </summary>
        [XmlIgnore]
        public SingulationAlgorithm InventoryAlgorithm
        {
            get { return this.antennaStatus.inv_algo; }
            set { this.antennaStatus.inv_algo = value; }
        }
        /// <summary>
        /// Inventory StartQ
        /// </summary>
        [XmlIgnore]
        public UInt32 StartQ
        {
            get { return this.antennaStatus.startQ; }
            set { this.antennaStatus.startQ = value; }
        }
        /// <summary>
        /// LinkProfile
        /// </summary>
        [XmlIgnore]
        public UInt32 LinkProfile
        {
            get { return this.antennaStatus.profile; }
            set { this.antennaStatus.profile = value; }
        }
        /// <summary>
        /// Frequency channel
        /// </summary>
        [XmlIgnore]
        public UInt32 FreqChannel
        {
            get { return this.antennaStatus.freqChn; }
            set { this.antennaStatus.freqChn = value; }
        }
//#endif
        /// <summary>
        /// The power level for the logical antenna port's physical 
        /// transmit antenna.  This value is specified in 0.1 (i.e., 
        /// 1/10th) dBm. Note that all radio modules may not support 
        /// setting an antenna port's power level at 1/10th dBm 
        /// resolutions.  The dBm rounding/truncation policy is left to 
        /// the radio module and is outside the scope of the RFID 
        /// Reader Library. 
        /// </summary>
        [XmlIgnore]
        public UInt32 PowerLevel
        {
            get
            {
                return this.antennaConfig.powerLevel;
            }
            set
            {
                this.antennaConfig.powerLevel = value;
            }
        }
        /// <summary>
        /// Specifies the maximum amount of time, in milliseconds, 
        /// that may be spent on the logical antenna port during a 
        /// tag-protocol-operation cycle before switching to the next 
        /// enabled antenna port.  A value of zero indicates that there 
        /// is no maximum dwell time for this antenna port.  If this 
        /// parameter is zero, then numberInventoryCycles may 
        /// not be zero. 
        /// See  for the effect of antenna-port dwell time and number 
        /// of inventory cycles on the amount of time spent on an 
        /// antenna port during a single tag-protocol-operation cycle. 
        /// NOTE:  when performing any non-inventory ISO 18000-6C tag
        /// access operation (i.e., read, write, kill, or lock), the
        /// radio module ignores the dwell time for the antenna port 
        /// which is used for the tag-protocol operation. 
        /// </summary>
        [XmlIgnore]
        public UInt32 DwellTime
        {
            get
            {
                return this.antennaConfig.dwellTime;
            }
            set
            {
                this.antennaConfig.dwellTime = value;
            }
        }
        /// <summary>
        /// Specifies the maximum number of inventory cycles to 
        /// attempt on the antenna port during a tag-protocol-
        /// operation cycle before switching to the next enabled 
        /// antenna port.  An inventory cycle consists of one or more 
        /// executions of the singulation algorithm for a particular 
        /// inventory-session target (i.e., A or B).  If the singulation 
        /// algorithm [SING-ALG] is configured to toggle the 
        /// inventory-session, executing the singulation algorithm for 
        /// inventory session A and inventory session B counts as 
        /// two inventory cycles.  A value of zero indicates that there 
        /// is no maximum number of inventory cycles for this 
        /// antenna port.  If this parameter is zero, then dwellTime 
        /// may not be zero. 
        /// See  for the effect of antenna-port dwell time and number 
        /// of inventory cycles on the amount of time spent on an 
        /// antenna port during a single tag-protocol-operation cycle. 
        /// NOTE:  when performing any non-inventory ISO 18000-
        /// 6C tag access operation (i.e., read, write, kill, or lock), the 
        /// radio module ignores the number of inventory cycles for 
        /// the antenna port which is used for the tag-protocol 
        /// operation. 
        /// </summary>
        [XmlIgnore]
        public UInt32 NumberInventoryCycles
        {
            get
            {
                return this.antennaConfig.numberInventoryCycles;
            }
            set
            {
                this.antennaConfig.numberInventoryCycles = value;
            }
        }

        /// <summary>
        /// The measured resistance, specified in ohms, above which 
        /// the antenna-sense resistance should be considered to be 
        /// an open circuit (i.e., a disconnected antenna).  If it is 
        /// detected that the antenna-sense resistance is above the 
        /// threshold, the carrier wave will not be turned on in order 
        /// to protect the circuit. 
        /// NOTE:  This value, while appearing in the per-antenna 
        /// configuration is actually a system-wide setting in the 
        /// current release.  Changing it will Result in the value being 
        /// changed for all antennas.  To prevent unintentionally 
        /// changing this value for all antennas, it is best to first 
        /// retrieve the antenna configuration for the antenna for 
        /// which configuration will be changed, update the fields that 
        /// should be changed, and then set the configuration. 
        /// </summary>
        [XmlIgnore]
        public UInt32 AntennaSenseThreshold
        {
            get
            {
                return this.antennaConfig.antennaSenseThreshold;
            }
            set
            {
                this.antennaConfig.antennaSenseThreshold = value;
            }
        }
        /// <summary>
        /// The stored value from the last measurement of the 
        /// antenna-sense resistor for the logical antenna port's 
        /// physical transmit antenna port.  The last measurement 
        /// taken occurred the last time that the carrier wave was 
        /// turned on for this antenna port C note that this means that 
        /// when retrieving the logical antenna port's status, this does 
        /// not Result in an active measurement of the antenna-sense 
        /// resistor.  This value is specified in ohms. 
        /// </summary>
        [XmlIgnore]
        public UInt32 AntennaSenseValue
        {
            get
            {
                return this.antennaStatus.antennaSenseValue;
            }
        }
    } // End class Antenna


} // End namespace RFID.RFIDInterface
//#endif
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/Antenna/AntennaConfig.cs">
//#if CS468
using System;
using System.Collections.Generic;
using System.Text;

namespace CSLibrary
{
    using CSLibrary.Constants;
    using CSLibrary.Structures;
    class AntennaConfig
        :
        Object
    {
        private UInt32 port;
        private AntennaPortConfig antennaPortConfig;

        public AntennaPortConfig AntennaPortConfig
        {
            get { return antennaPortConfig; }
            set { antennaPortConfig = value; }
        }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="port"></param>
        public AntennaConfig
        (
            UInt32 port
        )
            :
            base()
        {
            this.port = port;
            this.antennaPortConfig = new AntennaPortConfig();
        }

        /// <summary>
        /// Copy Constructor
        /// </summary>
        /// <param name="source"></param>
        public AntennaConfig
        (
            AntennaConfig source
        )
            :
            base()
        {
            this.Copy(source);
        }

        /// <summary>
        /// Copy from AntennaConfig
        /// </summary>
        /// <param name="from"></param>
        public void Copy(AntennaConfig from)
        {
            this.port = from.port;

            this.antennaPortConfig.powerLevel = from.antennaPortConfig.powerLevel;
            this.antennaPortConfig.dwellTime = from.antennaPortConfig.dwellTime;
            this.antennaPortConfig.numberInventoryCycles = from.antennaPortConfig.numberInventoryCycles;
            this.antennaPortConfig.antennaSenseThreshold = from.antennaPortConfig.antennaSenseThreshold;
        }

        /// <summary>
        /// Check equal
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(System.Object obj)
        {
            if (null == obj)
            {
                return false;
            }

            AntennaConfig rhs = obj as AntennaConfig;

            if (null == (System.Object)rhs)
            {
                return false;
            }

            return this.Equals(rhs);
        }
        /// <summary>
        /// Check equal
        /// </summary>
        /// <param name="rhs"></param>
        /// <returns></returns>
        public bool Equals(AntennaConfig rhs)
        {
            if (null == (System.Object)rhs)
            {
                return false;
            }

            return
                   this.port == rhs.port
                && this.antennaPortConfig.powerLevel == rhs.antennaPortConfig.powerLevel
                && this.antennaPortConfig.dwellTime == rhs.antennaPortConfig.dwellTime
                && this.antennaPortConfig.numberInventoryCycles == rhs.antennaPortConfig.numberInventoryCycles
                && this.antennaPortConfig.antennaSenseThreshold == rhs.antennaPortConfig.antennaSenseThreshold;
        }

        /// <summary>
        /// TODO: provide real hash return value
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
        /// <summary>
        /// Load Antenna config from MAC
        /// </summary>
        /// <param name="transport"></param>
        /// <returns></returns>
        public Result Load
        (
            HighLevelInterface transport
        )
        {
            if (transport == null)
                return Result.NOT_INITIALIZED;
            return transport.rfid.GetAntennaPortConfiguration
                (
                    port,
                    ref this.antennaPortConfig
                );

        }
        /// <summary>
        /// Store Antenna config to MAC
        /// </summary>
        /// <param name="transport"></param>
        /// <returns></returns>
        public Result Store
        (
            HighLevelInterface transport
        )
        {
            if (transport == null)
                return Result.NOT_INITIALIZED;
            return transport.rfid.SetAntennaPortConfiguration
                (
                    port,
                    this.antennaPortConfig
                );
        }
        /// <summary>
        /// Antenna port number
        /// </summary>
        public UInt32 Port
        {
            get
            {
                return this.port;
            }
        }
        /// <summary>
        /// The power level for the logical antenna port's physical 
        /// transmit antenna.  This value is specified in 0.1 (i.e., 
        /// 1/10th) dBm. Note that all radio modules may not support 
        /// setting an antenna port's power level at 1/10th dBm 
        /// resolutions.  The dBm rounding/truncation policy is left to 
        /// the radio module and is outside the scope of the RFID 
        /// Reader Library. 
        /// </summary>
        public UInt32 PowerLevel
        {
            get
            {
                return this.antennaPortConfig.powerLevel;
            }
            set
            {
                this.antennaPortConfig.powerLevel = value;
            }
        }
        /// <summary>
        /// Specifies the maximum amount of time, in milliseconds, 
        /// that may be spent on the logical antenna port during a 
        /// tag-protocol-operation cycle before switching to the next 
        /// enabled antenna port.  A value of zero indicates that there 
        /// is no maximum dwell time for this antenna port.  If this 
        /// parameter is zero, then numberInventoryCycles may 
        /// not be zero. 
        /// See  for the effect of antenna-port dwell time and number 
        /// of inventory cycles on the amount of time spent on an 
        /// antenna port during a single tag-protocol-operation cycle. 
        /// NOTE:  when performing any non-inventory ISO 18000-6C tag
        /// access operation (i.e., read, write, kill, or lock), the
        /// radio module ignores the dwell time for the antenna port 
        /// which is used for the tag-protocol operation. 
        /// </summary>
        public UInt32 DwellTime
        {
            get
            {
                return this.antennaPortConfig.dwellTime;
            }
            set
            {
                this.antennaPortConfig.dwellTime = value;
            }
        }
        /// <summary>
        /// Specifies the maximum number of inventory cycles to 
        /// attempt on the antenna port during a tag-protocol-
        /// operation cycle before switching to the next enabled 
        /// antenna port.  An inventory cycle consists of one or more 
        /// executions of the singulation algorithm for a particular 
        /// inventory-session target (i.e., A or B).  If the singulation 
        /// algorithm [SING-ALG] is configured to toggle the 
        /// inventory-session, executing the singulation algorithm for 
        /// inventory session A and inventory session B counts as 
        /// two inventory cycles.  A value of zero indicates that there 
        /// is no maximum number of inventory cycles for this 
        /// antenna port.  If this parameter is zero, then dwellTime 
        /// may not be zero. 
        /// See  for the effect of antenna-port dwell time and number 
        /// of inventory cycles on the amount of time spent on an 
        /// antenna port during a single tag-protocol-operation cycle. 
        /// NOTE:  when performing any non-inventory ISO 18000-
        /// 6C tag access operation (i.e., read, write, kill, or lock), the 
        /// radio module ignores the number of inventory cycles for 
        /// the antenna port which is used for the tag-protocol 
        /// operation. 
        /// </summary>
        public UInt32 NumberInventoryCycles
        {
            get
            {
                return this.antennaPortConfig.numberInventoryCycles;
            }
            set
            {
                this.antennaPortConfig.numberInventoryCycles = value;
            }
        }

        /// <summary>
        /// The measured resistance, specified in ohms, above which 
        /// the antenna-sense resistance should be considered to be 
        /// an open circuit (i.e., a disconnected antenna).  If it is 
        /// detected that the antenna-sense resistance is above the 
        /// threshold, the carrier wave will not be turned on in order 
        /// to protect the circuit. 
        /// NOTE:  This value, while appearing in the per-antenna 
        /// configuration is actually a system-wide setting in the 
        /// current release.  Changing it will Result in the value being 
        /// changed for all antennas.  To prevent unintentionally 
        /// changing this value for all antennas, it is best to first 
        /// retrieve the antenna configuration for the antenna for 
        /// which configuration will be changed, update the fields that 
        /// should be changed, and then set the configuration. 
        /// </summary>
        public UInt32 AntennaSenseThreshold
        {
            get
            {
                return this.antennaPortConfig.antennaSenseThreshold;
            }
            set
            {
                this.antennaPortConfig.antennaSenseThreshold = value;
            }
        }


    } // End class AntennaConfig


} // End namespace CSLibrary
//#endif
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/Antenna/AntennaList.cs">
//#if CS468
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Text;

namespace CSLibrary
{
    using static RFIDDEVICE;
    using Constants;
    using Structures;

#if NETCFDESIGNTIME
    [System.ComponentModel.TypeConverter(typeof(AntennaListTypeConverter))]
#endif
    public class AntennaList
        :
        List<Antenna>
    {

#if NETCFDESIGNTIME && NO_NEED

        public static AntennaList DEFAULT_ANTENNA_LIST
        {
            get
            {
                Object obj = TypeDescriptor.GetConverter(typeof(AntennaList)).ConvertFromString
                (
                    CSLibrary.Properties.Settings.Default.DefaultAntennaSettings
                );

                if (null == obj)
                {
                    // SHOULD NEVER OCCUR
                }

                return obj as AntennaList;
            }
        }
#endif
        /*0,ENABLED,300,2000,0,0,0,1048575;
        1,DISABLED,300,2000,0,4,4,1048575;
        2,DISABLED,300,2000,0,8,8,1048575;
        3,DISABLED,300,2000,0,12,12,1048575;
        4,DISABLED,300,2000,0,1,1,1048575;
        5,DISABLED,300,2000,0,5,5,1048575;
        6,DISABLED,300,2000,0,9,9,1048575;
        7,DISABLED,300,2000,0,13,13,1048575;
        8,DISABLED,300,2000,0,2,2,1048575;
        9,DISABLED,300,2000,0,6,6,1048575;
        10,DISABLED,300,2000,0,10,10,1048575;
        11,DISABLED,300,2000,0,14,14,1048575;
        12,DISABLED,300,2000,0,3,3,1048575;
        13,DISABLED,300,2000,0,7,7,1048575;
        14,DISABLED,300,2000,0,11,11,1048575;
        15,DISABLED,300,2000,0,15,15,1048575;*/
        /// <summary>
        /// Default antenna list
        /// </summary>
        public static readonly AntennaList DEFAULT_ANTENNA_LIST;

        static AntennaList()
        {
            DEFAULT_ANTENNA_LIST = new AntennaList();
            
            DEFAULT_ANTENNA_LIST.Add(new Antenna(0, AntennaPortState.ENABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
        }

        /// <summary>
        /// Create an empty antenna list
        /// </summary>
        public AntennaList()
            :
            base()
        {
            // NOP
        }


        /// <summary>
        /// Create an empty antenna list with initial capacity
        /// </summary>
        /// <param name="capacity"></param>
        public AntennaList(Int32 capacity)
            :
            base(capacity)
        {
            // NOP
        }


        /// <summary>
        /// Copy an antenna list ~ no checks for dup ports
        /// </summary>
        /// <param name="enumerable"></param>
        public AntennaList(IEnumerable<Antenna> enumerable)
            :
            base(enumerable)
        {
            // NOP
        }


        /// <summary>
        /// Copy an antenna list ~ performing a DEEP copy of
        /// antennas if indicated
        /// </summary>
        /// <param name="enumerable"></param>
        /// <param name="deepCopy"></param>

        public AntennaList(IEnumerable<Antenna> enumerable, Boolean deepCopy)
            :
            base()
        {
            if (!deepCopy)
            {
                this.AddRange(enumerable);
            }
            else
            {
                this.Copy(enumerable);
            }
        }

        public void Copy(IEnumerable<Antenna> from)
        {
            this.Clear();

            foreach (Antenna antenna in from)
            {
                this.Add(new Antenna(antenna));
            }
        }


        // Attempt to locate antenna with matching ( logical ) port

        public Antenna FindByPort(UInt32 port)
        {
            Antenna Result = this.Find
                (
                    delegate(Antenna antenna)
                    {
                        return antenna.Port == port;
                    }
                );

            return Result;
        }

    } // END class Source_AntennaList


} // END namespace RFID.RFIDInterface
//#endif
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/Antenna/AntennaStatus.cs">
//#if CS468
using System;
using System.Collections.Generic;
using System.Text;

namespace CSLibrary
{
    using CSLibrary.Constants;
    using CSLibrary.Structures;
    /// <summary>
    /// Antenna Status
    /// </summary>
    class AntennaStatus
        :
        Object
    {
        private UInt32 port;
        private AntennaPortStatus antennaPortStatus;


        /// <summary>
        /// Constructor
        /// designed to init for loading from radio
        /// </summary>
        /// <param name="port">Valid port from 0 - 15</param>
        public AntennaStatus
        (
            UInt32 port
        )
            :
            base()
        {
            this.port = port;
            this.antennaPortStatus = new AntennaPortStatus();
        }

        /// <summary>
        /// Copy Constructor
        /// </summary>
        /// <param name="source"></param>
        public AntennaStatus
        (
            AntennaStatus source
        )
            :
            base()
        {
            this.Copy(source);
        }

        /// <summary>
        /// Copy from AntennaStatus
        /// </summary>
        /// <param name="from"></param>
        public void Copy(AntennaStatus from)
        {
            this.port = from.Port;
            this.antennaPortStatus.state = from.State;
            this.antennaPortStatus.antennaSenseValue = from.AntennaSenseValue;
        }

        /// <summary>
        /// check equal
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(System.Object obj)
        {
            if (null == obj)
            {
                return false;
            }

            AntennaStatus rhs = obj as AntennaStatus;

            if (null == (System.Object)rhs)
            {
                return false;
            }

            return this.Equals(rhs);
        }

        /// <summary>
        /// check equal
        /// </summary>
        /// <param name="rhs"></param>
        /// <returns></returns>
        public bool Equals(AntennaStatus rhs)
        {
            if (null == (System.Object)rhs)
            {
                return false;
            }

            return
                   this.port == rhs.port
                && this.antennaPortStatus.state == rhs.antennaPortStatus.state
//#if CS468
                && this.antennaPortStatus.enableLocalFreq == rhs.antennaPortStatus.enableLocalFreq
                && this.antennaPortStatus.enableLocalInv == rhs.antennaPortStatus.enableLocalInv
                && this.antennaPortStatus.enableLocalProfile == rhs.antennaPortStatus.enableLocalProfile
                && this.antennaPortStatus.freqChn == rhs.antennaPortStatus.freqChn
                && this.antennaPortStatus.inv_algo == rhs.antennaPortStatus.inv_algo
                && this.antennaPortStatus.profile == rhs.antennaPortStatus.profile
                && this.antennaPortStatus.startQ == rhs.antennaPortStatus.startQ
//#endif
                && this.antennaPortStatus.antennaSenseValue == rhs.antennaPortStatus.antennaSenseValue;
        }

        /// <summary>
        /// TODO: provide real hash return value
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
        /// <summary>
        /// Load Antenna Status from MAC
        /// </summary>
        /// <param name="transport"></param>
        /// <returns></returns>
        public Result Load
        (
            HighLevelInterface transport
        )
        {
            if (transport == null)
                return Result.NOT_INITIALIZED;
            return transport.rfid.GetAntennaPortStatus
                (
                    this.port,
                    this.antennaPortStatus
                );
        }

        /// <summary>
        /// Store Antenna Status to MAC
        /// </summary>
        /// <param name="transport"></param>
        /// <returns></returns>
        public Result Store
        (
            HighLevelInterface transport
        )
        {
            if (transport == null)
                return Result.NOT_INITIALIZED;
            // There is no save for the AntennaPortStatus in lower library but
            // there is a set state so use that here!

            return transport.rfid.SetAntennaPortState
                (
                    this.port,
                    this.antennaPortStatus.state
                );
        }
        /// <summary>
        /// Get current port number
        /// </summary>
        public UInt32 Port
        {
            get
            {
                return this.port;
            }
        }
        /// <summary>
        /// Get the state of the logical antenna port. 
        /// </summary>
        public AntennaPortState State
        {
            get
            {
                return this.antennaPortStatus.state;
            }
            set
            {
                this.antennaPortStatus.state = value;
            }
        }

//#if CS468
        public Boolean EnableLocalInv
        {
            get { return this.antennaPortStatus.enableLocalInv; }
            set { this.antennaPortStatus.enableLocalInv = value; }
        }
        public Boolean EnableLocalProfile
        {
            get { return this.antennaPortStatus.enableLocalProfile; }
            set { this.antennaPortStatus.enableLocalProfile = value; }
        }
        public Boolean EnableLocalFreq
        {
            get { return this.antennaPortStatus.enableLocalFreq; }
            set { this.antennaPortStatus.enableLocalFreq = value; }
        }
        public SingulationAlgorithm InventoryAlgorithm
        {
            get { return this.antennaPortStatus.inv_algo; }
            set { this.antennaPortStatus.inv_algo = value; }
        }
        public UInt32 StartQ
        {
            get { return this.antennaPortStatus.startQ; }
            set { this.antennaPortStatus.startQ = value; }
        }
        public UInt32 LinkProfile
        {
            get { return this.antennaPortStatus.profile; }
            set { this.antennaPortStatus.profile = value; }
        }
        public UInt32 FreqChannel
        {
            get { return this.antennaPortStatus.freqChn; }
            set { this.antennaPortStatus.freqChn = value; }
        }
//#endif

        /// <summary>
        /// The stored value from the last measurement of the 
        /// antenna-sense resistor for the logical antenna port's 
        /// physical transmit antenna port.  The last measurement 
        /// taken occurred the last time that the carrier wave was 
        /// turned on for this antenna port C note that this means that 
        /// when retrieving the logical antenna port's status, this does 
        /// not Result in an active measurement of the antenna-sense 
        /// resistor.  This value is specified in ohms. 
        /// </summary>
        public UInt32 AntennaSenseValue
        {
            get
            {
                return this.antennaPortStatus.antennaSenseValue;
            }
        }


    } // End class AntennaStatus


} // End namespace CSLibrary
//#endif
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reflection;

namespace CSLibrary
{
    using Constants;
    using Structures;
    using Events;
    using Tools;

    public partial class RFIDReader
    {
        // 0x3002 packet
        void csl_tag_read_epc_only_recurrent_packet_proc(byte[] data, int index)
        {

		}

        // 0x3004 packet
        void csl_tag_read_multibank_recurrent_index_only_packet_proc(byte[] data, int index)
        {

		}

        // 0x3008 packet
        void csl_operation_complete_packet_proc(byte[] data, int index)
        {
            UInt32 UTCTimeStamp = Tools.Hex.MSBToUInt32(data, index);
            UInt16 commandCode = Tools.Hex.MSBToUInt16(data, index + 4);
            UInt16 status = Tools.Hex.MSBToUInt16(data, index + 6);

            Debug.WriteLine("{0:X4} : 0x3008, {1:X2}, {2:X2}", UTCTimeStamp, commandCode, status);

            LastMacErrorCode = status;

            switch (commandCode)
            {
                case 0x10b8:
                    FireAccessCompletedEvent(
                    new CSLibrary.Events.OnAccessCompletedEventArgs(
                    (status == 0x00),
                        Bank.UNKNOWN,
                        TagAccess.KILL,
                        null));
                    break;

            }

/*
            // Fix high current bug (CANNOT FIX)
            if (LastMacErrorCode != 0x0000 && 
                ((commandCode >= 0x10a1 && commandCode <= 0x10a8) ||
                (commandCode >= 0x10b1 && commandCode <= 0x10b9)))
                StopOperation();
*/

            FireStateChangedEvent(RFState.IDLE);
        }

        // 0x1471
        void ReadRegister_packet_proc(byte[] data, int index)
        {
            // 33:A7 B3 19 C2 82 9E 02 9B 81 00     51 E2 14 71    00   00 10     01 07 D0 0B B8 00 06 30 F7 00 00 00 08 01 05 00
            //    A7 B3 73 C2 00 9E B3 F4 81 00     51 E2 14 71    00   00 6A     31 2E 31 2E 30 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 2F 00 00 00 A2 20 1A 06 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF


            int size = (data[15] << 8) + (data[16]);

            if (size == 101) // OEM packet data len
                SaveInitRegisters(index, data, size);
            //else
            //    SaveRegister(17, data, size);


            /*
                        int seq = data[index];
                        index++;

                        do
                        {
                            int len = data[index] << 8 | data[index + 1];

                            if (index + len > data.Length)
                                break;

                            index += 2;
            //                Array.Copy(data, index, buffer, 0, len);
                            index += len;
                        } while (index < data.Length);
            */

            // Init setting after read registers
            InitDefaultChannel_CS710S();
            GenCountryList_CS710S();
            SetDefaultAntennaList();
            FireStateChangedEvent(RFState.INITIALIZATION_COMPLETE);
            FireStateChangedEvent(RFState.IDLE);
        }


        internal CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE DeviceRecvData_CS710S(byte[] recvData, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE currentCommandResponse)
        {
            CSLibrary.HighLevelInterface.BTWAITCOMMANDRESPONSETYPE result = HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1;

            CSLibrary.Debug.WriteLine("Routine : DeviceRecvData");
            int index = 10; // header size

            do
            {
                int header = Tools.Hex.MSBToUInt16(recvData, index);
                int packetcode = Tools.Hex.MSBToUInt16(recvData, index + 2);
                int seqnum = recvData[index + 4];
                int payloadlen = Tools.Hex.MSBToUInt16(recvData, index + 5);

                index += 7;
                switch (header)
                {
                    case 0x49dc:
                        {
                            switch (packetcode)
                            {
                                case 0x3001:
                                    csl_tag_read_epc_only_new_packet_proc(recvData, index);
                                    break;

                                case 0x3002:
                                    csl_tag_read_epc_only_recurrent_packet_proc(recvData, index);
                                    break;

                                case 0x3003:
                                    csl_tag_read_multibank_new_packet_proc(recvData, index);
                                    break;

                                case 0x3004:
                                    csl_tag_read_multibank_recurrent_index_only_packet_proc(recvData, index);
                                    break;

                                case 0x3006:
                                    csl_tag_read_compact_packet_proc(recvData, index);
                                    break;

                                case 0x3007:
                                    csl_miscellaneous_event_packet_proc(recvData, index, payloadlen - 6);
                                    break;

                                case 0x3008:
                                    csl_operation_complete_packet_proc(recvData, index);
                                    result = HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.CSL_OPERATION_COMPLETE;
                                    break;

                                case 0x3009:
                                    csl_access_complete_packet_proc(recvData, index, payloadlen - 12);
                                    break;

                                default:
                                    break;
                            }
                        }
                        break;


                    case 0x51e2:
                        {
                            switch (packetcode)
                            {
                                case 0x1471:
                                    ReadRegister_packet_proc(recvData, index);
                                    StopOperation();
                                    break;

                                case 0x10b1: // read tag
                                    result = HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.ENDEVENTUPLINKPACKET;
                                    break;

                                case 0x10b7: // read tag
                                    result = HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.ENDEVENTUPLINKPACKET;
                                    break;

                                case 0x9a06: // write registers
                                    result = HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.COMMANDENDRESPONSE;
                                    break;
                            }
                        }
                        break;
                }

                index += payloadlen;
            } while (index < recvData.Length);

            return result;
        }

        public Result CancelAllSelectCriteria_CS710S()
        {
            if (RFIDRegister == null)
                return Result.FAILURE;

            RFIDRegister.SelectConfiguration.Enable(0, 6, false);

            return Result.OK;
        }

#region ====================== Set Tag Group ======================
        /// <summary>
        /// Get Tag Group
        /// </summary>
        /// <param name="gpSelect"></param>
        /// <returns></returns>
        public Result SetTagGroup_CS710S(Selected gpSelect)
        {
            RFIDRegister.AntennaPortConfig.Select((uint)gpSelect);

            return (m_Result = Result.OK);
        }

        /// <summary>
        /// Once the tag population has been partitioned into disjoint groups, a subsequent 
        /// tag-protocol operation (i.e., an inventory operation or access command) is then 
        /// applied to one of the tag groups. 
        /// </summary>
        /// <param name="gpSelect">Specifies the state of the selected (SL) flag for tags that will have 
        /// the operation applied to them. </param>
        /// <param name="gpSession">Specifies which inventory session flag (i.e., S0, S1, S2, or S3) 
        /// will be matched against the inventory state specified by target. </param>
        /// <param name="gpSessionTarget">Specifies the state of the inventory session flag (i.e., A or B),
        /// specified by session, for tags that will have the operation 
        /// applied to them. </param>
        public Result SetTagGroup_CS710S(Selected gpSelect, Session gpSession, SessionTarget gpSessionTarget)
		{
            RFIDRegister.AntennaPortConfig.TagGroup((uint)gpSession, (uint)gpSelect, (uint)gpSessionTarget);

            return (m_Result = Result.OK);
        }

        /// <summary>
        /// Once the tag population has been partitioned into disjoint groups, a subsequent 
        /// tag-protocol operation (i.e., an inventory operation or access command) is then 
        /// applied to one of the tag groups. 
        /// </summary>
        /// <param name="tagGroup"><see cref="TagGroup"/></param>
        /// <returns></returns>
        public Result SetTagGroup_CS710S(TagGroup tagGroup)
		{
            RFIDRegister.AntennaPortConfig.TagGroup((uint)tagGroup.session, (uint)tagGroup.selected, (uint)tagGroup.target);

            return (m_Result = Result.OK);
        }
        /// <summary>
        /// Get Tag Group
        /// </summary>
        /// <param name="tagGroup"></param>
        /// <returns></returns>
        internal Result GetTagGroup_CS710S(ref TagGroup tagGroup)
		{
            //RFIDRegister.AntennaPortConfig.TagGroup((uint)tagGroup.session, (uint)tagGroup.selected, (uint)tagGroup.target);
        
            return (m_Result = Result.NOT_SUPPORTED);
		}
#endregion

        public bool SetTagDelayTime_CS710S(UInt32 ms)
        {
            if (ms > 0xff)
                return false;

            //_INVENTORYDELAYTIME = (ms << 20);

            RFIDRegister.IntraPacketDelay.Set((byte)ms);

            return true;
        }

        internal Result CancelAllSelectCriteria_CS701S()
        {
            for (uint cnt = 0; cnt < 7; cnt++)
            {
                SetSelectCriteria_CS710S(cnt, null);
            }

            return Result.OK;
        }

        /// <summary>
        /// Configures the tag-selection criteria for the ISO 18000-6C select 
        /// command.  The supplied tag-selection criteria will be used for any 
        /// tag-protocol operations (i.e., Inventory, etc.) in 
        /// which the application specifies that an ISO 18000-6C select 
        /// command should be issued prior to executing the tag-protocol 
        /// operation (i.e., the SelectFlags.SELECT flag is provided to 
        /// the appropriate RFID_18K6CTag* function).  The tag-selection 
        /// criteria will stay in effect until the next call to 
        /// SetSelectCriteria.  Tag-selection criteria may not 
        /// be changed while a radio module is executing a tag-protocol 
        /// operation. 
        /// </summary>
        /// <param name="critlist">
        /// SelectCriteria array, containing countCriteria entries, of selection 
        /// criterion structures that are to be applied sequentially, beginning with 
        /// pCriteria[0], to the tag population.  If this field is NULL, 
        /// countCriteria must be zero. 
        ///</param>
        /// <returns></returns>

        internal Result SetSelectCriteria_CS710S(SelectCriterion[] critlist)
        {
            uint index;
            uint registerValue;

            if (critlist == null || critlist.Length == 0)
                return Result.INVALID_PARAMETER;

            try
            {
                for (index = 0; index < critlist.Length; index++)
                    SetSelectCriteria_CS710S(index, critlist[index]);


/*
                SelectCriteria SC = new SelectCriteria();
                SC.countCriteria = (uint)critlist.Length;
                SC.pCriteria = (SelectCriterion[])critlist.Clone();

                index = 0;
                {
                    SelectCriterion pCriterion = SC.pCriteria[index];
                    SelectMask pMask = pCriterion.mask;
                    SelectAction pAction = pCriterion.action;

                    // Instruct the MAC as to which select mask we want to work with
                    MacWriteRegister(MACREGISTER.HST_TAGMSK_DESC_SEL, index);

                    // Create the HST_TAGMSK_DESC_CFG register value and write it to the MAC
                    registerValue = (0x01 |
                        (((uint)(pAction.target) & 0x07) << 1) |
                        (((uint)(pAction.action) & 0x07) << 4) |
                        (pAction.enableTruncate != 0x00 ? (uint)(1 << 7) : 0)) |
                        (((uint)(pAction.delay) & 0xFF) << 8);
                    MacWriteRegister(MACREGISTER.HST_TAGMSK_DESC_CFG, registerValue);

                    // Create the HST_TAGMSK_BANK register value and write it to the MAC
                    registerValue = (uint)pMask.bank;
                    MacWriteRegister(MACREGISTER.HST_TAGMSK_BANK, registerValue);

                    // Write the mask offset to the HST_TAGMSK_PTR register
                    MacWriteRegister(MACREGISTER.HST_TAGMSK_PTR, (uint)pMask.offset);

                    // Create the HST_TAGMSK_LEN register and write it to the MAC
                    registerValue = (uint)(pMask.count);
                    MacWriteRegister(MACREGISTER.HST_TAGMSK_LEN, registerValue);

                    // Now write the MAC's mask registers
                    WriteMacMaskRegisters((ushort)MACREGISTER.HST_TAGMSK_0_3, pMask.count, pMask.mask);
                    // Set up the selection criteria
                }
*/
            }
            catch (System.Exception ex)
            {
#if DEBUG
                //				CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.SetSelectCriteria()", ex);
#endif
                return Result.SYSTEM_CATCH_EXCEPTION;
            }
            return m_Result;
        }

        internal Result SetSelectCriteria_CS710S(uint index, SelectCriterion crit)
        {
            try
            {
                if (crit == null)
                {
                    RFIDRegister.SelectConfiguration.Enable(index, false);
                    return Result.OK;
                }

                byte[] a = crit.mask.mask;

                RFIDRegister.SelectConfiguration.Set((int)index, true, (byte)crit.mask.bank, crit.mask.offset, (byte)crit.mask.count, crit.mask.mask, (byte)crit.action.target, (byte)crit.action.action, (byte)crit.action.delay);

                return Result.OK;
            }
            catch (System.Exception ex)
            {
#if DEBUG
                //CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagSelected()", ex);
#endif
                m_Result = CSLibrary.Constants.Result.SYSTEM_CATCH_EXCEPTION;
            }

            return Result.FAILURE;






            /*
                        uint registerValue;

                        // Instruct the MAC as to which select mask we want to work with
                        MacWriteRegister(MACREGISTER.HST_TAGMSK_DESC_SEL, index);

                        if (crit == null)
                        {
                            MacWriteRegister(MACREGISTER.HST_TAGMSK_DESC_CFG, 0x0000);
                            //MacWriteRegister(MACREGISTER.HST_TAGMSK_BANK, 0x0000);
                            //MacWriteRegister(MACREGISTER.HST_TAGMSK_PTR, 0x0000);
                            //MacWriteRegister(MACREGISTER.HST_TAGMSK_LEN, 0x0000);
                            return Result.OK;
                        }

                        try
                        {
                            {
                                SelectCriterion pCriterion = crit;
                                SelectMask pMask = pCriterion.mask;
                                SelectAction pAction = pCriterion.action;

                                // Create the HST_TAGMSK_DESC_CFG register value and write it to the MAC
                                registerValue = (0x01 |
                                    (((uint)(pAction.target) & 0x07) << 1) |
                                    (((uint)(pAction.action) & 0x07) << 4) |
                                    (pAction.enableTruncate != 0x00 ? (uint)(1 << 7) : 0)) |
                                    (((uint)(pAction.delay) & 0xFF) << 8);
                                MacWriteRegister(MACREGISTER.HST_TAGMSK_DESC_CFG, registerValue);

                                // Create the HST_TAGMSK_BANK register value and write it to the MAC
                                registerValue = (uint)pMask.bank;
                                MacWriteRegister(MACREGISTER.HST_TAGMSK_BANK, registerValue);

                                // Write the mask offset to the HST_TAGMSK_PTR register
                                MacWriteRegister(MACREGISTER.HST_TAGMSK_PTR, (uint)pMask.offset);

                                // Create the HST_TAGMSK_LEN register and write it to the MAC
                                registerValue = (uint)(pMask.count);
                                MacWriteRegister(MACREGISTER.HST_TAGMSK_LEN, registerValue);

                                // Now write the MAC's mask registers
                                WriteMacMaskRegisters((ushort)MACREGISTER.HST_TAGMSK_0_3, pMask.count, pMask.mask);
                                // Set up the selection criteria
                            }
                        }
                        catch (System.Exception ex)
                        {
            #if DEBUG
                            //				CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.SetSelectCriteria()", ex);
            #endif
                            return Result.SYSTEM_CATCH_EXCEPTION;
                        }
                        return m_Result;
            */
        }

        #region Public Functions

        internal void Connect_CS710S()
		{
            RegisterInitialize_CS710S();

            //RFIDRegister.EventPacketUplinkEnable.Set(0x0D);
            RFIDRegister.EventPacketUplinkEnable.Set(0x09);

            //ReadReaderOEMData();
        }
        public string GetFirmwareVersionString_CS710S()
        {
            return RFIDRegister.VersionString.Get();
        }

        /// <summary>
        /// Sets the operation mode of RFID radio module.  By default, when 
        /// an application opens a radio, the RFID Reader Library sets the 
        /// reporting mode to non-continuous.  An RFID radio module's 
        /// operation mode will remain in effect until it is explicitly changed 
        /// via RFID_RadioSetOperationMode, or the radio is closed and re-
        /// opened (at which point it will be set to non-continuous mode).  
        /// The operation mode may not be changed while a radio module is 
        /// executing a tag-protocol operation. 
        /// </summary>
        /// <param name="mode">The operation mode for the radio module.</param>
        /// <returns></returns>
        public Result SetOperationMode_CS710S(RadioOperationMode mode)
		{
            return Result.NOT_SUPPORTED; // CS710S 
		}

        /// <summary>
        /// This is used to set inventory duration
        /// </summary>
        /// <param name="duration"></param>
        /// <returns></returns>
        public Result SetInventoryDuration_CS710S(uint duration, uint antennaPort = 0)
		{
            RFIDRegister.AntennaPortConfig.SetDwell((UInt16)duration, (byte)antennaPort);

			return Result.OK;
		}

        public Result SetInventoryDuration_CS710S(uint [] duration)
        {
            Result r;

			for (uint cnt = 0; cnt < duration.Length; cnt++)
                if ((r = SetInventoryDuration_CS710S(duration[cnt], cnt)) != Result.OK)
                    return r;

            return Result.OK;
        }

#endregion

    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Private.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using System.Reflection;


namespace CSLibrary
{
    using Constants;
    using Structures;
    using Events;
    using Tools;

    public partial class RFIDReader
    {
        void Start18K6CRequest_CS710S(uint tagStopCount, SelectFlags flags)
        {
            if ((flags & SelectFlags.SELECT) != 0)
            {
                if (_deviceType == RFIDDEVICE.MODEL.CS710S)
                    RFIDRegister.AntennaPortConfig.Select(3, 0xffff);
                else
                    RFIDRegister.AntennaPortConfig.Select(3);
            }
        }

        private void TagLockThreadProc_CS710S()
        {
            const UInt16 HST_TAGACC_LOCKCFG_MASK_USE_PWD_ACTION = 0x1;
            const UInt16 HST_TAGACC_LOCKCFG_MASK_USE_PERMA_ACTION = 0x2;

            /* HST_TAGACC_LOCKCFG register helper macros                                */
            /* The size of the bit fields in the HST_TAGACC_LOCKCFG register.           */
            const byte HST_TAGACC_LOCKCFG_ACTION_USER_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_ACTION_TID_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_ACTION_EPC_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_ACTION_ACC_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_ACTION_KILL_SIZE = 2;

            const byte HST_TAGACC_LOCKCFG_MASK_USER_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_MASK_TID_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_MASK_EPC_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_MASK_ACC_SIZE = 2;
            const byte HST_TAGACC_LOCKCFG_MASK_KILL_SIZE = 2;

            const byte HST_TAGACC_LOCKCFG_RFU1_SIZE = 12;

            const byte HST_TAGACC_LOCKCFG_ACTION_USER_SHIFT = 0;
            const byte HST_TAGACC_LOCKCFG_ACTION_TID_SHIFT = (HST_TAGACC_LOCKCFG_ACTION_USER_SHIFT + HST_TAGACC_LOCKCFG_ACTION_USER_SIZE);
            const byte HST_TAGACC_LOCKCFG_ACTION_EPC_SHIFT = (HST_TAGACC_LOCKCFG_ACTION_TID_SHIFT + HST_TAGACC_LOCKCFG_ACTION_TID_SIZE);
            const byte HST_TAGACC_LOCKCFG_ACTION_ACC_SHIFT = (HST_TAGACC_LOCKCFG_ACTION_EPC_SHIFT + HST_TAGACC_LOCKCFG_ACTION_EPC_SIZE);
            const byte HST_TAGACC_LOCKCFG_ACTION_KILL_SHIFT = (HST_TAGACC_LOCKCFG_ACTION_ACC_SHIFT + HST_TAGACC_LOCKCFG_ACTION_ACC_SIZE);

            const byte HST_TAGACC_LOCKCFG_MASK_USER_SHIFT = 0;
            const byte HST_TAGACC_LOCKCFG_MASK_TID_SHIFT = (HST_TAGACC_LOCKCFG_MASK_USER_SHIFT + HST_TAGACC_LOCKCFG_MASK_USER_SIZE);
            const byte HST_TAGACC_LOCKCFG_MASK_EPC_SHIFT = (HST_TAGACC_LOCKCFG_MASK_TID_SHIFT + HST_TAGACC_LOCKCFG_MASK_TID_SIZE);
            const byte HST_TAGACC_LOCKCFG_MASK_ACC_SHIFT = (HST_TAGACC_LOCKCFG_MASK_EPC_SHIFT + HST_TAGACC_LOCKCFG_MASK_EPC_SIZE);
            const byte HST_TAGACC_LOCKCFG_MASK_KILL_SHIFT = (HST_TAGACC_LOCKCFG_MASK_ACC_SHIFT + HST_TAGACC_LOCKCFG_MASK_ACC_SIZE);

            const byte HST_TAGACC_LOCKCFG_RFU1_SHIFT = (HST_TAGACC_LOCKCFG_MASK_KILL_SHIFT + HST_TAGACC_LOCKCFG_MASK_KILL_SIZE);

            /* Constants for HST_TAGACC_LOCKCFG register bit fields (note that the      */
            /* values are already shifted into the low-order bits of the constant.      */
            const UInt16 HST_TAGACC_LOCKCFG_ACTION_MEM_WRITE = 0x0;
            const UInt16 HST_TAGACC_LOCKCFG_ACTION_MEM_PERM_WRITE = 0x1;
            const UInt16 HST_TAGACC_LOCKCFG_ACTION_MEM_SEC_WRITE = 0x2;
            const UInt16 HST_TAGACC_LOCKCFG_ACTION_MEM_NO_WRITE = 0x3;
            const UInt16 HST_TAGACC_LOCKCFG_ACTION_PWD_ACCESS = 0x0;
            const UInt16 HST_TAGACC_LOCKCFG_ACTION_PWD_PERM_ACCESS = 0x1;
            const UInt16 HST_TAGACC_LOCKCFG_ACTION_PWD_SEC_ACCESS = 0x2;
            const UInt16 HST_TAGACC_LOCKCFG_ACTION_PWD_NO_ACCESS = 0x3;
            const UInt16 HST_TAGACC_LOCKCFG_MASK_USE_NO_ACTION = 0x0;

            const UInt16 HST_TAGACC_LOCKCFG_MASK_USE_BOTH_ACTION = (HST_TAGACC_LOCKCFG_MASK_USE_PWD_ACTION | HST_TAGACC_LOCKCFG_MASK_USE_PERMA_ACTION);

            const UInt16 RFID_18K6C_TAG_PWD_PERM_ACCESSIBLE = 0x0;
            const UInt16 RFID_18K6C_TAG_PWD_PERM_ALWAYS_NOT_ACCESSIBLE = 0x1;
            const UInt16 RFID_18K6C_TAG_PWD_PERM_ALWAYS_ACCESSIBLE = 0x2;
            const UInt16 RFID_18K6C_TAG_PWD_PERM_SECURED_ACCESSIBLE = 0x3;
            const UInt16 RFID_18K6C_TAG_PWD_PERM_NO_CHANGE = 0x4;

            const UInt16 RFID_18K6C_TAG_MEM_PERM_WRITEABLE = 0x0;             //unlock		00
            const UInt16 RFID_18K6C_TAG_MEM_PERM_ALWAYS_NOT_WRITEABLE = 0x1;  //permlock		01
            const UInt16 RFID_18K6C_TAG_MEM_PERM_ALWAYS_WRITEABLE = 0x2;      //permunlock	10
            const UInt16 RFID_18K6C_TAG_MEM_PERM_SECURED_WRITEABLE = 0x3;     //lock			11
            const UInt16 RFID_18K6C_TAG_MEM_PERM_NO_CHANGE = 0x4;

            UInt16 maskValue = 0;
            UInt16 actionValue = 0;

            if (m_rdr_opt_parms.TagLock.permanentLock)
            {
                actionValue = 0x3ff;
            }
            else
            {
                if (RFID_18K6C_TAG_PWD_PERM_NO_CHANGE == (UInt16)m_rdr_opt_parms.TagLock.killPasswordPermissions)
                {
                    maskValue |= (HST_TAGACC_LOCKCFG_MASK_USE_NO_ACTION << HST_TAGACC_LOCKCFG_MASK_KILL_SHIFT);
                }
                // Otherwise, indicate to look at the kill password bits and set the
                // persmission for it
                else
                {
                    maskValue |= (HST_TAGACC_LOCKCFG_MASK_USE_BOTH_ACTION << HST_TAGACC_LOCKCFG_MASK_KILL_SHIFT);
                    actionValue |= (UInt16)((UInt16)m_rdr_opt_parms.TagLock.killPasswordPermissions << HST_TAGACC_LOCKCFG_ACTION_KILL_SHIFT);
                }

                // If the access password access permissions are not to change, then
                // indicate to ignore those bits.
                if (RFID_18K6C_TAG_PWD_PERM_NO_CHANGE == (UInt16)m_rdr_opt_parms.TagLock.accessPasswordPermissions)
                {
                    maskValue |= HST_TAGACC_LOCKCFG_MASK_USE_NO_ACTION << HST_TAGACC_LOCKCFG_MASK_ACC_SHIFT;
                }
                // Otherwise, indicate to look at the access password bits and set the
                // persmission for it
                else
                {
                    maskValue |= HST_TAGACC_LOCKCFG_MASK_USE_BOTH_ACTION << HST_TAGACC_LOCKCFG_MASK_ACC_SHIFT;
                    actionValue |= (UInt16)((UInt16)m_rdr_opt_parms.TagLock.accessPasswordPermissions << HST_TAGACC_LOCKCFG_ACTION_ACC_SHIFT);
                }

                // If the EPC memory access permissions are not to change, then indicate
                // to ignore those bits.
                if (RFID_18K6C_TAG_MEM_PERM_NO_CHANGE == (UInt16)m_rdr_opt_parms.TagLock.epcMemoryBankPermissions)
                {
                    maskValue |= HST_TAGACC_LOCKCFG_MASK_USE_NO_ACTION << HST_TAGACC_LOCKCFG_MASK_EPC_SHIFT;
                }
                // Otherwise, indicate to look at the EPC memory bits and set the
                // persmission for it
                else
                {
                    maskValue |= HST_TAGACC_LOCKCFG_MASK_USE_BOTH_ACTION << HST_TAGACC_LOCKCFG_MASK_EPC_SHIFT;
                    actionValue |= (UInt16)((UInt16)m_rdr_opt_parms.TagLock.epcMemoryBankPermissions << HST_TAGACC_LOCKCFG_ACTION_EPC_SHIFT);
                }

                // If the TID memory access permissions are not to change, then indicate
                // to ignore those bits.
                if (RFID_18K6C_TAG_MEM_PERM_NO_CHANGE == (UInt16)m_rdr_opt_parms.TagLock.tidMemoryBankPermissions)
                {
                    maskValue |= HST_TAGACC_LOCKCFG_MASK_USE_NO_ACTION << HST_TAGACC_LOCKCFG_MASK_TID_SHIFT;
                }
                // Otherwise, indicate to look at the TID memory bits and set the
                // persmission for it
                else
                {
                    maskValue |= HST_TAGACC_LOCKCFG_MASK_USE_BOTH_ACTION << HST_TAGACC_LOCKCFG_MASK_TID_SHIFT;
                    actionValue |= (UInt16)((UInt16)m_rdr_opt_parms.TagLock.tidMemoryBankPermissions << HST_TAGACC_LOCKCFG_ACTION_TID_SHIFT);
                }

                // If the user memory access permissions are not to change, then indicate
                // to ignore those bits.
                if (RFID_18K6C_TAG_MEM_PERM_NO_CHANGE == (UInt16)m_rdr_opt_parms.TagLock.userMemoryBankPermissions)
                {
                    maskValue |= HST_TAGACC_LOCKCFG_MASK_USE_NO_ACTION << HST_TAGACC_LOCKCFG_MASK_USER_SHIFT;
                }
                // Otherwise, indicate to look at the user memory bits and set the
                // persmission for it
                else
                {
                    maskValue |= HST_TAGACC_LOCKCFG_MASK_USE_BOTH_ACTION << HST_TAGACC_LOCKCFG_MASK_USER_SHIFT;
                    actionValue |= (UInt16)((UInt16)m_rdr_opt_parms.TagLock.userMemoryBankPermissions << HST_TAGACC_LOCKCFG_ACTION_USER_SHIFT);
                }

                // Set LockMask
                RFIDRegister.LockMask.Set(maskValue);

                // Set LockAction
                RFIDRegister.LockAction.Set(actionValue);

                RFIDRegister.AccessPassword.Set(m_rdr_opt_parms.TagLock.accessPassword);

                // run 
                RFIDLockTag();
            }
        }

        private void TagBlockLockThreadProc_CS710S()
        {
        }

        private void TagKillThreadProc_CS710S()
        {
            RFIDRegister.KillPassword.Set(m_rdr_opt_parms.TagKill.killPassword);

            RFIDKillTag();

            m_Result = Result.OK;
            return;

/*            ushort[] tmp = new ushort[1];

            if (RFID_18K6CTagKill())
            {
                if (CUST_18K6CTagRead(
                    MemoryBank.EPC,
                    EPC_START_OFFSET,
                    1,
                    tmp,
                    m_rdr_opt_parms.TagKill.accessPassword,
                    //m_rdr_opt_parms.TagKill.retryCount,
                    SelectFlags.SELECT) != true)
                {
                    //can't read mean killed
                    m_Result = Result.OK;
                    return;
                }
            }
            //FireAccessCompletedEvent(new OnAccessCompletedEventArgs(m_Result == Result.OK, Bank.UNKNOWN, TagAccess.KILL, null));
            //FireStateChangedEvent(RFState.IDLE);*/
        }


        private void TagAuthenticateThreadProc_CS710S()
        {
            RFIDRegister.AccessPassword.Set(m_rdr_opt_parms.TagAuthenticate.password);
            SetAuthenticateConfig_CS710S(Options.TagAuthenticate.SenRep == SENREP.SEND, Options.TagAuthenticate.IncRepLen == INCREPLEN.INCLUDE, Options.TagAuthenticate.CSI, Options.TagAuthenticate.Length);
            SetAuthenticateMessage(Tools.Hex.ToBytes(Options.TagAuthenticate.Message));
            SetAuthenticateResponseLen(Options.TagAuthenticate.ResponseLen);

            SCSLRFIDAuthenticate();
        }

        private void TagReadBufferThreadProc_CS710S()
        {
        }

        private void TagUntraceableThreadProc_CS710S()
        {
            return;
        }


        private bool FM13DTReadMemoryThreadProc_CS710S()
        {
            return false;
        }

        private bool FM13DTWriteMemoryThreadProc_CS710S()
        {
            return false;
        }

        private bool FM13DTReadRegThreadProc_CS710S()
        {
            return true;
        }

        private bool FM13DTWriteRegThreadProc_CS710S()
        {
            return true;
        }

        private bool FM13DTAuthThreadProc_CS710S()
        {
//            FM13DT160_Auth(m_rdr_opt_parms.FM FM13DTWriteMemory.offset, m_rdr_opt_parms.FM13DTWriteMemory.count);
            return true;
        }

        private bool FM13DTGetTempThreadProc_CS710S()
        {
            //FM13DT160_GetTemp(m_rdr_opt_parms.FM13DTWriteMemory.offset, m_rdr_opt_parms.FM13DTWriteMemory.count, m_rdr_opt_parms.FM13DTWriteMemory.data);
            return true;
        }
        private bool FM13DTStartLogThreadProc_CS710S()
        {
            return true;
        }
        private bool FM13DTStopLogChkThreadProc_CS710S()
        {
            return true;
        }
        private bool FM13DTDeepSleepThreadProc_CS710S()
        {
            return true;
        }
        private bool FM13DTOpModeChkThreadProc_CS710S()
        {
            return true;
        }
        private bool FM13DTInitialRegFileThreadProc_CS710S()
        {
            return true;
        }

        private bool FM13DTLedCtrlThreadProc_CS710S()
        {
            return true;
        }

        /// <summary>
        /// rfid reader packet
        /// </summary>
        /// <param name="RW"></param>
        /// <param name="add"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        internal byte[] PacketData_CS710S(UInt16 add, UInt32? value = null)
        {
            byte[] CMDBuf = new byte[8];

            if (value == null)
            {
                CMDBuf[1] = 0x00;
                CMDBuf[4] = 0x00;
                CMDBuf[5] = 0x00;
                CMDBuf[6] = 0x00;
                CMDBuf[7] = 0x00;
            }
            else
            {
                CMDBuf[1] = 0x01;
                CMDBuf[4] = (byte)value;
                CMDBuf[5] = (byte)(value >> 8);
                CMDBuf[6] = (byte)(value >> 16);
                CMDBuf[7] = (byte)(value >> 24);
            }

            CMDBuf[0] = 0x70;
            CMDBuf[2] = (byte)add;
            CMDBuf[3] = (byte)((uint)add >> 8);

            return CMDBuf;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Private.Read.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        //const int MAX_RD_CNT_CS710S = 253; // max 253, old version 0x20

        internal void Setup18K6CReadRegisters_CS710S(UInt32 bank, UInt32 offset, UInt32 count)
        {

            RFIDRegister.MultibankReadConfig.Set(0, true, (int)bank, (int)offset, (int)count);
        }

        internal int Start18K6CRead_CS710S(uint bank, uint offset, uint count, UInt16[] data, uint accessPassword, uint retry, CSLibrary.Constants.SelectFlags flags)
        {
            // Perform the common 18K6C tag operation setup
            Start18K6CRequest(retry, flags);

            Setup18K6CReadRegisters(bank, offset, count);

            // Set up the access password register
            //MacWriteRegister(MACREGISTER.HST_TAGACC_ACCPWD, accessPassword);
            RFIDRegister.AccessPassword.Set(accessPassword);

            // Issue the read command
            //_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.READ), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (UInt32)CurrentOperation);
            RFIDReadMB();

            return 0;
        } //  Start18K6CRead

        internal bool CUST_18K6CTagRead_CS710S(CSLibrary.Constants.MemoryBank bank, int offset, int count, UInt16[] data, UInt32 password, /*UInt32 retry, */CSLibrary.Constants.SelectFlags flags)
        {
            if (count > MAX_RD_CNT)
                return false;       // too many data

            Start18K6CRead_CS710S((uint)bank, (uint)(offset), (uint)count, data, password, 1, flags);

            return true;
        }

        internal void ReadThreadProc_CS710S()
        {
            ushort[] readbuf = new ushort[2];

            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                CurrentOperationResult = CSLibrary.Constants.Result.NO_TAG_FOUND;

                m_rdr_opt_parms.TagRead.m_pData = new UInt16[m_rdr_opt_parms.TagRead.count];

                m_Result = CSLibrary.Constants.Result.OK;

                if (CUST_18K6CTagRead(
                    m_rdr_opt_parms.TagRead.bank,
                    m_rdr_opt_parms.TagRead.offset,
                    m_rdr_opt_parms.TagRead.count,
                    m_rdr_opt_parms.TagRead.m_pData,
                    m_rdr_opt_parms.TagRead.accessPassword,
                    CSLibrary.Constants.SelectFlags.SELECT) != true)
                    m_Result = CSLibrary.Constants.Result.FAILURE;
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.ReadThreadProc()", ex);
#endif
            }
            finally
            {
            }
        }

        internal void TagReadPCThreadProc_CS710S()
        {
            ushort[] readbuf = new ushort[1];

            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                CurrentOperationResult = CSLibrary.Constants.Result.NO_TAG_FOUND;

                m_Result = CSLibrary.Constants.Result.OK;

                if (CUST_18K6CTagRead(
                    CSLibrary.Constants.MemoryBank.BANK1,
                    PC_START_OFFSET,
                    ONE_WORD_LEN,
                    readbuf,
                    m_rdr_opt_parms.TagReadPC.accessPassword,
//                    m_rdr_opt_parms.TagReadPC.retryCount,
                    CSLibrary.Constants.SelectFlags.SELECT) == true)
                    m_rdr_opt_parms.TagReadPC.m_pc = readbuf[0];
                else
                    m_Result = CSLibrary.Constants.Result.FAILURE;
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagReadPCThreadProc()", ex);
#endif
            }
            finally
            {
                /*                FireAccessCompletedEvent(
                                    new OnAccessCompletedEventArgs(
                                    m_Result == CSLibrary.Constants.Result.OK,
                                    CSLibrary.Constants.Bank.PC,
                                    CSLibrary.Constants.TagAccess.READ,
                                    m_rdr_opt_parms.TagReadPC.pc));

                                FireStateChangedEvent(CSLibrary.Constants.RFState.IDLE);
                */
            }
        }

        internal void TagReadEPCThreadProc_CS710S()
        {
            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                CurrentOperationResult = CSLibrary.Constants.Result.NO_TAG_FOUND;

                m_Result = CSLibrary.Constants.Result.OK;

                if (CUST_18K6CTagRead(
                    CSLibrary.Constants.MemoryBank.EPC,
                    (ushort)(EPC_START_OFFSET + m_rdr_opt_parms.TagReadEPC.offset),
                    m_rdr_opt_parms.TagReadEPC.count,
                    m_rdr_opt_parms.TagReadEPC.m_epc,
                    m_rdr_opt_parms.TagReadEPC.accessPassword,
//                    m_rdr_opt_parms.TagReadEPC.retryCount,
                    CSLibrary.Constants.SelectFlags.SELECT) != true)
                    m_Result = CSLibrary.Constants.Result.FAILURE;
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagReadEPCThreadProc()", ex);
#endif
            }
            finally
            {
                /*
                                FireAccessCompletedEvent(
                                    new OnAccessCompletedEventArgs(
                                    m_Result == CSLibrary.Constants.Result.OK,
                                    CSLibrary.Constants.Bank.EPC,
                                    CSLibrary.Constants.TagAccess.READ,
                                    m_rdr_opt_parms.TagReadEPC.epc));

                                FireStateChangedEvent(CSLibrary.Constants.RFState.IDLE);
                */
            }
        }

        internal void TagReadAccPwdThreadProc_CS710S()
        {
            ushort[] readbuf = new ushort[2];

            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                m_Result = CSLibrary.Constants.Result.OK;
                _deviceHandler._currentCmdRemark = (UInt32)CSLibrary.Constants.Operation.TAG_READ_ACC_PWD;

                if (CUST_18K6CTagRead(
                    CSLibrary.Constants.MemoryBank.RESERVED,
                    ACC_PWD_START_OFFSET,
                    TWO_WORD_LEN,
                    readbuf,
                    m_rdr_opt_parms.TagReadAccPwd.accessPassword,
//                    m_rdr_opt_parms.TagReadAccPwd.retryCount,
                    CSLibrary.Constants.SelectFlags.SELECT) == true)
                    m_rdr_opt_parms.TagReadAccPwd.m_password = (uint)(readbuf[0] << 16 | readbuf[1]);
                else
                    m_Result = CSLibrary.Constants.Result.FAILURE;
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagReadAccPwdThreadProc()", ex);
#endif
            }
            finally
            {
 /*               FireAccessCompletedEvent(
                    new OnAccessCompletedEventArgs(
                    m_Result == CSLibrary.Constants.Result.OK,
                    CSLibrary.Constants.Bank.ACC_PWD,
                    CSLibrary.Constants.TagAccess.READ,
                    m_rdr_opt_parms.TagReadAccPwd.password));

                FireStateChangedEvent(CSLibrary.Constants.RFState.IDLE);
*/            }
        }

        internal void TagReadKillPwdThreadProc_CS710S()
        {
            ushort[] readbuf = new ushort[2];

            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                //                m_Result = TagReadKillPwd(m_rdr_opt_parms.TagReadKillPwd);
                m_Result = CSLibrary.Constants.Result.OK;

                if (CUST_18K6CTagRead(
                    CSLibrary.Constants.MemoryBank.RESERVED,
                    KILL_PWD_START_OFFSET,
                    TWO_WORD_LEN,
                    readbuf,
                    m_rdr_opt_parms.TagReadKillPwd.accessPassword,
                    //m_rdr_opt_parms.TagReadKillPwd.retryCount,
                    CSLibrary.Constants.SelectFlags.SELECT) == true)
                    m_rdr_opt_parms.TagReadKillPwd.m_password = (uint)(readbuf[0] << 16 | readbuf[1]);
                else
                    m_Result = CSLibrary.Constants.Result.FAILURE;

            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagReadKillPwdThreadProc()", ex);
#endif
            }
            finally
            {
                /*
                                FireAccessCompletedEvent(
                                    new OnAccessCompletedEventArgs(
                                    m_Result == CSLibrary.Constants.Result.OK,
                                    CSLibrary.Constants.Bank.KILL_PWD,
                                    CSLibrary.Constants.TagAccess.READ,
                                    m_rdr_opt_parms.TagReadKillPwd.password));

                                FireStateChangedEvent(CSLibrary.Constants.RFState.IDLE);
                */
            }
        }

        internal void TagReadTidThreadProc_CS710S()
        {
            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                CurrentOperationResult = CSLibrary.Constants.Result.NO_TAG_FOUND;

                m_Result = CSLibrary.Constants.Result.OK;

                if (CUST_18K6CTagRead(
                    CSLibrary.Constants.MemoryBank.TID,
                    m_rdr_opt_parms.TagReadTid.offset,
                    m_rdr_opt_parms.TagReadTid.count,
                    m_rdr_opt_parms.TagReadTid.pData,
                    m_rdr_opt_parms.TagReadTid.accessPassword,
                    //m_rdr_opt_parms.TagReadTid.retryCount,
                    CSLibrary.Constants.SelectFlags.SELECT) != true)
                    m_Result = CSLibrary.Constants.Result.FAILURE;
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagReadTidThreadProc()", ex);
#endif
            }
            finally
            {
                /*
                                FireAccessCompletedEvent(
                                    new OnAccessCompletedEventArgs(
                                    m_Result == CSLibrary.Constants.Result.OK,
                                    CSLibrary.Constants.Bank.TID,
                                    CSLibrary.Constants.TagAccess.READ,
                                    m_rdr_opt_parms.TagReadTid.tid));

                                FireStateChangedEvent(CSLibrary.Constants.RFState.IDLE);
                */
            }
        }

        internal void TagReadUsrMemThreadProc_CS710S()
        {
            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                CurrentOperationResult = CSLibrary.Constants.Result.NO_TAG_FOUND;

                m_rdr_opt_parms.TagReadUser.m_pData = new UInt16[m_rdr_opt_parms.TagReadUser.count];

                m_Result = CSLibrary.Constants.Result.OK;

                if (CUST_18K6CTagRead(
                    CSLibrary.Constants.MemoryBank.USER,
                    m_rdr_opt_parms.TagReadUser.offset,
                    m_rdr_opt_parms.TagReadUser.count,
                    m_rdr_opt_parms.TagReadUser.m_pData,
                    m_rdr_opt_parms.TagReadUser.accessPassword,
                    //m_rdr_opt_parms.TagReadUser.retryCount,
                    CSLibrary.Constants.SelectFlags.SELECT) != true)
                    m_Result = CSLibrary.Constants.Result.FAILURE;
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagReadUsrMemThreadProc()", ex);
#endif
            }
            finally
            {
                /*                FireAccessCompletedEvent(
                                    new OnAccessCompletedEventArgs(
                                    m_Result == CSLibrary.Constants.Result.OK,
                                    Bank.USER,
                                    TagAccess.READ,
                                    m_rdr_opt_parms.TagReadUser.pData));

                                FireStateChangedEvent(CSLibrary.Constants.RFState.IDLE);
                */
            }
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Private.Select.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        private void TagSelected_CS710S()
        {
            try
            {
                _tagSelectedParms = (Structures.TagSelectedParms)m_rdr_opt_parms.TagSelected.Clone();

                if (m_rdr_opt_parms.TagSelected.bank == Constants.MemoryBank.EPC)
                {
                    byte[] a = m_rdr_opt_parms.TagSelected.epcMask.ToBytes();

                    RFIDRegister.SelectConfiguration.Set(0, true, (byte)m_rdr_opt_parms.TagSelected.bank, (uint)((m_rdr_opt_parms.TagSelected.flags & CSLibrary.Constants.SelectMaskFlags.ENABLE_PC_MASK) == CSLibrary.Constants.SelectMaskFlags.ENABLE_PC_MASK ? 16 : 32 + m_rdr_opt_parms.TagSelected.epcMaskOffset), (byte)m_rdr_opt_parms.TagSelected.epcMaskLength, m_rdr_opt_parms.TagSelected.epcMask.ToBytes(), (byte)CSLibrary.Constants.Target.SELECTED, 0, 0);
                }
                else
                {
                    byte[] a = m_rdr_opt_parms.TagSelected.Mask.ToArray();

                    RFIDRegister.SelectConfiguration.Set(0, true, (byte)m_rdr_opt_parms.TagSelected.bank, m_rdr_opt_parms.TagSelected.MaskOffset, (byte)m_rdr_opt_parms.TagSelected.MaskLength, m_rdr_opt_parms.TagSelected.Mask.ToArray(), (byte)CSLibrary.Constants.Target.SELECTED, 0, 0);
                }
            }
            catch (System.Exception ex)
            {
#if DEBUG
                //CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagSelected()", ex);
#endif
                m_Result = CSLibrary.Constants.Result.SYSTEM_CATCH_EXCEPTION;
            }
        }

        /// <summary>
        /// Only set first EPC ID and length (register 0x804-0x807)
        /// </summary>
        private void FastTagSelected_CS710S()
        {
        }

        private void PreFilter_CS710S()
        {
            try
            {
                _tagSelectedParms = (Structures.TagSelectedParms)m_rdr_opt_parms.TagSelected.Clone();

                if (m_rdr_opt_parms.TagSelected.bank == Constants.MemoryBank.EPC)
                {
                    byte[] a = m_rdr_opt_parms.TagSelected.epcMask.ToBytes();

                    RFIDRegister.SelectConfiguration.Set(0, true, (byte)m_rdr_opt_parms.TagSelected.bank, (uint)((m_rdr_opt_parms.TagSelected.flags & CSLibrary.Constants.SelectMaskFlags.ENABLE_PC_MASK) == CSLibrary.Constants.SelectMaskFlags.ENABLE_PC_MASK ? 16 : 32 + m_rdr_opt_parms.TagSelected.epcMaskOffset), (byte)m_rdr_opt_parms.TagSelected.epcMaskLength, m_rdr_opt_parms.TagSelected.epcMask.ToBytes(), (byte)CSLibrary.Constants.Target.SELECTED, 0, 0);
                }
                else
                {
                    byte[] a = m_rdr_opt_parms.TagSelected.Mask.ToArray();

                    RFIDRegister.SelectConfiguration.Set(0, true, (byte)m_rdr_opt_parms.TagSelected.bank, m_rdr_opt_parms.TagSelected.epcMaskOffset, (byte)m_rdr_opt_parms.TagSelected.epcMaskLength, m_rdr_opt_parms.TagSelected.Mask.ToArray(), (byte)CSLibrary.Constants.Target.SELECTED, 0, 0);
                }
            }
            catch (System.Exception ex)
            {
#if DEBUG
                //CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagSelected()", ex);
#endif
                m_Result = CSLibrary.Constants.Result.SYSTEM_CATCH_EXCEPTION;
            }


/*

            try
            {
                UInt32 value = 0;

                MacReadRegister(MACREGISTER.HST_TAGACC_DESC_CFG, ref value);
                value |= 0x0001U; // Enable Verify after write
                MacWriteRegister(MACREGISTER.HST_TAGACC_DESC_CFG, value);

                MacReadRegister(MACREGISTER.HST_QUERY_CFG, ref value);
                value &= ~0x0200U; // Enable Ucode Parallel encoding
                MacWriteRegister(MACREGISTER.HST_QUERY_CFG, value);

                CSLibrary.Structures.SelectCriterion[] sel = new CSLibrary.Structures.SelectCriterion[1];
                sel[0] = new CSLibrary.Structures.SelectCriterion();
                sel[0].action = new CSLibrary.Structures.SelectAction(CSLibrary.Constants.Target.SELECTED,
                    (m_rdr_opt_parms.TagSelected.flags & CSLibrary.Constants.SelectMaskFlags.ENABLE_NON_MATCH) == CSLibrary.Constants.SelectMaskFlags.ENABLE_NON_MATCH ?
                    CSLibrary.Constants.Action.DSLINVB_ASLINVA : CSLibrary.Constants.Action.ASLINVA_DSLINVB, 0);

                //SetTagGroup(CSLibrary.Constants.Selected.ASSERTED, CSLibrary.Constants.Session.S0, CSLibrary.Constants.SessionTarget.A);
                SetTagGroup(CSLibrary.Constants.Selected.ASSERTED);

                if (m_rdr_opt_parms.TagSelected.bank == CSLibrary.Constants.MemoryBank.EPC)
                {
                    sel[0].mask = new CSLibrary.Structures.SelectMask(
                        m_rdr_opt_parms.TagSelected.bank,
                        (uint)((m_rdr_opt_parms.TagSelected.flags & CSLibrary.Constants.SelectMaskFlags.ENABLE_PC_MASK) == CSLibrary.Constants.SelectMaskFlags.ENABLE_PC_MASK ? 16 : 32 + m_rdr_opt_parms.TagSelected.epcMaskOffset),
                        m_rdr_opt_parms.TagSelected.epcMaskLength,
                        m_rdr_opt_parms.TagSelected.epcMask.ToBytes());
                }
                else
                {
                    sel[0].mask = new CSLibrary.Structures.SelectMask(
                        m_rdr_opt_parms.TagSelected.bank,
                        m_rdr_opt_parms.TagSelected.MaskOffset,
                        m_rdr_opt_parms.TagSelected.MaskLength,
                        m_rdr_opt_parms.TagSelected.Mask);
                }
                if ((m_Result = SetSelectCriteria(sel)) != CSLibrary.Constants.Result.OK)
                {
                    //goto EXIT;
                }
            }
            catch (System.Exception ex)
            {
#if DEBUG
                //CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagSelected()", ex);
#endif
                m_Result = CSLibrary.Constants.Result.SYSTEM_CATCH_EXCEPTION;
            }
*/
        }

        private void SetMaskThreadProc_CS710S()
        {
        }

        private void PostFilter_CS710S()
        {
        }

    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Private.Write.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        const int MAX_WR_CNT_710S = 0x20;

        void Setup18K6CWriteRegisters_CS710S(CSLibrary.Constants.MemoryBank WriteBank, UInt32 WriteOffset, UInt32 WriteSize, UInt16[] WriteBuf, UInt32 BufOffset)
        {
            //int offset;
            //int pcnt = 0;

            byte[] baWriteBuf = CSLibrary.Tools.Hex.ToBytes(WriteBuf);

            RFIDRegister.MultibankWriteConfig.Set(0, true, (byte)WriteBank, WriteOffset, (byte)WriteSize, baWriteBuf);

            return;

#if oldcode
            // Set up the tag bank register (tells where to write the data)
            //            MacWriteRegister(MACREGISTER.HST_TAGACC_BANK, (uint)WriteBank);

            // Set the offset
            //MacWriteRegister(MACREGISTER.HST_TAGACC_PTR, WriteOffset);
            //            MacWriteRegister(MACREGISTER.HST_TAGACC_PTR, 0);

            // Set up the access count register (i.e., number of words to write)
            //            MacWriteRegister(MACREGISTER.HST_TAGACC_CNT, WriteSize);

            // Set up the HST_TAGWRDAT_N registers.  Fill up a bank at a time.
            for (UInt32 registerBank = 0; WriteSize > 0; registerBank++)
            {
                uint value = 0;

                // Indicate which bank of tag write registers we are going to fill
                MacWriteRegister(MACREGISTER.HST_TAGWRDAT_SEL, registerBank);

                /*
				MacReadRegister(MACREGISTER.MAC_ERROR, ref value);

				if (value == HOSTIF_ERR_SELECTORBNDS)
				{
					MacClearError();
					return;
				}
				*/

                // Write the values to the bank until either the bank is full or we run out of data
                UInt16 registerAddress = (UInt16)MACREGISTER.HST_TAGWRDAT_0;
                offset = 0;

                while ((WriteSize > 0) && (offset < 16 /*RFID_NUM_TAGWRDAT_REGS_PER_BANK*/))
                {
                    // Set up the register and then write it to the MAC
                    UInt32 registerValue = (uint)(WriteBuf[BufOffset + pcnt] | ((WriteOffset + pcnt) << 16));

                    MacWriteRegister((MACREGISTER)(registerAddress), registerValue);

                    pcnt++;
                    registerAddress++;
                    offset++;
                    WriteSize--;
                }
            }
#endif
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="bank"></param>
        /// <param name="offset"></param>
        /// <param name="count"></param>
        /// <param name="data"></param>
        /// <param name="password"></param>
        /// <param name="retry"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        private CSLibrary.Constants.Result CUST_18K6CTagWrite_CS710S(
            CSLibrary.Constants.MemoryBank bank,
            UInt32 offset,
            UInt32 count,
            UInt16[] data,
            UInt32 password,
            CSLibrary.Constants.SelectFlags flags
        )
        {
            if (count > MAX_WR_CNT)
                return CSLibrary.Constants.Result.DEVICE_NOT_SUPPORT;       // too many data

            Start18K6CRequest(1, flags);
            RFIDRegister.AccessPassword.Set(password);
            Setup18K6CWriteRegisters(bank, offset, count, data, 0);
            RFIDWriteMB();

            return CSLibrary.Constants.Result.OK;
        }

        private void WriteThreadProc_CS710S()
        {
            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                UInt16[] readData = new UInt16[m_rdr_opt_parms.TagWrite.count];
                UInt16[] writeData = m_rdr_opt_parms.TagWrite.pData;
                UInt16[] readCmp = new UInt16[MAX_WR_CNT];
                bool status;

                m_Result = CSLibrary.Constants.Result.OK;

                m_Result = CUST_18K6CTagWrite(
                    m_rdr_opt_parms.TagWrite.bank,
                    (uint)(m_rdr_opt_parms.TagWrite.offset),
                    m_rdr_opt_parms.TagWrite.count,
                    writeData,
                    m_rdr_opt_parms.TagWrite.accessPassword,
                    CSLibrary.Constants.SelectFlags.SELECT);
            }
            catch (System.Exception ex)
            {
#if DEBUG
                //                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagWriteUsrMemThreadProc()", ex);
#endif
            }
            finally
            {
            }
        }

        private void TagWritePCThreadProc_CS710S()
        {
            UInt16[] readData = new UInt16[1];
            UInt16[] writeData = new UInt16[1];

            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                //                m_Result = TagWritePC(m_rdr_opt_parms.TagWritePC);

                writeData[0] = m_rdr_opt_parms.TagWritePC.pc;
                                m_Result = CUST_18K6CTagWrite(
                                    CSLibrary.Constants.MemoryBank.EPC,
                                    PC_START_OFFSET,
                                    ONE_WORD_LEN,
                                    writeData,
                                    m_rdr_opt_parms.TagWritePC.accessPassword,
                                    //m_rdr_opt_parms.TagWritePC.retryCount,
                                    //m_rdr_opt_parms.TagWritePC.writeRetryCount,
                                    CSLibrary.Constants.SelectFlags.SELECT);
                }
                catch (System.Exception ex)
                {
    #if DEBUG
    //                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagWritePCThreadProc()", ex);
    #endif
                }
                finally
                {
/*                            FireAccessCompletedEvent(
                        new OnAccessCompletedEventArgs(
                        m_Result == Result.OK,
                        Bank.PC,
                        TagAccess.WRITE,
                        new S_PC(m_rdr_opt_parms.TagWritePC.pc)));

                    FireStateChangedEvent(RFState.IDLE);
*/              }
        }

        private void TagWriteEPCThreadProc_CS710S()
        {
            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                UInt16[] readData = new UInt16[m_rdr_opt_parms.TagWriteEPC.count];
                UInt16[] writeData = m_rdr_opt_parms.TagWriteEPC.epc.ToUshorts();
                UInt16[] readCmp = new UInt16[MAX_WR_CNT];
                bool status;

                m_Result = CSLibrary.Constants.Result.OK;

                m_Result = CUST_18K6CTagWrite(
                    CSLibrary.Constants.MemoryBank.EPC,
                    (uint)(EPC_START_OFFSET + m_rdr_opt_parms.TagWriteEPC.offset),
                    m_rdr_opt_parms.TagWriteEPC.count,
                    writeData,
                    m_rdr_opt_parms.TagWriteEPC.accessPassword,
                    //m_rdr_opt_parms.TagWriteEPC.retryCount,
                    //m_rdr_opt_parms.TagWriteEPC.writeRetryCount,
                    CSLibrary.Constants.SelectFlags.SELECT);
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagWriteEPCThreadProc()", ex);
#endif
            }
            finally
            {
/*                FireAccessCompletedEvent(
                    new OnAccessCompletedEventArgs(
                    m_Result == Result.OK,
                    Bank.EPC,
                    TagAccess.WRITE,
                    m_rdr_opt_parms.TagWriteEPC.epc));

                FireStateChangedEvent(RFState.IDLE);
*/            }
        }

        private void TagWriteAccPwdThreadProc_CS710S()
        {
            UInt16[] writeData = new UInt16[2];

            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                //                m_Result = TagWriteAccPwd(m_rdr_opt_parms.TagWriteAccPwd);
                writeData[0] = (ushort)(m_rdr_opt_parms.TagWriteAccPwd.password >> 16);
                writeData[1] = (ushort)m_rdr_opt_parms.TagWriteAccPwd.password;

                m_Result = CUST_18K6CTagWrite(
                    CSLibrary.Constants.MemoryBank.RESERVED,
                    ACC_PWD_START_OFFSET,
                    TWO_WORD_LEN,
                    writeData,
                    m_rdr_opt_parms.TagWriteAccPwd.accessPassword,
                    //m_rdr_opt_parms.TagWriteAccPwd.retryCount,
                    //m_rdr_opt_parms.TagWriteAccPwd.writeRetryCount,
                    CSLibrary.Constants.SelectFlags.SELECT);
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagWriteAccPwdThreadProc()", ex);
#endif
            }
            finally
            {
                /*
                FireAccessCompletedEvent(
                    new OnAccessCompletedEventArgs(
                    m_Result == Result.OK,
                    Bank.ACC_PWD,
                    TagAccess.WRITE,
                    new S_PWD(m_rdr_opt_parms.TagWriteAccPwd.password)));

                FireStateChangedEvent(RFState.IDLE);*/
            }
        }

        private void TagWriteKillPwdThreadProc_CS710S()
        {
            UInt16[] writeData = new UInt16[2];

            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                //m_Result = TagWriteKillPwd(m_rdr_opt_parms.TagWriteKillPwd);

                writeData[0] = (UInt16)(m_rdr_opt_parms.TagWriteKillPwd.password >> 16);
                writeData[1] = (UInt16)(m_rdr_opt_parms.TagWriteKillPwd.password);

                m_Result = CUST_18K6CTagWrite(
                    CSLibrary.Constants.MemoryBank.RESERVED,
                    KILL_PWD_START_OFFSET,
                    TWO_WORD_LEN,
                    writeData,
                    m_rdr_opt_parms.TagWriteKillPwd.accessPassword,
                    //m_rdr_opt_parms.TagWriteKillPwd.retryCount,
                    //m_rdr_opt_parms.TagWriteKillPwd.writeRetryCount,
                    CSLibrary.Constants.SelectFlags.SELECT);
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagWriteKillPwdThreadProc()", ex);
#endif
            }
            finally
            {
/*                FireAccessCompletedEvent(
                    new OnAccessCompletedEventArgs(
                    m_Result == Result.OK,
                    Bank.KILL_PWD,
                    TagAccess.WRITE,
                    new S_PWD(m_rdr_opt_parms.TagWriteKillPwd.password)));

                FireStateChangedEvent(RFState.IDLE);
*/            }
        }

        private void TagWriteUsrMemThreadProc_CS710S()
        {
            try
            {
                FireStateChangedEvent(CSLibrary.Constants.RFState.BUSY);

                UInt16[] readData = new UInt16[m_rdr_opt_parms.TagWriteUser.count];
                UInt16[] writeData = m_rdr_opt_parms.TagWriteUser.pData;
                UInt16[] readCmp = new UInt16[MAX_WR_CNT];
                bool status;

                m_Result = CSLibrary.Constants.Result.OK;

                m_Result = CUST_18K6CTagWrite(
                    CSLibrary.Constants.MemoryBank.USER,
                    (uint)(m_rdr_opt_parms.TagWriteUser.offset),
                    m_rdr_opt_parms.TagWriteUser.count,
                    writeData,
                    m_rdr_opt_parms.TagWriteUser.accessPassword,
                    //m_rdr_opt_parms.TagWriteUser.retryCount,
                    //m_rdr_opt_parms.TagWriteUser.writeRetryCount,
                    CSLibrary.Constants.SelectFlags.SELECT);
            }
            catch (System.Exception ex)
            {
#if DEBUG
//                CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.TagWriteUsrMemThreadProc()", ex);
#endif
            }
            finally
            {
/*                FireAccessCompletedEvent(
                    new OnAccessCompletedEventArgs(
                    m_Result == Result.OK,
                    Bank.USER,
                    TagAccess.WRITE,
                    new S_DATA(m_rdr_opt_parms.TagWriteUser.pData)));

                FireStateChangedEvent(RFState.IDLE);
*/            }
        }

        private void BlockWriteThreadProc_CS710S()
        {
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Public.Algorithm.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;
using CSLibrary.Structures;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        /// <summary>
        /// Allows the application to set the currently-active singulation 
        /// algorithm (i.e., the one that is used when performing a tag-
        /// protocol operation (e.g., inventory, tag read, etc.)).  The 
        /// currently-active singulation algorithm may not be changed while a 
        /// radio module is executing a tag-protocol operation. 
        /// </summary>
        /// <param name="SingulationAlgorithm">
        /// The singulation algorithm that is to be used for 
        /// subsequent tag-access operations.  If this 
        /// parameter does not represent a valid 
        /// singulation algorithm, 
        /// RFID_ERROR_INVALID_PARAMETER is returned. </param>m
        public Result SetCurrentSingulationAlgorithm_CS710S(SingulationAlgorithm SingulationAlgorithm)
        {
            if (SingulationAlgorithm == SingulationAlgorithm.FIXEDQ)
                RFIDRegister.AntennaPortConfig.EnableFixedQ();
            else
                RFIDRegister.AntennaPortConfig.EnableDynamicQ();

            return Result.OK;
        }

        /// <summary>
        /// Get Current Singulation Algorithm
        /// </summary>
        /// <param name="SingulationAlgorithm"></param>
        /// <returns></returns>
        public Result GetCurrentSingulationAlgorithm_CS710S(ref SingulationAlgorithm SingulationAlgorithm)
        {
            if (RFIDRegister.AntennaPortConfig.GetCurrentAlgorithm() == 0)
                SingulationAlgorithm = SingulationAlgorithm.DYNAMICQ;
            else
                SingulationAlgorithm = SingulationAlgorithm.FIXEDQ;

            return Result.OK;
        }

        /// <summary>
        /// SetSingulationAlgorithmParms
        /// </summary>
        /// <param name="alg"></param>
        /// <param name="parms"></param>
        /// <returns></returns>
        public Result SetSingulationAlgorithmParms_CS710S(SingulationAlgorithm alg, SingulationAlgorithmParms parms)
        {
            if (alg == SingulationAlgorithm.UNKNOWN)
                return Result.INVALID_PARAMETER;

            try
            {
                switch (alg)
                {
                    case SingulationAlgorithm.FIXEDQ:
                        {
                            FixedQParms p = (FixedQParms)parms;
                            RFIDRegister.AntennaPortConfig.EnableFixedQ(p.qValue, 0); // Query Target alway A
                            RFIDRegister.AntennaPortConfig.SetTargetToggle(p.toggleTarget > 0);
                        }
                        break;

                    case SingulationAlgorithm.DYNAMICQ:
                        {
                            DynamicQParms p = (DynamicQParms)parms;
                            RFIDRegister.AntennaPortConfig.EnableDynamicQ(p.minQValue, p.maxQValue, p.startQValue, p.MinQCycles, p.QDecreaseUseQuery, p.QIncreaseUseQuery, 0); // Query Target alway A
                            RFIDRegister.AntennaPortConfig.MaxQSinceValidEpc(p.NoEPCMaxQ);
                            RFIDRegister.AntennaPortConfig.SetTargetToggle(p.toggleTarget > 0);
                        }
                        break;

                    default:
                        return Result.INVALID_PARAMETER;
                } // switch (algorithm)

            }
            catch (Exception ex)
            {

            }

            return (m_Result = Result.OK);
            //return (m_Result = SetCurrentSingulationAlgorithm(alg));
        }

        /// <summary>
        /// The  parameters  for  the  fixed-Q  algorithm,  MAC  singulation  algorithm  0
        /// If running a same operation, it only need to config once times
        /// </summary>
        /// <param name="QValue">The Q value to use.  Valid values are 0-15, inclusive.</param>
        /// <param name="RetryCount">Specifies the number of times to try another execution 
        /// of the singulation algorithm for the specified 
        /// session/target before either toggling the target (if 
        /// toggleTarget is non-zero) or terminating the 
        /// inventory/tag access operation.  Valid values are 0-
        /// 255, inclusive. Valid values are 0-255, inclusive.</param>
        /// <param name="ToggleTarget"> A non-zero value indicates that the target should
        /// be toggled.A zero value indicates that the target should not be toggled.
        /// Note that if the target is toggled, retryCount and repeatUntilNoTags will also apply
        /// to the new target. </param>
        public Result SetFixedQParms_CS710S(uint QValue, uint ToggleTarget)
        {
            FixedQParms FixedQParm = new FixedQParms();
            FixedQParm.qValue = QValue;      //if only 1 tag read and write, otherwise use 7
            FixedQParm.toggleTarget = ToggleTarget;

            return (m_Result = SetSingulationAlgorithmParms_CS710S(SingulationAlgorithm.FIXEDQ, FixedQParm));
        }
        /// <summary>
        /// The  parameters  for  the  fixed-Q  algorithm,  MAC  singulation  algorithm  0
        /// If running a same operation, it only need to config once times
        /// </summary>
        /// <returns></returns>
        public Result SetFixedQParms_CS710S(FixedQParms fixedQParm)
        {
            return (m_Result = SetSingulationAlgorithmParms_CS710S(SingulationAlgorithm.FIXEDQ, fixedQParm));
        }
        /// <summary>
        /// The  parameters  for  the  fixed-Q  algorithm,  MAC  singulation  algorithm  0
        /// If running a same operation, it only need to config once times
        /// </summary>
        /// <returns></returns>
        public Result SetFixedQParms_CS710S()
        {
            FixedQParms FixedQParm = new FixedQParms();
            FixedQParm.qValue = 7;      //if only 1 tag read and write, otherwise use 7
            FixedQParm.toggleTarget = 1;

            return (m_Result = SetSingulationAlgorithmParms_CS710S(SingulationAlgorithm.FIXEDQ, FixedQParm));
        }

        /// <summary>
        /// The parameters for the dynamic-Q algorithm with application-controlled Q-adjustment-threshold, MAC singulation algorithm 3
        /// </summary>
        /// <param name="StartQValue">The starting Q value to use.  Valid values are 0-15, inclusive.  
        /// startQValue must be greater than or equal to minQValue and 
        /// less than or equal to maxQValue. </param>
        /// <param name="MinQValue">The minimum Q value to use.  Valid values are 0-15, inclusive.  
        /// minQValue must be less than or equal to startQValue and 
        /// maxQValue. </param>
        /// <param name="MaxQValue">The maximum Q value to use.  Valid values are 0-15, inclusive.  
        /// maxQValue must be greater than or equal to startQValue and 
        /// minQValue. </param>
        /// <param name="ToggleTarget">A flag that indicates if, after performing the inventory cycle for the 
        /// specified target (i.e., A or B), if the target should be toggled (i.e., 
        /// A to B or B to A) and another inventory cycle run.  A non-zero 
        /// value indicates that the target should be toggled.  A zero value 
        /// indicates that the target should not be toggled.  Note that if the 
        /// target is toggled, retryCount and maxQueryRepCount will 
        /// also apply to the new target. </param>
        public Result SetDynamicQParms_CS710S(uint StartQValue, uint MinQValue, uint MaxQValue, uint ToggleTarget)
        {
            DynamicQParms dynParm = new DynamicQParms();
            dynParm.startQValue = StartQValue;
            dynParm.maxQValue = MaxQValue;      //if only 1 tag read and write, otherwise use 7
            dynParm.minQValue = MinQValue;
            dynParm.toggleTarget = ToggleTarget;

            return (m_Result = SetSingulationAlgorithmParms_CS710S(SingulationAlgorithm.DYNAMICQ, dynParm));
        }
        /// <summary>
        /// The parameters for the dynamic-Q algorithm with application-controlled Q-adjustment-threshold
        /// </summary>
        /// <returns></returns>
        public Result SetDynamicQParms_CS710S(DynamicQParms dynParm)
        {
            return (m_Result = SetSingulationAlgorithmParms_CS710S(SingulationAlgorithm.DYNAMICQ, dynParm));
        }
        /// <summary>
        /// The parameters for the dynamic-Q algorithm with application-controlled Q-adjustment-threshold
        /// </summary>
        /// <returns></returns>
        public Result SetDynamicQParms_CS710S()
        {
            DynamicQParms dynParm = new DynamicQParms();
            dynParm.startQValue = 7;
            dynParm.maxQValue = 15;      //if only 1 tag read and write, otherwise use 7
            dynParm.minQValue = 0;
            dynParm.toggleTarget = 1;

            return (m_Result = SetSingulationAlgorithmParms_CS710S(SingulationAlgorithm.DYNAMICQ, dynParm));
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Public.Antenna.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Text;



namespace CSLibrary
{
    using Constants;
    using Structures;

    public partial class RFIDReader
    {
        private Result AntennaPortSetState_CS710S(UInt32 antennaPort, AntennaPortState state)
        {

            switch (state)
            {
                case AntennaPortState.DISABLED:
                    {
                        RFIDRegister.AntennaPortConfig.Enable(false, (byte)antennaPort);
                        break;
                    } // case RFID_ANTENNA_PORT_STATE_DISABLED
                case AntennaPortState.ENABLED:
                    {
                        RFIDRegister.AntennaPortConfig.Enable(true, (byte)antennaPort);
                        break;
                    } // case RFID_ANTENNA_PORT_STATE_ENABLED
                default:
                    return Result.INVALID_PARAMETER;
            }

            return Result.OK;
        }

        private Result AntennaPortSetState_CS710S(int startPort, int endPort, AntennaPortState state)
        {

            switch (state)
            {
                case AntennaPortState.DISABLED:
                    {
                        RFIDRegister.AntennaPortConfig.Enable(false, startPort, endPort);
                        break;
                    } // case RFID_ANTENNA_PORT_STATE_DISABLED
                case AntennaPortState.ENABLED:
                    {
                        RFIDRegister.AntennaPortConfig.Enable(true, startPort, endPort);
                        break;
                    } // case RFID_ANTENNA_PORT_STATE_ENABLED
                default:
                    return Result.INVALID_PARAMETER;
            }

            return Result.OK;
        }
    }
}

#if oldcode
namespace CSLibrary
{
    public partial class RFIDReader
    {
        //AntennaList m_AntennaList = nullnew AntennaList(AntennaList.DEFAULT_ANTENNA_LIST, true);
        AntennaList m_AntennaList = null;

        public AntennaList AntennaList
        {
            get { lock (m_AntennaList) return m_AntennaList; }
            set { lock (m_AntennaList) m_AntennaList = value; }
        }

        public Result SetDefaultAntennaList()
        {
            //DEBUG_WriteLine(DEBUGLEVEL.API, "HighLevelInterface.SetDefaultAntennaList()");
            
            m_AntennaList = new AntennaList();

            switch (m_oem_machine)
            {
                case Machine.CS108:
                default:
                    m_AntennaList.Add(new Antenna(0, AntennaPortState.ENABLED, 300, 0, 0x2000, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    break;

                case Machine.CS203X:
                    m_AntennaList.Add(new Antenna(0, AntennaPortState.ENABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(1, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    break;

                case Machine.CS463:
                    m_AntennaList.Add(new Antenna(0, AntennaPortState.ENABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(1, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(2, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(3, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    break;

                case Machine.CS468X:
                case Machine.CS468XJ:
                    m_AntennaList.Add(new Antenna(0, AntennaPortState.ENABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(1, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(2, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(3, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(4, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(5, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(6, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(7, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(8, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(9, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(10, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(11, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(12, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(13, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(14, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    m_AntennaList.Add(new Antenna(15, AntennaPortState.DISABLED, 300, 2000, 0, false, false, SingulationAlgorithm.DYNAMICQ, 0, false, 0, false, 0, 1048575));
                    break;
            }

            try
            {
                int i;
                //m_AntennaList = new AntennaList(AntennaList.DEFAULT_ANTENNA_LIST, true);
                for (i = 0; i < m_AntennaList.Count; i++)
                {
                    if (m_AntennaList[i].PowerLevel > GetSoftwareMaxPowerLevel(m_save_region_code))
                        m_AntennaList[i].PowerLevel = GetSoftwareMaxPowerLevel(m_save_region_code);

                    SetAntennaPortStatus((uint)i, m_AntennaList[i].AntennaStatus);
                    SetAntennaPortConfiguration((uint)i, m_AntennaList[i].AntennaConfig);
                }

                for (; i < 16; i++)
                {
                    AntennaPortSetState((uint)i, AntennaPortState.DISABLED);
                    //SetAntennaPortState((uint)i, AntennaPortState.DISABLED);  
                }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("HighLevelInterface.SetDefaultAntennaList() : " + ex.Message);
                //DEBUG_WriteLine(DEBUGLEVEL.API, "HighLevelInterface.SetDefaultAntennaList() : " + ex.Message);
                //CSLibrary.Diagnostics.CoreDebug.Logger.ErrorException("HighLevelInterface.SetDefaultAntennaList()", ex);
            }

            return Result.OK;
        }

        /// <summary>
        /// Retrieves the status of the requested logical antenna port for a 
        /// particular radio module.  The antenna-port status cannot be 
        /// retrieved while a radio module is executing a tag-protocol 
        /// operation. 
        /// </summary>
        /// <param name="portStatus"></param>
        /// <returns></returns>
        public Result GetAntennaPortStatus(AntennaPortStatus portStatus)
        {
            return (m_Result = AntennaPortGetStatus(0, portStatus));
        }

        /// <summary>
        /// Retrieves the status of the requested logical antenna port for a 
        /// particular radio module.  The antenna-port status cannot be 
        /// retrieved while a radio module is executing a tag-protocol 
        /// operation. 
        /// </summary>
        /// <param name="port">antenna port</param>
        /// <param name="portStatus"></param>
        /// <returns></returns>
        public Result GetAntennaPortStatus(uint port, AntennaPortStatus portStatus)
        {
            return (m_Result = AntennaPortGetStatus(port, portStatus));
        }

        public Result AntennaPortGetStatus(uint port, AntennaPortStatus portStatus)
        {
            UInt32 registerValue = 0;

            // First, tell the MAC which antenna descriptors we'll be reading and
            // verify that it was a valid selector
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_SEL, port);

            /*
            MacReadRegister(MACREGISTER.MAC_ERROR, ref registerValue);

            if (registerValue == HOSTIF_ERR_SELECTORBNDS)
            {
                MacClearError();
                return Result.INVALID_PARAMETER;
            }
            */

            // Get the state of the antenna
            MacReadRegister(MACREGISTER.HST_ANT_DESC_CFG, ref registerValue);

            portStatus.state = ((registerValue & 0x01) != 0x00 ? AntennaPortState.ENABLED : AntennaPortState.DISABLED);
            portStatus.enableLocalInv = (registerValue & (1 << 1)) != 00;
            portStatus.inv_algo = (SingulationAlgorithm)(registerValue >> 2 & 0x03);
            portStatus.startQ = registerValue >> 4 & 0x0f;
            portStatus.enableLocalProfile = (registerValue & (1 << 8)) != 00;
            portStatus.profile = registerValue >> 9 & 0x0f;
            portStatus.enableLocalFreq = (registerValue & (1 << 13)) != 00;
            portStatus.freqChn = registerValue >> 14 & 0x3f;

            // Now read the anteanna sense value
            MacReadRegister(MACREGISTER.MAC_ANT_DESC_STAT, ref registerValue);
            portStatus.antennaSenseValue = registerValue;

            return Result.OK;
        }

        /// <summary>
        /// Retrieves the status of the requested logical antenna port for a 
        /// particular radio module.  The antenna-port status cannot be 
        /// retrieved while a radio module is executing a tag-protocol 
        /// operation. 
        /// </summary>
        /// <param name="portStatus"></param>
        /// <returns></returns>
        public Result SetAntennaPortStatus(AntennaPortStatus portStatus)
        {
            return (m_Result = AntennaPortSetStatus(0, portStatus));
        }

        /// <summary>
        /// Retrieves the status of the requested logical antenna port for a 
        /// particular radio module.  The antenna-port status cannot be 
        /// retrieved while a radio module is executing a tag-protocol 
        /// operation. 
        /// </summary>
        /// <param name="port">antenna port</param>
        /// <param name="portStatus"></param>
        /// <returns></returns>
        public Result SetAntennaPortStatus(uint port, AntennaPortStatus portStatus)
        {
            m_AntennaList[(int)port].AntennaStatus = portStatus;

            return (m_Result = AntennaPortSetStatus(port, portStatus));
        }

        public Result AntennaPortSetStatus(uint port, AntennaPortStatus portStatus)
        {
            UInt32 registerValue = 0;

            // First, tell the MAC which antenna descriptors we'll be reading and
            // verify that it was a valid selector
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_SEL, port);

            /*MacReadRegister(MACREGISTER.MAC_ERROR, ref registerValue);

            if (registerValue == HOSTIF_ERR_SELECTORBNDS)
            {
                MacClearError();
                return Result.INVALID_PARAMETER;
            }
            */

            // Read the current value of the anteann port configuration
            MacReadRegister(MACREGISTER.HST_ANT_DESC_CFG, ref registerValue);

            registerValue &= 0xfff00000;

            // Now set the enabled bit appropriately
            switch (portStatus.state)
            {
                case AntennaPortState.DISABLED:
                    {
                        //HST_ANT_DESC_CFG_SET_DISABLED//(registerValue);
                        registerValue &= ~((uint)1);
                        break;
                    } // case RFID_ANTENNA_PORT_STATE_DISABLED
                case AntennaPortState.ENABLED:
                    {
                        //HST_ANT_DESC_CFG_SET_ENABLED(registerValue);
                        registerValue |= 1;
                        break;
                    } // case RFID_ANTENNA_PORT_STATE_ENABLED
                default:
                    {
                        return Result.INVALID_PARAMETER;
                        break;
                    } // default
            } // switch (state)

            if (portStatus.easAlarm)
            {
                registerValue |= 1U << 20;
            }
            else
            {
                registerValue &= ~(1U << 20);
            }

            if (portStatus.enableLocalInv)
            {
                //HST_ANT_DESC_CFG_SET_LOCAL_INV(registerValue);
                //HST_ANT_DESC_CFG_SET_INV_ALGO(registerValue, pStatus->inv_algo);
                //HST_ANT_DESC_CFG_SET_STARTQ(registerValue, pStatus->startQ);
                registerValue |= 1 << 1;
                registerValue |= (uint)portStatus.inv_algo << 2;
                registerValue |= (uint)portStatus.startQ << 4;
            }
            else
            {
                //HST_ANT_DESC_CFG_SET_GLOBAL_INV(registerValue);
                registerValue &= ~((uint)1 << 1);
            }

            if (portStatus.enableLocalProfile)
            {
                //HST_ANT_DESC_CFG_SET_LOCAL_PROFILE(registerValue);
                //HST_ANT_DESC_CFG_SET_PROFILE(registerValue, pStatus->profile);
                registerValue |= (uint)1 << 8;
                registerValue |= (uint)portStatus.profile << 9;
            }
            else
            {
                //HST_ANT_DESC_CFG_SET_GLOBAL_PROFILE(registerValue);
                registerValue &= ~((uint)1 << 8);
            }

            if (portStatus.enableLocalFreq)
            {
                //HST_ANT_DESC_CFG_SET_LOCAL_FREQ(registerValue);
                //HST_ANT_DESC_CFG_SET_FREQ_CHN(registerValue, pStatus->freqChn);
                registerValue |= (uint)1 << 13;
                registerValue |= (uint)portStatus.freqChn << 14;
            }
            else
            {
                //HST_ANT_DESC_CFG_SET_GLOBAL_FREQ(registerValue);
                registerValue &= ~((uint)1 << 13);
            }

            // Write back the configuration register
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_CFG, registerValue);

            return Result.OK;
        }

        /// <summary>
        /// Allows an application to specify whether or not a radio module's 
        /// logical antenna port is enabled for subsequent tag operations.  The 
        /// antenna-port state cannot be set while a radio module is executing 
        /// a tag-protocol operation. 
        /// </summary>
        /// <param name="portState">The new state of the logical antenna port. </param>
        /// <returns></returns>
        public Result SetAntennaPortState(AntennaPortState portState)
        {
            if (portState == AntennaPortState.UNKNOWN)
                return Result.INVALID_PARAMETER;

            return (m_Result = AntennaPortSetState(0, portState));
        }

        /// <summary>
        /// Allows an application to specify whether or not a radio module's 
        /// logical antenna port is enabled for subsequent tag operations.  The 
        /// antenna-port state cannot be set while a radio module is executing 
        /// a tag-protocol operation. 
        /// </summary>
        /// <param name="port">antenna port</param>
        /// <param name="portState">The new state of the logical antenna port.</param>
        /// <returns></returns>
        public Result SetAntennaPortState(uint port, AntennaPortState portState)
        {
            if (portState == AntennaPortState.UNKNOWN)
                return Result.INVALID_PARAMETER;

            m_AntennaList[(int)port].State = portState;

            return (m_Result = AntennaPortSetState(port, portState));
        }

        const uint HOSTIF_ERR_SELECTORBNDS = 0x010E;
        public Result AntennaPortSetState(UInt32 antennaPort, AntennaPortState state)
        {
            uint registerValue = 0;

            // First, tell the MAC which antenna descriptors we'll be reading and
            // verify that it was a valid selector
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_SEL, antennaPort);

            /*
            MacReadRegister(MACREGISTER.MAC_ERROR, ref registerValue);

            if (registerValue == HOSTIF_ERR_SELECTORBNDS)
            {
                MacClearError();
                return Result.INVALID_PARAMETER;
            }
            */

            // Read the current value of the anteann port configuration
            MacReadRegister(MACREGISTER.HST_ANT_DESC_CFG, ref registerValue);

            // Now set the enabled bit appropriately
            switch (state)
            {
                case AntennaPortState.DISABLED:
                    {
                        registerValue &= ~((uint)1);
                        break;
                    } // case RFID_ANTENNA_PORT_STATE_DISABLED
                case AntennaPortState.ENABLED:
                    {
                        registerValue |= 1;
                        break;
                    } // case RFID_ANTENNA_PORT_STATE_ENABLED
                default:
                    return Result.INVALID_PARAMETER;
            } // switch (state)

            // Write back the configuration register
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_CFG, registerValue);

            return Result.OK;

        } // Radio::SetAntennaPortState


        /// <summary>
        /// Allows an application to retrieve a single logical antenna port's 
        /// configuration parameters  e.g., dwell time, power level, and 
        /// number of inventory cycles.  Even if the logical antenna port is 
        /// disabled, an application is allowed to retrieve these configuration 
        /// parameters.  Retrieving configuration parameters does not cause a 
        /// logical antenna port to be automatically enabled; the application 
        /// must still enable the logical antenna port via 
        /// RFID_AntennaPortSetState.  The antenna-port configuration 
        /// cannot be retrieved while a radio module is executing a tag-
        /// protocol operation. 
        /// </summary>
        /// <param name="antenna">A structure that upon return will 
        /// contain the antenna-port configuration 
        /// parameters. </param>
        /// <returns>
        /// </returns>
        public Result GetAntennaPortConfiguration(ref AntennaPortConfig antenna)
        {
            AntennaPortGetConfiguration(0, antenna);

            return Result.OK;
        }

        /// <summary>
        /// Allows an application to retrieve a single logical antenna port's 
        /// configuration parameters  e.g., dwell time, power level, and 
        /// number of inventory cycles.  Even if the logical antenna port is 
        /// disabled, an application is allowed to retrieve these configuration 
        /// parameters.  Retrieving configuration parameters does not cause a 
        /// logical antenna port to be automatically enabled; the application 
        /// must still enable the logical antenna port via 
        /// RFID_AntennaPortSetState.  The antenna-port configuration 
        /// cannot be retrieved while a radio module is executing a tag-
        /// protocol operation. 
        /// </summary>
        /// <param name="port">antenna-port</param>
        /// <param name="antenna">A structure that upon return will 
        /// contain the antenna-port configuration 
        /// parameters. </param>
        /// <returns>
        /// </returns>
        public Result GetAntennaPortConfiguration(uint port, ref AntennaPortConfig antenna)
        {
            AntennaPortGetConfiguration(port, antenna);

            return Result.OK;
        }

        Result AntennaPortGetConfiguration(uint port, AntennaPortConfig antenna)
        {
            UInt32 registerValue = 0;

            // First, tell the MAC which antenna descriptors we'll be reading and
            // verify that it was a valid selector
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_SEL, port);

            /*
            MacReadRegister(MACREGISTER.MAC_ERROR, ref registerValue);

            if (registerValue == HOSTIF_ERR_SELECTORBNDS)
            {
                MacClearError();
                return Result.INVALID_PARAMETER;
            }
            */

            // Read the antenna dwell time, RF power, inventory cycle count, and 
            // sense resistor registers
            MacReadRegister(MACREGISTER.HST_ANT_DESC_DWELL, ref antenna.dwellTime);
            MacReadRegister(MACREGISTER.HST_ANT_DESC_RFPOWER, ref antenna.powerLevel);
            MacReadRegister(MACREGISTER.HST_ANT_DESC_INV_CNT, ref antenna.numberInventoryCycles);
            //MacReadRegister(MacRegister.HST_RFTC_ANTSENSRESTHRSH, ref antenna.antennaSenseThreshold);

            return Result.OK;
        }

        /// <summary>
        /// Allows an application to configure several parameters for a single 
        /// logical antenna port e.g.,  dwell time, power level, and number 
        /// of inventory cycles.  Even if the logical antenna port is disabled, 
        /// an application is allowed to set these configuration parameters.  
        /// Setting configuration parameters does not cause a logical antenna 
        /// port to be automatically enabled; the application must still enable 
        /// the logical antenna port via RFID_AntennaPortSetState.  The 
        /// antenna-port configuration cannot be set while a radio module is 
        /// executing a tag-protocol operation. 
        /// NOTE:  Since RFID_AntennaPortSetConfiguration sets all of the 
        /// configuration parameters that are present in the 
        /// RFID_ANTENNA_PORT_CONFIG structure, if an application wishes to 
        /// leave some parameters unchanged, the application should first call 
        /// RFID_AntennaPortGetConfiguration to retrieve the current 
        /// settings, update the values in the structure that are to be 
        /// changed, and then call RFID_AntennaPortSetConfiguration. 
        /// </summary>
        /// <param name="antenna">A structure that contains the 
        /// antenna-port configuration parameters.  This 
        /// parameter must not be NULL.  In version 1.1, 
        /// the physicalRxPort and physicalTxPort 
        /// fields must be the same. </param>
        /// <returns></returns>
        public Result SetAntennaPortConfiguration(AntennaPortConfig antenna)
        {
            if (antenna == null)
                return Result.INVALID_PARAMETER;

            return (m_Result = AntennaPortSetConfiguration(0, antenna));
        }

        /// <summary>
        /// Allows an application to configure several parameters for a single 
        /// logical antenna port e.g.,  dwell time, power level, and number 
        /// of inventory cycles.  Even if the logical antenna port is disabled, 
        /// an application is allowed to set these configuration parameters.  
        /// Setting configuration parameters does not cause a logical antenna 
        /// port to be automatically enabled; the application must still enable 
        /// the logical antenna port via RFID_AntennaPortSetState.  The 
        /// antenna-port configuration cannot be set while a radio module is 
        /// executing a tag-protocol operation. 
        /// NOTE:  Since RFID_AntennaPortSetConfiguration sets all of the 
        /// configuration parameters that are present in the 
        /// RFID_ANTENNA_PORT_CONFIG structure, if an application wishes to 
        /// leave some parameters unchanged, the application should first call 
        /// RFID_AntennaPortGetConfiguration to retrieve the current 
        /// settings, update the values in the structure that are to be 
        /// changed, and then call RFID_AntennaPortSetConfiguration. 
        /// </summary>
        /// <param name="port">antenna-port</param>
        /// <param name="antenna">A structure that contains the 
        /// antenna-port configuration parameters.  This 
        /// parameter must not be NULL.  In version 1.1, 
        /// the physicalRxPort and physicalTxPort 
        /// fields must be the same. </param>
        /// <returns></returns>
        public Result SetAntennaPortConfiguration(uint port, AntennaPortConfig antenna)
        {
            if (antenna == null)
                return Result.INVALID_PARAMETER;

            if (antenna.powerLevel > GetSoftwareMaxPowerLevel(m_save_region_code))
                return (m_Result = Result.INVALID_PARAMETER);

            m_AntennaList[(int)port].AntennaConfig = antenna;

            return (m_Result = AntennaPortSetConfiguration(port, antenna));
        }

        private Result SetAntennaPortConfiguration(uint virtual_port, uint physical_port)
        {
            AntennaPortConfig antenna = new AntennaPortConfig();

            if ((m_Result = AntennaPortGetConfiguration(virtual_port, antenna)) != Result.OK)
                return m_Result;

            return (m_Result = AntennaPortSetConfiguration(virtual_port, antenna));
        }

        Result AntennaPortSetConfiguration(uint port, AntennaPortConfig antenna)
        {
            UInt32 registerValue = 0;

            // First, tell the MAC which antenna descriptors we'll be reading and
            // verify that it was a valid selector
            MacWriteRegister( MACREGISTER.HST_ANT_DESC_SEL, port);

            /*
            MacReadRegister(MACREGISTER.MAC_ERROR, ref registerValue);

            if (registerValue == HOSTIF_ERR_SELECTORBNDS)
            {
                MacClearError();
                return Result.INVALID_PARAMETER;
            }
            */

            // Write the antenna dwell, RF power, inventory cycle count, and sense
            // resistor threshold registers
            MacWriteRegister(MACREGISTER.HST_ANT_DESC_DWELL, antenna.dwellTime);

            MacWriteRegister(MACREGISTER.HST_ANT_DESC_RFPOWER, antenna.powerLevel);

            MacWriteRegister(MACREGISTER.HST_ANT_DESC_INV_CNT, antenna.numberInventoryCycles);

            return Result.OK;
        }

        public uint GetAntennaPort()
        {
            return (uint)m_AntennaList.Count;
		}

    }
}
#endif
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Public.Country.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;

namespace CSLibrary
{
    using static FrequencyBand;
    using static FrequencyBand_CS710S;

    public partial class RFIDReader
    {
        public string GetModelName()
        {
            return m_oem_machine.ToString();
        }

        public string GetModelCountry()
        {
            return DEVICE.GetModelName((int)m_oem_country_code, (int)m_oem_special_country_version);
        }

        public string GetFullModelName()
        {
            return m_oem_machine.ToString() + DEVICE.GetModelName((int)m_oem_country_code, (int)m_oem_special_country_version);
        }

        // Get Active Country Name List
        private string[] GetActiveRegionNameList_CS710S()
        {
            string SubModel = GetModelCountry();

            List<string> ActiveCountryNameList = new List<string>();

            foreach (var i in FrequencyBand_CS710S.frequencySet)
                //if (i.modelCode.Equals(SubModel))
                if (i.modelCode == SubModel)
                    ActiveCountryNameList.Add(i.name);

            if (ActiveCountryNameList.Count == 0)
                return null;

            return ActiveCountryNameList.ToArray();
        }

        public bool IsHopping_CS710S(string CountryName)
        {
            var item = FrequencyBand_CS710S.frequencySet.Find(i => i.name.Equals(CountryName));

            if (item == null)
            {
                return false;
            }

            return (item.hopping == "Hop");
        }

        public bool IsHopping_CS710S(int index)
        {
            return (FrequencyBand_CS710S.frequencySet[index].hopping == "Hop");
        }

        public bool IsFixed_CS710S(string CountryName)
        {
            var item = FrequencyBand_CS710S.frequencySet.Find(i => i.name.Equals(CountryName));

            if (item == null)
            {
                return false;
            }

            return (item.hopping == "Fixed");
        }

        public bool IsFixed_CS710S(int index)
        {
            return (FrequencyBand_CS710S.frequencySet[index].hopping == "Fixed");
        }

        internal Result SetRegion_CS710S(string CountryName, int Channel = 0)                                        // Select Country Frequency with channel if fixed
        {
            var item = FrequencyBand_CS710S.frequencySet.Find(i => i.name.Equals(CountryName));

            if (item == null)
                return Result.FAILURE;

            return SetCountry(item.index, Channel);
        }

        public Result SetCountry_CS710S(int CountryIndex, int Channel = 0)                                        // Select Country Frequency with channel if fixed
        {
            RFIDRegister.CountryEnum.Set((UInt16)CountryIndex);

            if (IsFixed_CS710S(CountryIndex))
                RFIDRegister.FrequencyChannelIndex.Set((byte)(Channel + 1));
            else
                RFIDRegister.FrequencyChannelIndex.Set(0);

            return Result.OK;
        }

        public double[] GetAvailableFrequencyTable_CS710S(string CountryName)									// Get Available frequency table with country code
        {
            var item = FrequencyBand_CS710S.frequencySet.Find(i => i.name.Equals(CountryName));

            if (item == null)
                return null;

            return GetAvailableFrequencyTable_CS710S(item.index);
        }

        internal double[] GetAvailableFrequencyTable_CS710S(int index)									// Get Available frequency table with country code
        {
            double firstChannel = FrequencyBand_CS710S.frequencySet[index].firstChannel;
            double lastChannel = FrequencyBand_CS710S.frequencySet[index].lastChannel + 0.1; // Fix double value compare error (C# bug)
            int totalFrequencyChannel = FrequencyBand_CS710S.frequencySet[index].totalFrequencyChannel;
            double channelSepatration = (double)(FrequencyBand_CS710S.frequencySet[index].channelSepatration) / 1000;
            double[] FreqTable = new double[totalFrequencyChannel];

            if (index == 74)
            {
                FreqTable[0] = 916.8;
                FreqTable[1] = 918;
                FreqTable[2] = 919.2;
                FreqTable[3] = 920.4;
                FreqTable[4] = 920.6;
                FreqTable[5] = 920.8;
            }
            else
            {
                double freq = firstChannel;
                for (int i = 0;
                    freq <= lastChannel && i < totalFrequencyChannel;
                    freq += channelSepatration)
                    FreqTable[i++] = freq;
            }

            return FreqTable;
        }

        public List<double> GetCurrentFrequencyTable_CS710S()														// Get frequency table on current selected region
        {
            //return GetAvailableFrequencyTable_CS710S(1m_save_region);

            return null;
        }

        public string GetCurrentCountry_CS710S()
        {
            return FrequencyBand_CS710S.frequencySet[RFIDRegister.CountryEnum.Get()].name;
        }

        public int GetCurrentCountryIndex_CS710S()
        {
            return RFIDRegister.CountryEnum.Get();
        }

        int GetCurrentFrequencyChannel_CS710S()
        {
            return RFIDRegister.FrequencyChannelIndex.Get();
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Public.FrequencyChannel.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;
using CSLibrary.Structures;

namespace CSLibrary
{
    using static FrequencyBand;

    public partial class RFIDReader
    {
        internal Result InitDefaultChannel_CS710S()
        {
            m_save_countryindex = RFIDRegister.CountryEnum.Get();
            m_save_countryname = FrequencyBand_CS710S.frequencySet[m_save_countryindex].name;
            m_save_freq_channel = RFIDRegister.FrequencyChannelIndex.Get();
            m_save_region_code = RegionCode.UNKNOWN;

            return Result.OK;
        }

        public Result SetDefaultChannel_CS710S()
        {
            return Result.FAILURE;
        }

        internal Result GenCountryList_CS710S()
        {
            return Result.FAILURE;
        }

        internal Result SetDefaultAntennaList_CS710S()
        {
            return Result.FAILURE;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Public.Operation.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using CSLibrary.Constants;
using CSLibrary.Structures;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        TagRangingParms _currentTagRanging;
        internal Result StartOperation_CS710S(Operation opertion)
        {
            CurrentOperation = opertion;

            InventoryDebug.Clear();
            switch (opertion)
            {
                case Operation.Kiloway_RANGING: // Spical Kiloway LED Inventory
                    _deviceHandler.battery.EnableAutoBatteryLevel();

                    _currentTagRanging = Options.TagRanging.Clone();

                    RFIDRegister.AntennaPortConfig.FastIdEnable(Options.TagRanging.fastid);
                    RFIDRegister.AntennaPortConfig.TagFocusEnable(Options.TagRanging.focus);
                    if (m_rdr_opt_parms.TagRanging.multibanks == 0)
                    {
                        if ((Options.TagRanging.flags & SelectFlags.FILTER) == 0X00 && (Options.TagRanging.flags & SelectFlags.SELECT) == 0x00)
                        {
                            //RFIDRegister.AntennaPortConfig.TagGroup(0, 3, 0);
                            RFIDStartCompactInventory();
                        }
                        else
                        {
                            RFIDRegister.AntennaPortConfig.TagGroup(0, 3, 0, 0xffff);
                            RFIDStartSelectCompactInventory();
                        }
                    }
                    else
                    {
                        if ((Options.TagRanging.flags & SelectFlags.FILTER) == 0X00 && (Options.TagRanging.flags & SelectFlags.SELECT) == 0x00)
                        {
                            //RFIDRegister.AntennaPortConfig.TagGroup(0, 3, 0);
                            RFIDStartKilowayMBInventory();
                        }
                        else
                        {
                            RFIDRegister.AntennaPortConfig.TagGroup(0, 3, 0, 0xffff);
                            RFIDStartKilowaySelectMBInventory();
                        }
                    }
                    break;

                case Operation.TAG_EXESEARCHING: // phase out for backward compatible
                case Operation.TAG_EXERANGING: // phase out for backward compatible
                case Operation.TAG_RANGING: // Enable get battery level by interrupt

                    //WriteRegister(0x3036, new byte[] { 0x66 });

                    _deviceHandler.battery.EnableAutoBatteryLevel();

                    _currentTagRanging = Options.TagRanging.Clone();

                    RFIDRegister.AntennaPortConfig.FastIdEnable(Options.TagRanging.fastid);
                    RFIDRegister.AntennaPortConfig.TagFocusEnable(Options.TagRanging.focus);
                    if (m_rdr_opt_parms.TagRanging.multibanks == 0)
                    {
                        if ((Options.TagRanging.flags & SelectFlags.FILTER) == 0X00 && (Options.TagRanging.flags & SelectFlags.SELECT) == 0x00)
                        {
                            //RFIDRegister.AntennaPortConfig.TagGroup(0, 3, 0);
                            RFIDStartCompactInventory();
                        }
                        else
                        {
                            RFIDRegister.AntennaPortConfig.TagGroup(0, 3, 0, 0xffff);
                            RFIDStartSelectCompactInventory();
                        }
                    }
                    else
                    {
                        if ((Options.TagRanging.flags & SelectFlags.FILTER) == 0X00 && (Options.TagRanging.flags & SelectFlags.SELECT) == 0x00)
                        {
                            //RFIDRegister.AntennaPortConfig.TagGroup(0, 3, 0);
                            RFIDStartMBInventory();
                        }
                        else
                        {
                            RFIDRegister.AntennaPortConfig.TagGroup(0, 3, 0, 0xffff);
                            RFIDStartSelectMBInventory();
                        }
                    }
                    break;

                case Operation.TAG_SELECTED:
                    // Set Q = 1
                    SetFixedQParms_CS710S(1, 1);
                    // Set 
                    TagSelected_CS710S();
                    break;

                case Operation.TAG_PREFILTER:
                    TagSelected_CS710S();
                    break;

                case Operation.TAG_READ:
                    ReadThreadProc_CS710S();
                    break;

                case Operation.TAG_READ_PC:
                    TagReadPCThreadProc_CS710S();
                    break;

                case Operation.TAG_READ_EPC:
                    TagReadEPCThreadProc_CS710S();
                    break;

                case Operation.TAG_READ_ACC_PWD:
                    TagReadAccPwdThreadProc_CS710S();
                    break;

                case Operation.TAG_READ_KILL_PWD:
                    TagReadKillPwdThreadProc_CS710S();
                    break;

                case Operation.TAG_READ_TID:
                    TagReadTidThreadProc_CS710S();
                    break;

                case Operation.TAG_READ_USER:
                    TagReadUsrMemThreadProc_CS710S();
                    break;

                case Operation.TAG_WRITE:
                    WriteThreadProc_CS710S();
                    break;

                case Operation.TAG_WRITE_PC:
                    TagWritePCThreadProc_CS710S();
                    break;

                case Operation.TAG_WRITE_EPC:
                    TagWriteEPCThreadProc_CS710S();
                    break;

                case Operation.TAG_WRITE_ACC_PWD:
                    TagWriteAccPwdThreadProc_CS710S();
                    break;

                case Operation.TAG_WRITE_KILL_PWD:
                    TagWriteKillPwdThreadProc_CS710S();
                    break;

                case Operation.TAG_WRITE_USER:
                    TagWriteUsrMemThreadProc_CS710S();
                    break;

                case Operation.TAG_LOCK:
                    TagLockThreadProc_CS710S();
                    break;

                case Operation.TAG_KILL:
                    TagKillThreadProc_CS710S();
                    break;

                case Operation.TAG_AUTHENTICATE:
                    TagAuthenticateThreadProc_CS710S();
                    break;


                //                case Operation.TAG_PREFILTER:
                //                    PreFilter();
                //                    break;







                /*
                                case Operation.TAG_SEARCHING: // Enable get battery level by interrupt
                                    _deviceHandler.battery.EnableAutoBatteryLevel();
                                    TagSearchOneTagThreadProc();
                                    break;

                                case Operation.TAG_PRESEARCHING:
                                    PreTagSearchOneTagThreadProc();
                                    break;

                                case Operation.TAG_EXESEARCHING: // Enable get battery level by interrupt
                                    CurrentOperation = Operation.TAG_SEARCHING;
                                    _deviceHandler.battery.EnableAutoBatteryLevel();
                                    ExeTagSearchOneTagThreadProc();
                                    break;

                case Operation.TAG_SELECTEDDYNQ:
                    TagSelectedDYNQ();
                    break;

                case Operation.TAG_FASTSELECTED:
                    FastTagSelected();
                    break;

                case Operation.TAG_GENERALSELECTED:
                    SetMaskThreadProc();
                    break;



                case Operation.TAG_BLOCK_WRITE:
                    BlockWriteThreadProc();
                    break;

                case Operation.TAG_BLOCK_PERMALOCK:
                    TagBlockLockThreadProc();
                    break;


                case Operation.TAG_AUTHENTICATE:
                    TagAuthenticateThreadProc();
                    break;

                case Operation.TAG_READBUFFER:
                    TagReadBufferThreadProc();
                    break;

                case Operation.TAG_UNTRACEABLE:
                    TagUntraceableThreadProc();
                    break;

                case Operation.FM13DT_READMEMORY:
                    FM13DTReadMemoryThreadProc();
                    break;

                case Operation.FM13DT_WRITEMEMORY:
                    FM13DTWriteMemoryThreadProc();
                    break;

                case Operation.FM13DT_READREGISTER:
                    FM13DTReadRegThreadProc();
                    break;

                case Operation.FM13DT_WRITEREGISTER:
                    FM13DTWriteRegThreadProc();
                    break;

               case Operation.FM13DT_AUTH:
                    FM13DTAuthThreadProc();
                    break;

                case Operation.FM13DT_GETTEMP:
                    FM13DTGetTempThreadProc();
                    break;

                case Operation.FM13DT_STARTLOG:
                    FM13DTStartLogThreadProc();
                    break;

                case Operation.FM13DT_STOPLOG:
                    FM13DTStopLogChkThreadProc();
                    break;

                case Operation.FM13DT_DEEPSLEEP:
                    FM13DTDeepSleepThreadProc();
                    break;

                case Operation.FM13DT_OPMODECHK:
                    FM13DTOpModeChkThreadProc();
                    break;

                case Operation.FM13DT_INITIALREGFILE:
                    FM13DTInitialRegFileThreadProc();
                    break;

                case Operation.FM13DT_LEDCTRL:
                    FM13DTLedCtrlThreadProc();
                    break;

                case Operation.QT_COMMAND:
                    QT_CommandProc();
                    break;
                */

                default:
                    return Result.NOT_SUPPORTED;
            }

            return Result.OK;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Public.Power.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    using static FrequencyBand;
    using Constants;


    public partial class RFIDReader
    {
        private uint m_oem_hipower = 0;

        /// <summary>
        /// Available Maximum Power you can set on specific region
        /// </summary>
        public uint GetActiveMaxPowerLevel_CS710S()
        {
            return 320;
        }

        /// <summary>
        /// Get current power level
        /// </summary>
        public uint SelectedPowerLevel_CS710S
        {
            get
            {
                uint pwrlvl = 0;
                GetPowerLevel_CS710S(ref pwrlvl);
                return pwrlvl;
            }
        }

        /// <summary>
        /// Get Power Level
        /// </summary>
        public Result GetPowerLevel_CS710S(ref uint pwrlvl)
        {
            pwrlvl = RFIDRegister.AntennaPortConfig.GetPower();
            return Result.OK;
        }

        public Result SetPowerLevel_CS710S(uint pwrlevel, uint port = 0)
        {
            if (pwrlevel < 0)
                return Result.INVALID_PARAMETER;

            if (pwrlevel > 330)
                pwrlevel = 330;

            RFIDRegister.AntennaPortConfig.SetPower((UInt16)(pwrlevel * 10), (byte)port);
            return Result.OK;
        }

/*
        public Result SetPowerLevel_CS710S(int pwrlevel, uint port = 0)
        {
            return SetPowerLevel_CS710S((uint)pwrlevel, port);
        }
*/

        public Result SetPowerLevel_CS710S(UInt32 [] pwrlevel)
        {
            Result r;

            for (uint cnt = 0; cnt < pwrlevel.Length; cnt++)
                if ((r = SetPowerLevel_CS710S(pwrlevel[cnt], cnt)) != Result.OK)
                    return r;

            return Result.OK;
        }

        /// <summary>
        /// Available Maximum Power you can set on specific region
        /// </summary>
        private uint GetSoftwareMaxPowerLevel_CS710S(RegionCode region)
        {
            // MAX Power 32dB
            return 300;
        }

        /// <summary>
        /// Set Power Sequencing (only for CS108)
        /// </summary>
        /// <param name="numberofPower"></param>
        /// <param name="power"></param>
        /// <param name="dwell"></param>
        /// <returns></returns>
        public Result SetPowerSequencing_CS710S(int numberofPower, uint[] power = null, uint[] dwell = null, bool CloneAntenna0Setting = true)
        {
            int i;

            if (numberofPower == 0)
            {
                try
                {
                    AntennaPortSetState(0, AntennaPortState.ENABLED);

                    for (i = 1; i < 16; i++)
                        AntennaPortSetState((uint)i, AntennaPortState.DISABLED);
                }
                catch (Exception ex)
                {
                    CSLibrary.Debug.WriteLine("Set Antenna Configuration Fail : " + ex.Message);
                }
                return Result.OK;
            }

            if (power == null || dwell == null || power.Length < numberofPower || dwell.Length < numberofPower)
                return Result.INVALID_PARAMETER;

            for (i = 0; i < numberofPower; i++)
            {
                AntennaPortSetState_CS710S((uint)i, AntennaPortState.ENABLED);
                SetPowerLevel_CS710S(power[i], (uint)i);
                SetInventoryDuration_CS710S(dwell[i], (uint)i);
            }

            if (CloneAntenna0Setting && numberofPower >= 2)
                RFIDRegister.AntennaPortConfig.CloneAntenna0Setting();

            //            for (; i < 16; i++)
            //                AntennaPortSetState_CS710S((uint)i, AntennaPortState.DISABLED);
            AntennaPortSetState_CS710S(i, 15, AntennaPortState.DISABLED);

            return Result.OK;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Public.Profile.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace CSLibrary
{
    using static FrequencyBand;
    using Constants;

    public partial class RFIDReader
    {
        internal uint[] _profileList_CS710S = { 103, 302, 120, 323, 344, 345, 223, 222, 241, 244, 285 };
        internal uint[] _profileList_CS710S_212 = { 103, 302, 120, 104, 323, 4323, 203, 202, 226, 344, 345, 4345, 225, 326, 325, 324, 4324, 342, 4342, 343, 4343, 205, 4382 };

        internal string[] _profileNameList_CS710S = {
            "103: Miller 1 640kHz Tari 6.25us",
            "302: Miller 1 640kHz Tari 7.25us",
            "120: Miller 2 640kHz Tari 6.25us",
            "323: Miller 2 640kHz Tari 7.5us",
            "344: Miller 4 640kHz Tari 7.5us",
            "345: Miller 4 640kHz Tari 7.5us",
            "223: Miller 2 320kHz Tari 15us",
            "222: Miller 2 320kHz Tari 20us",
            "241: Miller 4 320kHz Tari 20us",
            "244: Miller 4 250kHz Tari 20us",
            "285: Miller 8 160kHz Tari 20us"
        };

        internal string[] _profileNameList_CS710S_212 = {
            "103: Miller 1 640kHz Tari 6.25us",
            "302: Miller 1 640kHz Tari 7.25us",
            "120: Miller 2 640kHz Tari 6.25us",
            "104: FM0 320KHz Tari 6.25us",
            "323: Miller 2 640Hz Tari 7.5us",
            "4323: Miller 2 640Hz Tari 7.5us",
            "203: FM0 426KHz Tari 12.5us",
            "202: FM0 426KHz Tari 15us",
            "226: Miller 2 426Hz Tari 12.5us",
            "344: Miller 4 640kHz Tari 7.5us",
            "345: Miller 4 640kHz Tari 7.5us",
            "4345: Miller 4 640Hz Tari 7.5us",
            "225: Miller 2 426Hz Tari 15us",
            "326: Miller 2 320Hz Tari 12.5us",
            "325: Miller 2 320Hz Tari 15us",
            "324: Miller 2 320Hz Tari 20us",
            "4324: Miller 2 320Hz Tari 20us",
            "342: Miller 4 320Hz Tari 20us",
            "4342: Miller 4 320Hz Tari 20us",
            "343: Miller 4 250Hz Tari 20us",
            "4343: Miller 4 250Hz Tari 20us",
            "205: FM0 50KHz Tari 20us",
            "382: Miller 8 160Hz Tari 20us",
            "4382: Miller 8 160Hz Tari 20us"
        };

        bool IsVersionGreater(string v1, string v2)
        {
            var ver1 = new Version(v1);
            var ver2 = new Version(v2);
            return ver1 >= ver2;
        }

        internal uint[] GetActiveLinkProfile_CS710S(RegionCode region)
        {
            if (IsVersionGreater (GetFirmwareVersionString_CS710S(), "2.1.2"))
                return _profileList_CS710S_212;
            else
                return _profileList_CS710S;
        }

        internal string[] GetActiveLinkProfileName_CS710S(RegionCode region)
        {
            if (IsVersionGreater(GetFirmwareVersionString_CS710S(), "2.1.2"))
                return _profileNameList_CS710S_212;
            else
                return _profileNameList_CS710S;
        }

        /// <summary>
        /// Allows the application to set the current link profile for the radio 
        /// module.  A link profile will remain in effect until changed by a 
        /// subsequent call to RFID_RadioSetCurrentLinkProfile.  The 
        /// current link profile cannot be set while a radio module is executing 
        /// a tag-protocol operation. 
        /// </summary>
        /// <param name="profile">
        /// The link profile to make the current link profile.  If this 
        /// parameter does not represent a valid link profile, 
        /// RFID_ERROR_INVALID_PARAMETER is returned. </param>
        /// <returns></returns>
        internal Result SetCurrentLinkProfile_CS710S(uint profile)
        {
            if (new Version(GetFirmwareVersionString()) >= new Version("2.1.2"))
            {
                switch (profile)
                {
                    case 102:
                        profile = 302;
                        break;

                    case 124:
                        profile = 323;
                        break;

                    case 147:
                        profile = 344;
                        break;

                    case 148:
                        profile = 345;
                        break;

                    case 224:
                    case 126:
                        profile = 326;
                        break;

                    case 223:
                    case 125:
                        profile = 325;
                        break;

                    case 123:
                    case 222:
                        profile = 324;
                        break;

                    case 141:
                    case 241:
                        profile = 342;
                        break;

                    case 146:
                    case 244:
                        profile = 343;
                        break;

                    case 185:
                    case 285:
                        profile = 382;
                        break;
                }
            }

            RFIDRegister.AntennaPortConfig.RfMode((UInt16)profile);
            return Result.OK;
        }

        /// <summary>
        ///  Allows the application to retrieve the current link profile for the 
        ///  radio module.  The current link profile cannot be retrieved while a 
        ///  radio module is executing a tag-protocol operation. 
        /// </summary>
        /// <returns></returns>
        internal Result GetCurrentLinkProfile_CS710S(ref uint link)
        {
            return Result.FAILURE;
        }

    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.Public.RSSIFilter.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    using Constants;
    using CSLibrary.Structures;
    using System.Runtime.CompilerServices;

    public partial class RFIDReader
    {
        private RSSIFILTEROPTION _saveOption;

        public Result SetRSSIFilter_CS710S(RSSIFILTERTYPE type)
        {
            if (type == RSSIFILTERTYPE.DISABLE)
            {
                RFIDRegister.RssiFilteringConfig.Set(0x00);
            }
            else
            {
                RFIDRegister.RssiFilteringConfig.Set((byte)_saveOption);
            }

            return Result.OK;
        }

        /// <summary>
        /// RSSI dBm Filter
        /// </summary>
        /// <param name="type"></param>
        /// <param name="option"></param>
        /// <param name="threshold"></param>
        /// <returns></returns>
        internal Result SetRSSIFilter_CS710S(RSSIFILTERTYPE type, RSSIFILTEROPTION option, double threshold)
        {
            if (type == RSSIFILTERTYPE.DISABLE || option == RSSIFILTEROPTION.DISABLE)
            {
                RFIDRegister.RssiFilteringConfig.Set(0x00);
            }
            else
            {
                Int16 Intvalue = (Int16)(threshold * 100f);
                UInt16 UIntvalue = (UInt16)(Intvalue);

                _saveOption = option;
                RFIDRegister.RssiFilteringConfig.Set((byte)option);
                RFIDRegister.RssiThreshold.Set(UIntvalue);
            }
            return Result.OK;
        }

        internal Result SetAuthenticateConfig_CS710S(bool SenRep, bool IncRepLen, uint CSI, uint MessbitLen)
        {
            // Bit 0: SenRep
            // Bit 1: IncRepLen
            // Bit 9:2: CSI
            // Bit 21:10: Length of message in bits

            UInt32 newvalue = 0x00;

            if (SenRep)
                newvalue |= 0x01;

            if (IncRepLen)
                newvalue |= 0x02;

            CSI = CSI & 0xff;
            newvalue |= (CSI << 2);

            MessbitLen = MessbitLen & 0xfff;
            newvalue |= (MessbitLen << 10);

            if (newvalue == RFIDRegister.AuthenticateConfig.Get())
                return Result.OK;

            RFIDRegister.AuthenticateConfig.Set(newvalue);
            return Result.OK;
        }

        internal Result SetAuthenticateMessage(byte [] value)
        {
            if (value.Length > 32)
                return Result.INVALID_PARAMETER;

            byte [] oldValue = RFIDRegister.AuthenticateMessage.Get();
            byte [] newValue;

            if (value.Length == 32)
                newValue = value;
            else
            {
                int i = 0;
                newValue = new byte[32];

                for (; i < value.Length; i++)
                    newValue[i] = value[i];
                for (; i < 32; i++)
                    newValue[i] = 0x00;
            }

            RFIDRegister.AuthenticateMessage.Set(newValue);

            return Result.OK;
        }

        internal Result SetAuthenticateResponseLen(UInt16 value)
        {
            RFIDRegister.AuthenticateResponseLen.Set(value);

            return Result.OK;
        }

    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_API/CS710S/ClassRFID.UnifiedAPI.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Text;

namespace CSLibrary
{
    public partial class RFIDReader
    {
        internal void StopOperation_CS710S(bool value = true)
        {
            RFIDStopOperation();
        }

        internal bool SetDuplicateEliminationRollingWindow_CS710S(uint s)
        {
            if (s > 255)
                return false;

            RFIDRegister.DuplicateEliminationRollingWindow.Set((byte)s);

            return true;
        }

    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Constants/AntennaPort.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace CSLibrary.Constants
{
    /// <summary>
    /// Antenna Port Number
    /// </summary>
    public enum AntennaPort
    {
        /// <summary>
        /// Physical Port 0
        /// </summary>
        PORT_00,
        /// <summary>
        /// Physical Port 1
        /// </summary>
        PORT_01,
        /// <summary>
        /// Physical Port 2
        /// </summary>
        PORT_02,
        /// <summary>
        /// Physical Port 3
        /// </summary>
        PORT_03,
        /// <summary>
        /// Physical Port 4
        /// </summary>
        PORT_04,
        /// <summary>
        /// Physical Port 5
        /// </summary>
        PORT_05,
        /// <summary>
        /// Physical Port 6
        /// </summary>
        PORT_06,
        /// <summary>
        /// Physical Port 7
        /// </summary>
        PORT_07,
        /// <summary>
        /// Physical Port 8
        /// </summary>
        PORT_08,
        /// <summary>
        /// Physical Port 9
        /// </summary>
        PORT_09,
        /// <summary>
        /// Physical Port 10
        /// </summary>
        PORT_10,
        /// <summary>
        /// Physical Port 11
        /// </summary>
        PORT_11,
        /// <summary>
        /// Physical Port 12
        /// </summary>
        PORT_12,
        /// <summary>
        /// Physical Port 13
        /// </summary>
        PORT_13,
        /// <summary>
        /// Physical Port 14
        /// </summary>
        PORT_14,
        /// <summary>
        /// Physical Port 15
        /// </summary>
        PORT_15,
        /// <summary>
        /// Unknown Port Number
        /// </summary>
        UNKNOWN = 0xffff
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Constants/AntennaSequenceMode.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace CSLibrary.Constants
{
    /// <summary>
    /// AntennaSequenceMode
    /// </summary>
    [Flags]
    public enum AntennaSequenceMode
    {
        /// <summary>
        /// Normal mode
        /// </summary>
        NORMAL,
        /// <summary>
        /// Sequence Mode
        /// </summary>
        SEQUENCE,
        /// <summary>
        /// Smart check mode
        /// </summary>
        SMART_CHECK,
        /// <summary>
        /// Combination of Sequence and Smart Check
        /// </summary>
        SEQUENCE_SMART_CHECK,
        /// <summary>
        /// Unknown
        /// </summary>
        UNKNOWN = 0x4
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Constants/CSLibrary.Constants.cs">
using CSLibrary.Tools;
using System;
using System.Collections.Generic;
using System.Text;

namespace CSLibrary.Constants
{
    /// <summary>
    /// reader Callback Type
    /// </summary>
    public enum ReaderCallbackType
    {
        /// <summary>
        /// Reader connect sucess
        /// </summary>
        CONNECT_SUCESS,

        /// <summary>
        /// RFID Command Error
        /// </summary>
        COMMUNICATION_ERROR,
        
        /// <summary>
        /// BT connection disconnected
        /// </summary>
        CONNECTION_LOST,
        
        /// <summary>
        /// Specific-Tag Searching, Only PC , EPC and RSSI will backscatter
        /// </summary>
        UNKNOWN
    }

    /// <summary>
    /// Callback Type
    /// </summary>
    public enum CallbackType
    {
        /// <summary>
        /// Tag Inventory, Only PC and EPC will backscatter
        /// </summary>
        //TAG_INVENTORY,
        /// <summary>
        /// Specific-Tag Searching, Only PC , EPC and RSSI will backscatter
        /// </summary>
        TAG_SEARCHING,
        /// <summary>
        /// Ranging all tag, Only PC , EPC and RSSI will backscatter
        /// </summary>
        TAG_RANGING,
        /// <summary>
        /// Unknown Type will not happen
        /// </summary>
        UNKNOWN
    }
 
    /// <summary>
    /// RFID device status
    /// </summary>
    public enum RFState
    {
        /// <summary>
        /// Idle mode, ready for any operation.
        /// </summary>
        IDLE,
        /// <summary>
        /// Operation is running, please stop it before do any other operation.
        /// </summary>
        BUSY,
        /// <summary>
        /// Operation is stopping, please wait until back to Idle mode.
        /// </summary>
        ABORT,
        /// <summary>
        /// Reader is required to reset.
        /// </summary>
        RESET,
        /// <summary>
        /// buffer full
        /// </summary>
        SHUTDOWN,
        /// <summary>
        /// Reader is in error stage, please restart reader.
        /// </summary>
        ERROR,
        /// <summary>
        /// Anntenna Cycle End Notification.
        /// </summary>
        ANT_CYCLE_END,
        /// <summary>
        /// Channel hit
        /// </summary>
        CH_BUSY,
        /// <summary>
        /// Channel clear
        /// </summary>
        CH_CLEAR,
        /// <summary>
        /// EAS Alert
        /// </summary>
        EAS_ALARM,
        /// <summary>
        /// Receive Buffer Full
        /// </summary>
        BUFFER_FULL,

        /// <summary>
        /// Inventory MAC Error
        /// </summary>
        INVENTORY_MAC_ERROR,

        /// <summary>
        /// Received Carrier Info
        /// </summary>
        CARRIER_INFO,

        /// <summary>
        /// Inventory Cycle Begin
        /// </summary>
        INVENTORY_CYCLE_BEGIN,

        /// <summary>
        /// Reader initialization complete
        /// </summary>
        INITIALIZATION_COMPLETE,

        /// <summary>
        /// Unknown operation
        /// </summary>
        UNKNOWN
    }

    /// <summary>
    /// Error Type
    /// </summary>
    
    public enum ErrorType : int
    {
        /// <summary>
        /// Unknow
        /// </summary>
        UNKNOWN = -1,
        /// <summary>
        /// General Error
        /// </summary>
        COMMON = 0,
        /// <summary>
        /// Inventory or search error
        /// </summary>
        INVENTORY,
        /// <summary>
        /// Write error
        /// </summary>
        WRITE,
        /// <summary>
        /// Read error
        /// </summary>
        READ,
        /// <summary>
        /// Lock error
        /// </summary>
        LOCK,
        /// <summary>
        /// Kill error
        /// Notes : Kill always reports an error even  kill a tag successfully
        /// </summary>
        KILL,
        /// <summary>
        /// Mac Error
        /// </summary>
        MAC,
    }
    /// <summary>
    /// Operation Error Code
    /// </summary>
    
    public enum ErrorCode : int
    {
        /// <summary>
        /// Unknow error
        /// </summary>
        UNKNOWN = -1,
        /// <summary>
        /// MacError Occurs
        /// </summary>
        MAC_ERROR = 0,
        /// <summary>
        /// Max retry is over
        /// </summary>
        MAX_RETRY_OVER,
        /// <summary>
        /// Written data to target tag is invalid
        /// </summary>
        WRITTEN_DATA_INVALID,
        /// <summary>
        /// function return failure
        /// </summary>
        FUNC_RETURN_FAILED,
        /// <summary>
        /// CRC Invalid
        /// </summary>
        CRC_INVALID,
        /// <summary>
        /// fail to parse packet
        /// </summary>
        PARSE_PKT_ERROR,
        /// <summary>
        /// System.Exception catch
        /// </summary>
        SYSTEM_ERROR,
        /// <summary>
        /// Invalid tag found, ie not Gen2 class-1
        /// </summary>
        INVALID_TAG,
        /// <summary>
        /// can't find specific tag
        /// </summary>
        TAG_NOT_FOUND,
    }

    /// <summary>
    /// Extended Kill command for UHF class 1 gen-2 version 1.2
    /// </summary>
    [Flags]
    public enum ExtendedKillCommand
    {
        /// <summary>
        /// Perform normall Tag Kill command
        /// </summary>
        NORMAL = 0,
        /// <summary>
        /// The Tag shall diable block permalocking and unlock any block of User memory that
        /// were previously permalocked. The Tag shall disable support for the BlockPermalock
        /// command. If the Tag did not implement block permalocking prior to recommissioning
        /// then block permalocking shall remains disabled. The lock status of User memory shall
        /// be determined solely by the lock bits.
        /// </summary>
        DISABLE_PERMALOCK = 1,
        /// <summary>
        /// The Tag shall render its User memory inaccessible, causing the entire memory bank to
        /// become unreadable, unwriteable, unselectable(ie. the Tag functions as though its User memory
        /// bank no longer exits).
        /// </summary>
        DISABLE_USER_MEMORY = 2,
        /// <summary>
        /// The Tag shall unlock its EPC, TID, and User memory banks, regardless of whether these
        /// banks were locked or permalocked. Portions of User memory that were block permalock shall
        /// remain block permalocked, and vice versa, unless the DISABLE_PERMALOCK is also asserted, in which
        /// case the Tag shall unlock its permalocked blocks. The Tag shall write-unlock its kill and
        /// access passwords, and shall render the kill and access passwords permanently unreadable regardless
        /// of the values of the Tag's lock bits. If an Interrogator subsequently attempts to read
        /// the Tag's kill or access passwords the Tag shall backscatter an error code
        /// </summary>
        UNLOCK_ALL_BANKS = 4,
        /// <summary>
        /// Unknown command
        /// </summary>
        UNKNOWN = 0xff
    }

    /// <summary>
    /// Frequency Band State
    /// </summary>
    
    public enum BandState
    {
        /// <summary>
        /// Disable
        /// </summary>
        DISABLE = 0,
        /// <summary>
        /// Enable
        /// </summary>
        ENABLE = 1,
        /// <summary>
        /// Unknow
        /// </summary>
        UNKNOWN = 2
    }
    /// <summary>
    /// LBT Config
    /// </summary>
    
    internal enum LBT : uint
    {
        /// <summary>
        /// LBT OFF
        /// </summary>
        OFF = 0,
        /// <summary>
        /// LBT ON
        /// </summary>
        ON = 1,
        /// <summary>
        /// LBT SCAN MODE
        /// </summary>
        SCAN = 3
    }

/*
    /// <summary>
    /// Region Profile
    /// </summary>

    /// <summary>
    /// Region Profile
    /// </summary>
    public enum RegionCode
    {
        /// <summary>
        /// USA
        /// </summary>
        FCC = 1,
        /// <summary>
        /// Europe
        /// </summary>
        ETSI,
        /// <summary>
        /// China all frequency
        /// </summary>
        CN,
        /// <summary>
        /// Taiwan
        /// </summary>
        TW,
        /// <summary>
        /// Korea
        /// </summary>
        KR,
        /// <summary>
        /// Hong Kong
        /// </summary>
        HK,
        /// <summary>
        /// Japan
        /// </summary>
        JP,
        /// <summary>
        /// Australia
        /// </summary>
        AU,
        /// <summary>
        /// Malaysia
        /// </summary>
        MY,
        /// <summary>
        /// Singapore
        /// </summary>
        SG,
        /// <summary>
        /// India
        /// </summary>
        IN,
        /// <summary>
        /// G800 same as India
        /// </summary>
        G800,
        /// <summary>
        /// South Africa
        /// </summary>
        ZA,
        //New added
        /// <summary>
        /// Brazil
        /// </summary>
        BR1,
        /// <summary>
        /// Brazil
        /// </summary>
        BR2,
        /// <summary>
        /// Brazil
        /// </summary>
        BR3,
        /// <summary>
        /// Brazil
        /// </summary>
        BR4,
        /// <summary>
        /// Brazil
        /// </summary>
        BR5,
        /// <summary>
        /// Indonesia 
        /// </summary>
        ID,
        /// <summary>
        /// Thailand
        /// </summary>
        TH,
        /// <summary>
        /// Israel
        /// </summary>
        JE,
        /// <summary>
        /// Philippine
        /// </summary>
        PH,
        /// <summary>
        /// ETSI Upper Band
        /// </summary>
        ETSIUPPERBAND,
        /// <summary>
        /// New Zealand
        /// </summary>
        NZ,
        /// <summary>
        /// UH1
        /// </summary>
        UH1,
        /// <summary>
        /// UH2
        /// </summary>
        UH2,
        /// <summary>
        /// LH
        /// </summary>
        LH,
        /// <summary>
        /// LH
        /// </summary>
        LH1,
        /// <summary>
        /// LH
        /// </summary>
        LH2,
        /// <summary>
        /// Venezuela
        /// </summary>
        VE,
        /// <summary>
        /// Argentina
        /// </summary>
        AR,
        /// Chile
        CL,
        /// <summary>
        /// Colombia
        /// </summary>
        CO,
        /// <summary>
        /// Costa Rica??? ????????
        /// </summary>
        CR,
        /// <summary>
        /// Dominican Republic
        /// </summary>
        DO,
        /// <summary>
        /// Panama
        /// </summary>
        PA,
        /// <summary>
        /// Peru
        /// </summary>
        PE,
        /// <summary>
        /// Uruguay
        /// </summary>
        UY,
        /// <summary>
        /// Bangladesh
        /// </summary>
        BA,
        /// <summary>
        /// Vietnam
        /// </summary>
        VI,
        /// <summary>
        /// Unknow Country
        /// </summary>
        UNKNOWN = 0,
        /// <summary>
        /// Current Country
        /// </summary>
        CURRENT = -1
    }
*/

	//AC	    Tag mask designer identifier    tag model number    Serial number
	//8 bits	12 bits	                        12 bits	            16 bits
	//E2        001                             093
	/*public enum ISO
    {*/
	//INCITS 256	64	000x xxxx	 	 
	//INCITS 256, 18000-7	32	000x xxxx	000x xxxx	 
	//ISO 18000-7	48	000x xxxx	xxxx xxxx	xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx 
	/*ISO18K7 = 0x11,
	ISO18K2 = 0xE0,
	ISO18K3 = 0xE2,
	ISO18K3 = 0xE2,

ISO 18000-7 (Savi)	48	0001 0001	0000 0100	xxxx xxxx xxxx xxxx xxxx xxxx  xxxx xxxx 
ISO 18000-2, Type A (7816-6)	56 + AC	1110 0000	xxxx xxxx    (per 7816-6)	xxxx xxxx xxxx xxxx xxxx xxxx  xxxx xxxx xxxx xxxx xxxx xxxx 
ISO 18000-3m3 (non-EPC)	16 - 496	1110 0000	xxxx xxxx xxxx - xxxx xxxx xxxx	Maximum 496 bits
ISO 18000-3m3 (EPC)	16 - 496 	1110 0010	xxxx xxxx xxxx -xxxx xxxx xxxx	Maximum 496 bits
ISO 18000-4 (Intermec C 7816-6)	56	1110 0000	xxxx xxxx    (per 7816-6) 	xxxx xxxx xxxx xxxx xxxx xxxx  xxxx xxxx xxxx xxxx xxxx xxxx  
ISO 18000-4 (Intermec C 256)	56	0001 0010	xxxx xxxx  (Unassigned)	xxxx xxxx xxxx xxxx xxxx xxxx  xxxx xxxx xxxx xxxx xxxx xxxx 
ISO 18000-4 (Siemens/Nedap 7816-6) (see 18000-4 for details)	32	N/A	xxxx xxxx    (per 7816-6)	xxxx xxxx xxxx xxxx xxxx xxxx
xxxx xxxx xxxx xxxx xxxx xxxx
ISO 18000-6A	64	1110 0010	xxxx xxxx xxxx - xxxx xxxx xxxx	xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
ISO 18000-6B	64	0001 0011	xxxx xxxx xxxx - xxxx xxxx xxxx	xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
ISO 18000-6C (7816)	64	1110 0000	(per 7816-6)	xxxx xxxx xxxx xxxx xxxx xxxx  xxxx xxxx xxxx xxxx xxxx xxxx  
ISO 18000-6C (EPC)	16 - 496 	1110 0010	xxxx xxxx xxxx - xxxx xxxx xxxx	TBD - 18000-6C, Table 1 states a maximum of 496 bits
ISO/IEC 24730	48	0000 0000	xxxx - xxxx	xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
ISO/IEC 24730 (WhereNet)	48	0000 0000	0000 0000	xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
}*/
	/// <summary>
	/// Allocation Class Identifier
	/// </summary>
	public enum ACID
    {
        /// <summary>
        /// ISO/IEC 7816-6 registration authority
        /// </summary>
        APACS       = 0xE0,
        /// <summary>
        /// ISO/TS 14816 registration authority
        /// </summary>
        NEN         = 0xE1,
        /// <summary>
        /// EPCglobal
        /// </summary>
        GS1         = 0xE2,
        /// <summary>
        /// ISO/IEC 7816-6 registration authority(includes memory size and XTID Header)
        /// </summary>
        APACSX      = 0xE3,
        /// <summary>
        /// Unknown authority
        /// </summary>
        UNKNOWN     = 0xFF
    }
    /// <summary>
    /// EPCglobal Tag Mask Designer Identifier
    /// </summary>
    public enum EpcMDID
    {
        /// <summary>
        /// Impinj
        /// </summary>
        Impinj = 0x1,
        /// <summary>
        /// Texas Instruments
        /// </summary>
        Texas_Instruments = 0x2,
        /// <summary>
        /// Alien Technology
        /// </summary>
        Alien_Technology = 0x3,
        /// <summary>
        /// Intelleflex
        /// </summary>
        Intelleflex = 0x4,
        /// <summary>
        /// Atmel
        /// </summary>
        Atmel = 0x5,
        /// <summary>
        /// NXP
        /// </summary>
        NXP = 0x6,
        /// <summary>
        /// ST Microelectronics
        /// </summary>
        ST_Microelectronics = 0x7,
        /// <summary>
        /// EP Microelectronics
        /// </summary>
        EP_Microelectronics = 0x8,
        /// <summary>
        /// Motorola
        /// </summary>
        Motorola = 0x9,
        /// <summary>
        /// Sentech Snd Bhd
        /// </summary>
        Sentech_Snd_Bhd = 0xA,
        /// <summary>
        /// EM Microelectronics
        /// </summary>
        EM_Microelectronics = 0xB,
        /// <summary>
        /// Renesas Technology Corp
        /// </summary>
        Renesas_Technology_Corp = 0xC,
        /// <summary>
        /// Mstar
        /// </summary>
        Mstar = 0xD,
        /// <summary>
        /// Tyco International
        /// </summary>
        Tyco_International = 0xE,
        /// <summary>
        /// Quanray Electronics
        /// </summary>
        Quanray_Electronics = 0xF,
        /// <summary>
        /// Fujitsu
        /// </summary>
        Fujitsu = 0x10,
        /// <summary>
        /// LSIS
        /// </summary>
        LSIS = 0x11,
        /// <summary>
        /// CAEN RFID srl
        /// </summary>
        CAEN_RFID_srl = 0x12,
        /// <summary>
        /// CAEN Productivity Engineering Gesellschaft fuer IC Design mbH
        /// </summary>
        CAEN_Productivity_Engineering_Gesellschaft_fuer_IC_Design_mbH = 0x13,
        /// <summary>
        /// Impinj with xTid
        /// </summary>
        Impinj_with_xTid = 0x801,
        /// <summary>
        /// Texas Instruments with xTid
        /// </summary>
        Texas_Instruments_with_xTid = 0x802,
        /// <summary>
        /// Alien Technology with xTid
        /// </summary>
        Alien_Technology_with_xTid = 0x803,
        /// <summary>
        /// Intelleflex with xTid
        /// </summary>
        Intelleflex_with_xTid = 0x804,
        /// <summary>
        /// Atmel with xTid
        /// </summary>
        Atmel_with_xTid = 0x805,
        /// <summary>
        /// NXP with xTid
        /// </summary>
        NXP_with_xTid = 0x806,
        /// <summary>
        /// ST Microelectronics with xTid
        /// </summary>
        ST_Microelectronics_with_xTid = 0x807,
        /// <summary>
        /// EP Microelectronics with xTid
        /// </summary>
        EP_Microelectronics_with_xTid = 0x808,
        /// <summary>
        /// Motorola with xTid
        /// </summary>
        Motorola_with_xTid = 0x809,
        /// <summary>
        /// Sentech Snd Bhd with xTid
        /// </summary>
        Sentech_Snd_Bhd_with_xTid = 0x80A,
        /// <summary>
        /// EM Microelectronics with xTid
        /// </summary>
        EM_Microelectronics_with_xTid = 0x80B,
        /// <summary>
        /// Renesas Technology Corp with xTid
        /// </summary>
        Renesas_Technology_Corp_with_xTid = 0x80C,
        /// <summary>
        /// Mstar with xTid
        /// </summary>
        Mstar_with_xTid = 0x80D,
        /// <summary>
        /// Tyco International with xTid
        /// </summary>
        Tyco_International_with_xTid = 0x80E,
        /// <summary>
        /// Quanray Electronics with xTid
        /// </summary>
        Quanray_Electronics_with_xTid = 0x80F,
        /// <summary>
        /// Fujitsu with xTid
        /// </summary>
        Fujitsu_with_xTid = 0x810,
        /// <summary>
        /// LSIS with xTid
        /// </summary>
        LSIS_with_xTid = 0x811,
        /// <summary>
        /// CAEN RFID srl with xTid
        /// </summary>
        CAEN_RFID_srl_with_xTid = 0x812,
        /// <summary>
        /// CAEN Productivity Engineering Gesellschaft fuer IC Design mbH with xTid
        /// </summary>
        CAEN_Productivity_Engineering_Gesellschaft_fuer_IC_Design_mbH_with_xTid = 0x813,
        /// <summary>
        /// UNKNOWN
        /// </summary>
        UNKNOWN = 0xFFFF
    }
    /// <summary>
    /// ISO/IEC 7816-6 registration authority
    /// </summary>
    public enum IsoMDID
    {
        /// <summary>
        /// Motorola
        /// </summary>
        Motorola = 0x1,
        /// <summary>
        /// STMicroelectronics SA
        /// </summary>
        STM,
        /// <summary>
        /// Hitachi, Ltd 
        /// </summary>
        Hitachi,
        /// <summary>
        /// Philips Semiconductors 
        /// </summary>
        Philips,
        /// <summary>
        /// Infineon Technologies AG 
        /// </summary>
        Infineon,
        /// <summary>
        /// Cylink
        /// </summary>
        Cylink,
        /// <summary>
        /// Texas Instrument 
        /// </summary>
        Texas,
        /// <summary>
        /// Fujitsu Limited 
        /// </summary>
        Fujitsu,
        /// <summary>
        /// Matsushita Electronics Corporation, Semiconductor Co.
        /// </summary>
        Matsushita,
        /// <summary>
        /// NEC 
        /// </summary>
        NEC,
        /// <summary>
        /// Oki Electric Industry Co. Ltd 
        /// </summary>
        Oki,
        /// <summary>
        /// Toshiba Corp. 
        /// </summary>
        Toshiba,
        /// <summary>
        /// Mitsubishi Electric Corp. 
        /// </summary>
        Mitsubishi,
        /// <summary>
        /// Samsung Electronics Co. Ltd 
        /// </summary>
        Samsung,
        /// <summary>
        /// Hynix
        /// </summary>
        Hynix,
        /// <summary>
        /// LG-Semiconductors Co. Ltd 
        /// </summary>
        LG,
        /// <summary>
        /// Emosyn-EM Microelectronics 
        /// </summary>
        EmosynEM,
        /// <summary>
        /// INSIDE Technology 
        /// </summary>
        INSIDE,
        /// <summary>
        /// ORGA Kartensysteme GmbH 
        /// </summary>
        ORGA,
        /// <summary>
        /// SHARP Corporation 
        /// </summary>
        SHARP,
        /// <summary>
        /// ATMEL 
        /// </summary>
        ATMEL,
        /// <summary>
        /// EM Microelectronic-Marin SA 
        /// </summary>
        EM,
        /// <summary>
        /// KSW Microtec GmbH 
        /// </summary>
        KSW,
        /// <summary>
        /// ZMD AG 
        /// </summary>
        ZMD,
        /// <summary>
        /// XICOR, Inc. 
        /// </summary>
        XICOR,
        /// <summary>
        /// Sony Corporation 
        /// </summary>
        Sony,
        /// <summary>
        /// Malaysia Microelectronic Solutions Sdn. Bhd 
        /// </summary>
        Malaysia,
        /// <summary>
        /// Emosyn 
        /// </summary>
        Emosyn,
        /// <summary>
        /// Shanghai Fudan Microelectronics Co. Ltd. 
        /// </summary>
        Fudan,
        /// <summary>
        /// Magellan Technology Pty Limited 
        /// </summary>
        Magellan,
        /// <summary>
        /// Melexis NV BO 
        /// </summary>
        Melexis,
        /// <summary>
        /// Renesas Technology Corp. 
        /// </summary>
        Renesas,
        /// <summary>
        /// TAGSYS 
        /// </summary>
        TAGSYS,
        /// <summary>
        /// Transcore
        /// </summary>
        Transcore,
        /// <summary>
        /// Shanghai Belling Corp., Ltd. 
        /// </summary>
        Belling,
        /// <summary>
        /// Masktech Germany Gmbh 
        /// </summary>
        Masktech,
        /// <summary>
        /// Innovision Research and Techology Plc 
        /// </summary>
        Innovision,
        /// <summary>
        /// Hitachi ULSI Systems Co., Ltd. 
        /// </summary>
        HitachiULSI,
        /// <summary>
        /// Cypak AB 
        /// </summary>
        Cypak,
        /// <summary>
        /// Ricoh
        /// </summary>
        Ricoh,
        /// <summary>
        /// ASK 
        /// </summary>
        ASK,
        /// <summary>
        /// Unicore Microsystems, LLC 
        /// </summary>
        Unicore,
        /// <summary>
        /// Dallas Semiconductor/Maxim 
        /// </summary>
        Dallas,
        /// <summary>
        /// Impinj, Inc. 
        /// </summary>
        Impinj,
        /// <summary>
        /// RightPlug Alliance 
        /// </summary>
        Alliance,
        /// <summary>
        /// Broadcom Corporation 
        /// </summary>
        Broadcom,
        /// <summary>
        /// MStar Semiconductor, Inc 
        /// </summary>
        MStar,
        /// <summary>
        /// eeDar Technology Inc. 
        /// </summary>
        eeDar,
        /// <summary>
        /// RFIDsec
        /// </summary>
        RFIDsec,
        /// <summary>
        /// Schweizer Electronic AG 
        /// </summary>
        Schweizer,
        /// <summary>
        /// AMIC Technology Corp 
        /// </summary>
        AMIC,
        /// <summary>
        /// Unknown company
        /// </summary>
        UNKNOWN = 0xFFFF
    }

    /// <summary>
    /// RFID Operation Mode
    /// </summary>
    public enum Operation : int
    {
        /// <summary>
        /// Unknow operation
        /// </summary>
        UNKNOWN = -1,
        /// <summary>
        /// perform 18K6C tag read to target tag
        /// </summary>
        TAG_READ,
        /// <summary>
        /// perform 18K6C tag write to target tag
        /// </summary>
        TAG_WRITE,
        /// <summary>
        /// perform 18K6C BlockPermalock to target tag
        /// </summary>
        TAG_BLOCK_PERMALOCK,
        /// <summary>
        /// perform 18K6C tag lock to target tag
        /// </summary>
        TAG_LOCK,
        /// <summary>
        /// perform 18K6C tag kill to target tag
        /// </summary>
        TAG_KILL,
        /*/// <summary>
        /// perform 18K6C block write to target tag
        /// </summary>
        TAG_BLOCK_WRITE,*/
        /// <summary>
        /// perform custom read on kill password
        /// </summary>
        TAG_READ_KILL_PWD,
        /// <summary>
        /// perform custom read on access password
        /// </summary>
        TAG_READ_ACC_PWD,
        /// <summary>
        /// perform custom read on pc
        /// </summary>
        TAG_READ_PC,
        /// <summary>
        /// perform custom read on epc
        /// </summary>
        TAG_READ_EPC,
        /// <summary>
        /// perform custom read on tid
        /// </summary>
        TAG_READ_TID,
        /// <summary>
        /// perform custom read on user bank
        /// </summary>
        TAG_READ_USER,
        /// <summary>
        /// perform custom write on kill password
        /// </summary>
        TAG_WRITE_KILL_PWD,
        /// <summary>
        /// perform custom write on access password
        /// </summary>
        TAG_WRITE_ACC_PWD,
        /// <summary>
        /// perform custom write on pc
        /// </summary>
        TAG_WRITE_PC,
        /// <summary>
        /// perform custom write on epc
        /// </summary>
        TAG_WRITE_EPC,
        /// <summary>
        /// perform custom write on user bank 
        /// </summary>
        TAG_WRITE_USER,
        /// <summary>
        /// perform 18K6C block write to target tag
        /// </summary>
        TAG_BLOCK_WRITE,
        /// <summary>
        /// perform custom ranging on any tags
        /// </summary>
        TAG_RANGING,
        /// <summary>
        /// perform custom ranging on any tags
        /// </summary>
        TAG_PRERANGING,
        /// <summary>
        /// perform custom ranging on any tags
        /// </summary>
        TAG_EXERANGING,
        /// <summary>
        /// perform custom search specific tags
        /// </summary>
        TAG_SEARCHING,
        /// <summary>
        /// perform custom search specific tags
        /// </summary>
        TAG_PRESEARCHING,
        /// <summary>
        /// perform custom search specific tags
        /// </summary>
        TAG_EXESEARCHING,
        /*
        /// <summary>
        /// perform custom lock access password
        /// </summary>
        TAG_LOCK_ACC_PWD,
        /// <summary>
        /// perform custom lock kill password
        /// </summary>
        TAG_LOCK_KILL_PWD,
        /// <summary>
        /// perform custom lock EPC bank
        /// </summary>
        TAG_LOCK_EPC,
        /// <summary>
        /// perform custom lock TID bank
        /// </summary>
        TAG_LOCK_TID,
        /// <summary>
        /// perform custom lock USER bank
        /// </summary>
        TAG_LOCK_USER,*/
        /// <summary>
        /// Select a tag for operation
        /// </summary>
        TAG_SELECTED,
        /// <summary>
        /// Select a tag using dynamic Q for operation
        /// </summary>
        TAG_SELECTEDDYNQ,
        /// <summary>
        /// perform read protect custom command on specific tags
        /// </summary>
        TAG_READ_PROTECT,
        /// <summary>
        /// perform reset read protect custom search on specific tags
        /// </summary>
        TAG_RESET_READ_PROTECT,
        /// <summary>
        /// configure EAS
        /// </summary>
        EAS_CONFIG,
        /// <summary>
        /// EAS Alarm
        /// </summary>
        EAS_ALARM,
        /// <summary>
        /// Set password
        /// </summary>
        CL_SET_PASSWORD,
        /// <summary>
        /// Set log mode
        /// </summary>
        CL_SET_LOG_MODE,
        /// <summary>
        /// Set log limits
        /// </summary>
        CL_SET_LOG_LIMITS,
        /// <summary>
        /// Get measurement setup
        /// </summary>
        CL_GET_MEASUREMENT_SETUP,
        /// <summary>
        /// Set DFE parameter
        /// </summary>
        CL_SET_SFE_PARA,
        /// <summary>
        /// Set cal data
        /// </summary>
        CL_SET_CAL_DATA,
        /// <summary>
        /// End log
        /// </summary>
        CL_END_LOG,
        /// <summary>
        /// Start log
        /// </summary>
        CL_START_LOG,
        /// <summary>
        /// get log state
        /// </summary>
        CL_GET_LOG_STATE,
        /// <summary>
        /// Get cal data
        /// </summary>
        CL_GET_CAL_DATA,
        /// <summary>
        /// Get battery level
        /// </summary>
        CL_GET_BAT_LV,
        /// <summary>
        /// Set shelf life
        /// </summary>
        CL_SET_SHELF_LIFE,
        /// <summary>
        /// Init
        /// </summary>
        CL_INIT,
        /// <summary>
        /// Get sensor value
        /// </summary>
        CL_GET_SENSOR_VALUE,
        /// <summary>
        /// Open area
        /// </summary>
        CL_OPEN_AREA,
        /// <summary>
        /// Set access FIFO
        /// </summary>
        CL_ACCESS_FIFO,
        /// <summary>
        /// G2X ReadProtect
        /// </summary>
        G2_READ_PROTECT,
        /// <summary>
        /// G2X Reset ReadProtect
        /// </summary>
        G2_RESET_READ_PROTECT,
        /// <summary>
        /// G2X ChangeEAS
        /// </summary>
        G2_CHANGE_EAS,
        /// <summary>
        /// G2X EAS Alarm
        /// </summary>
        G2_EAS_ALARM,
        /// <summary>
        /// G2iL Change Config
        /// </summary>
        G2_CHANGE_CONFIG,
        /// <summary>
        /// QT Command
        /// </summary>
        QT_COMMAND,
        /// <summary>
        /// Custom EM Get Sensor Data
        /// </summary>
        EM4324_GetUid,
        /// <summary>
        /// Custom EM Get Sensor Data
        /// </summary>
        EM4325_GetUid,
        /// <summary>
        /// Custom EM Get Sensor Data
        /// </summary>
        EM_GetSensorData,
        /// <summary>
        /// Custom EM Get Sensor Data
        /// </summary>
        EM_ResetAlarms,
        /// <summary>
        /// SPI Command
        /// </summary>
        EM_SPI,
        /// <summary>
        /// SPI Command
        /// </summary>
        EM_SPIRequestStatus,
        /// <summary>
        /// EM4325 Command
        /// </summary>
        EM_SPIBoot,
        /// <summary>
        /// EM4325 Command
        /// </summary>
        EM_SPITransponder,
        /// <summary>
        /// EM4325 Command
        /// </summary>
        EM_SPIGetSensorData,
        /// <summary>
        /// EM4325 Command
        /// </summary>
        EM_SPISetFlags,
        /// <summary>
        /// EM4325 Command
        /// </summary>
        EM_SPIReadWord,
        /// <summary>
        /// EM4325 Command
        /// </summary>
        EM_SPIWriteWord,
        /// <summary>
        /// EM4325 Command
        /// </summary>
        EM_SPIReadPage,
        /// <summary>
        /// EM4325 Command
        /// </summary>
        EM_SPIWritePage,
        /// <summary>
        /// EM4325 Command
        /// </summary>
        EM_SPISetClock,
        /// <summary>
        /// EM4325 Command
        /// </summary>
        EM_SPIAlarm,
        /// <summary>
        /// EM4325 Command
        /// </summary>
        EM_SPIReadRegisterFileWord,
        /// <summary>
        /// EM4325 Command
        /// </summary>
        EM_SPIWriteRegisterFileWord,
        /// <summary>
        /// EM4325 Command
        /// </summary>
        EM_SPIReqRN,

        TAG_GENERALSELECTED,

        TAG_FASTSELECTED,

        TAG_PREFILTER,

        TAG_POSTFILTER,

        TAG_AUTHENTICATE,

        TAG_READBUFFER,

        TAG_UNTRACEABLE,

        // for FM13DT160 
        FM13DT_READMEMORY,
        FM13DT_WRITEMEMORY,
        FM13DT_AUTH,
        FM13DT_GETTEMP,
        FM13DT_STARTLOG,
        FM13DT_STOPLOG,
        FM13DT_WRITEREGISTER,
        FM13DT_READREGISTER,
        FM13DT_DEEPSLEEP,
        FM13DT_OPMODECHK,
        FM13DT_INITIALREGFILE,
        FM13DT_LEDCTRL,

        /// <summary>
        /// for Kiloway Tag
        /// </summary>
        Kiloway_RANGING,
    }
    /// <summary>
    /// Memory bank
    /// </summary>
    public enum Bank
    {
        /// <summary>
        /// Access password
        /// </summary>
        ACC_PWD,
        /// <summary>
        /// Kill password
        /// </summary>
        KILL_PWD,
        /// <summary>
        /// Protocol Control
        /// </summary>
        PC,
        /// <summary>
        /// Electronic Product Code
        /// </summary>
        EPC,
        /// <summary>
        /// Transponder ID
        /// </summary>
        TID,
        /// <summary>
        /// User memory
        /// </summary>
        USER,
        /// <summary>
        /// Any bank memory
        /// </summary>
        SPECIFIC,
        /// <summary>
        /// Untraceable
        /// </summary>
        UNTRACEABLE,
        /// <summary>
        /// Unknown bank
        /// </summary>
        UNKNOWN
    }

    /// <summary>
    /// The values that can be found in the command field for tag access packets
    /// </summary>
    public enum TagAccess : byte
    {
        /// <summary>
        /// ISO 18000-6C Read
        /// </summary>
        READ = 0xC2,
        /// <summary>
        /// ISO 18000-6C Write
        /// </summary>
        WRITE = 0xC3,
        /// <summary>
        /// ISO 18000-6C Kill
        /// </summary>
        KILL = 0xC4,
        /// <summary>
        /// ISO 18000-6C Lock
        /// </summary>
        LOCK = 0xC5,
        /// <summary>
        /// ISO 18000-6C Erase
        /// </summary>
        ERASE = 0xC6,
        /// <summary>
        /// UCODE DNA Authenticate
        /// </summary>
        AUTHENTICATE = 0x01,
        /// <summary>
        /// UCODE DNA Untracable
        /// </summary>
        UNTRACEABLE = 0x02,
        /// <summary>
        /// Unknown
        /// </summary>
        UNKNOWN = 0xff
    }

    public enum FM13DTAccess
    {
        READMEMORY,
        WRITEMEMORY,
        READREGISTER,
        WRITEREGISTER,
        AUTH,
        GETTEMP,
        STARTLOG,
        STOPLOG,
        DEEPSLEEP,
        OPMODECHK,
        INITIALREGFILE,
        LEDCTRL,
        UNKNOWN
    }

    /// <summary>
    /// Machine Type (phase out), please use CSLibrary.DEVICEINFORMATION.MODEL
    /// </summary>
    /// 
/*
    public enum Machine
    {
        CS101 = 0,
        CS108,
        CS203,
        CS333,
        CS468,
        CS206_OLD,
        CS468INT,
        CS463,
        CS469,
        CS208,
        CS209,
        CS103,
        CS206,
        CS468X,
        CS203X,
        CS468XJ,
        CS710S,
        MACHINE_CODE_END,
        UNKNOWN = 0xff
    }
*/

    public enum ChipSetID
    {
        R1000 = 0,
        R2000 = 1,
        E710 = 2,
        UNKNOWN = 0xff
    }

    public enum ApiMode
    {
        HIGHLEVEL,
        LOWLEVEL,
        UNKNOWN
    }

}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Constants/FreqAgile.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace CSLibrary.Constants
{
    /// <summary>
    /// Freq Agile Mode
    /// </summary>
    public enum FreqAgileMode
    {
        /// <summary>
        /// Disable Freq Agile
        /// </summary>
        DISABLE = 0,
        /// <summary>
        /// Enable Freq Agile
        /// </summary>
        ENABLE = 1,
    };

}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Constants/SelectFlags.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace CSLibrary.Constants
{
    /// <summary>
    /// Select Flags
    /// </summary>
    [Flags]
    public enum SelectFlags
    {
        /// <summary>
        /// Normal Inventory
        /// </summary>
        //NORMAL = 0x0000000,
        ZERO = 0x0000000,
        /// <summary>
        /// Use Select Criteria
        /// </summary>
        SELECT = 0x00000001,
        /// <summary>
        /// Use Post-Match Criteria
        /// </summary>
        POSTMATCH = 0x00000002,
        /// <summary>
        /// Using Post-Match Criterion
        /// </summary>
        POST_MATCH = 0x2,
        /// <summary>
        /// Using Post-Match Criterion
        /// </summary>
        FILTER = 0x3,
        /// <summary>
        /// Disable Inventory
        /// </summary>
        DISABLE_INVENTORY = 0x00000004,
        /// <summary>
        /// Read 1 bank after Inventory
        /// </summary>
        READ1BANK = 0x00000008,
        /// <summary>
        /// Read 2 bank after Inventory
        /// </summary>
        READ2BANK = 0x00000010,
        /// <summary>
        /// Unknown
        /// </summary>
        UNKNOWN = 0xffff,
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Events/CSLibrary.Events.cs">
using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.CompilerServices;
using System.Threading;

namespace CSLibrary.Events
{
    using CSLibrary.Structures;
    using CSLibrary.Constants;

    /// <summary>
    /// Reader status callback event argument
    /// </summary>
    public class OnReaderStateChangedEventArgs : EventArgs
    {
        /// <summary>
        /// Callback Tag Information
        /// </summary>
        public readonly object info;
        /// <summary>
        /// Async callback data type
        /// </summary>
        public readonly ReaderCallbackType type = ReaderCallbackType.UNKNOWN;
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="info">Tag Information</param>
        /// <param name="type">Callback Type</param>
        public OnReaderStateChangedEventArgs(object info, ReaderCallbackType type)
        {
            this.info = info;
            this.type = type;
        }
    }

    /// <summary>
    /// Inventory or tag search callback event argument
    /// </summary>
    public class OnAsyncCallbackEventArgs : EventArgs
    {
        /// <summary>
        /// Callback Tag Information
        /// </summary>
        public readonly TagCallbackInfo info = new TagCallbackInfo();
        /// <summary>
        /// Async callback data type
        /// </summary>
        public readonly CallbackType type = CallbackType.UNKNOWN;
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="info">Tag Information</param>
        /// <param name="type">Callback Type</param>
        public OnAsyncCallbackEventArgs(TagCallbackInfo info, CallbackType type)
        {
            this.info = info;
            this.type = type;
        }
    }
    /// <summary>
    /// Tag Access Completed Argument
    /// </summary>
    public class OnAccessCompletedEventArgs : EventArgs
    {
        /// <summary>
        /// Access Result
        /// </summary>     
        public readonly bool success = false;
        /// <summary>
        /// Access bank
        /// </summary>
        public readonly Bank bank = Bank.UNKNOWN;
        /// <summary>
        /// Access Type
        /// </summary>
        public readonly TagAccess access = TagAccess.UNKNOWN;
        /// <summary>
        /// Access Data only use for Tag Read operation
        /// </summary>
        public readonly IBANK data;
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="success">Access Result</param>
        /// <param name="bank">Access bank</param>
        /// <param name="access">Access type</param>
        /// <param name="data">Access Data only use for Tag Read operation</param>
        //public OnAccessCompletedEventArgs(bool success, Bank bank, TagAccess access, IBANK data)
        public OnAccessCompletedEventArgs(bool success, Bank bank, TagAccess access, IBANK data)
        {
            this.access = access;
            this.success = success;
            this.bank = bank;
            this.data = data;
        }
    }

    /// <summary>
    /// FM13DT Tag Access Completed Argument
    /// </summary>
    public class OnFM13DTAccessCompletedEventArgs : EventArgs
    {
        /// <summary>
        /// Access Result
        /// </summary>     
        public readonly bool success = false;
        /// <summary>
        /// Access Type
        /// </summary>
        public readonly FM13DTAccess access = FM13DTAccess.UNKNOWN;
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="success">Access Result</param>
        /// <param name="access">Access type</param>
        //public OnAccessCompletedEventArgs(bool success, Bank bank, TagAccess access, IBANK data)
        public OnFM13DTAccessCompletedEventArgs(FM13DTAccess access, bool success)
        {
            this.access = access;
            this.success = success;
        }
    }

    /// <summary>
    /// Reader Operation changed EventArgs
    /// </summary>
    public class OnStateChangedEventArgs : EventArgs
    {
        /// <summary>
        /// Current operation state
        /// </summary>
        public readonly RFState state = RFState.IDLE;
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="state"></param>
        public OnStateChangedEventArgs(RFState state)
        {
            this.state = state;
        }
    }

    
    public class OnInventoryTagRateCallbackEventArgs : EventArgs
    {
        /// <summary>
        /// Current operation state
        /// </summary>
        public readonly uint inventoryTagRate = 0;
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="state"></param>
        public OnInventoryTagRateCallbackEventArgs(uint tagRate)
        {
            this.inventoryTagRate = tagRate;
        }
    }


}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Structures/AntennaPortCollections.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace CSLibrary.Structures
{
    using CSLibrary.Constants;
    /// <summary>
    /// Antenna Port collections
    /// </summary>
    public class AntennaPortCollections : List<AntennaPort>
    {
        /// <summary>
        /// Initializes a new instance of the AntennaPortCollections class
        /// that is empty and has the default initial capacity.
        /// </summary>
        public AntennaPortCollections() : base() { }
        /// <summary>
        /// Initializes a new instance of the AntennaPortCollections class
        /// that is empty and has the specified initial capacity.
        /// </summary>
        /// <param name="capacity">The number of elements that the new list can initially store.</param>
        public AntennaPortCollections(int capacity)
            : base(capacity)
        {

        }
        /// <summary>
        /// Initializes a new instance of the AntennaPortCollections class
        /// that contains elements copied from the specified collection and has sufficient
        /// capacity to accommodate the number of elements copied.
        /// </summary>
        /// <param name="collection">The collection whose elements are copied to the new list.</param>
        public AntennaPortCollections(IEnumerable<AntennaPort> collection)
            : base(collection)
        {

        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Structures/CSLibrary.Structures.TagKill.cs">
using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;

using CSLibrary.Constants;
namespace CSLibrary.Structures
{
    /// <summary>
    /// Tag Kill structure, configure this before do tag kill
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public class TagKillParms
    {
        /*        /// <summary>
                /// Structure size
                /// </summary>
                protected readonly UInt32 Length = 21;
        */
        /// <summary>
        /// (NO USE in Kill Tag, just for compatible old code) The access password for the tags.  A value of zero indicates no 
        /// access password. 
        /// </summary>
        public UInt32 accessPassword;
        /// <summary>
        /// The kill password for the tags.  A value of zero indicates no 
        /// kill password. 
        /// </summary>
        public UInt32 killPassword;
        /// <summary>
        /// Number of retries attemp to read. This field must be between 0 and 15, inclusive.
        /// </summary>
        public UInt32 retryCount;
        /// <summary>
        /// Flag - Zero or combination of  Select or Post-Match
        /// </summary>
        public SelectFlags flags = SelectFlags.UNKNOWN;
        /// <summary>
        /// Extended Kill command
        /// </summary>
        public ExtendedKillCommand extCommand = ExtendedKillCommand.NORMAL;
        /// <summary>
        /// constructor
        /// </summary>
        public TagKillParms()
        {
            // NOP
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Structures/CSLibrary.Structures.TagLock.cs">
using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;

using CSLibrary.Constants;

namespace CSLibrary.Structures
{
    /// <summary>
    /// Tag lock structure, configure this before do tag lock
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public class TagLockParms
    {
        /// <summary>
        /// Structure size
        /// </summary>
        protected readonly UInt32 length = (UInt32)(16 + 20);
        /// <summary>
        /// The access password for the tags.  A value of zero indicates no 
        /// access password. 
        /// </summary>
        public UInt32 accessPassword;
        /// <summary>
        /// Number of retries attemp to read. This field must be between 0 and 15, inclusive.
        /// </summary>
        public UInt32 retryCount;
        /// <summary>
        /// The access permissions for the tag's kill password.  
        /// </summary>
        public Permission killPasswordPermissions = Permission.UNCHANGED;
        /// <summary>
        /// The access permissions for the tag's access password. 
        /// </summary>
        public Permission accessPasswordPermissions = Permission.UNCHANGED;
        /// <summary>
        /// The access permissions for the tag's EPC memory bank.  
        /// </summary>
        public Permission epcMemoryBankPermissions = Permission.UNCHANGED;
        /// <summary>
        /// The access permissions for the tag's TID memory bank.
        /// </summary>
        public Permission tidMemoryBankPermissions = Permission.UNCHANGED;
        /// <summary>
        /// The access permissions for the tag's user memory bank.
        /// </summary>
        public Permission userMemoryBankPermissions = Permission.UNCHANGED;
        /// <summary>
        /// The FFFFF Permanent Lock.
        /// </summary>
        public bool permanentLock = false;
        /// <summary>
        /// Flag - Zero or combination of  Select or Post-Match
        /// </summary>
        public SelectFlags flags = SelectFlags.UNKNOWN;
        /// <summary>
        /// constructor
        /// </summary>
        public TagLockParms()
        {
            // NOP
        }
    }

    /// <summary>
    /// block lock structure, configure this before do block lock
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public class TagBlockPermalockParms
    {
        /// <summary>
        /// Structure size
        /// </summary>
        public readonly UInt32 length = (UInt32)(24 + IntPtr.Size);
        /// <summary>
        /// The access password for the tags.  A value of zero indicates no 
        /// access password. 
        /// </summary>
        public UInt32 accessPassword;
        /// <summary>
        /// True to set permalock, otherwise read it state
        /// </summary>
        public bool setPermalock;
        /// <summary>
        /// Number of retries attemp to read. This field must be between 0 and 15, inclusive.
        /// </summary>
        public UInt32 retryCount;
        /// <summary>
        /// Flag - Zero or combination of  Select or Post-Match
        /// </summary>
        public SelectFlags flags = SelectFlags.UNKNOWN;
        /// <summary>
        /// 
        /// </summary>
        public UInt16 count;
        /// <summary>
        /// 
        /// </summary>
        public UInt16 offset;
        /// <summary>
        /// 
        /// </summary>
        public UInt16[] mask = new UInt16[0];
        /// <summary>
        /// constructor
        /// </summary>
        public TagBlockPermalockParms()
        {
            // NOP
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Structures/CSLibrary.Structures.TagRead.cs">
using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;

namespace CSLibrary.Structures
{
    using Constants;

    /// <summary>
    /// Read data memory structures, configure this before read current data
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public class TagReadParms
    {
        /// <summary>
        /// The Bank for the tags.
        /// </summary>
        public MemoryBank bank;
        /// <summary>
        /// The access password for the tags.  A value of zero indicates no 
        /// access password. 
        /// </summary>
        public UInt32 accessPassword;
        /// <summary>
        /// The offset, in the memory bank, of the first 16-bit word to read.
        /// </summary>
        public UInt16 offset;
        /// <summary>
        /// The number of 16-bit words that will be read.
        /// </summary>
        public UInt16 count;
        /// <summary>
        /// An array to the 16-bit values to read from the tag's memory bank.
        /// </summary>
        public UInt16[] m_pData = new ushort[0];
        /// <summary>
        /// constructor
        /// </summary>
        public TagReadParms()
        {
            // NOP
        }
        /// <summary>
        /// An array to the 16-bit values to read from the tag's memory bank.
        /// </summary>
        public S_DATA pData
        {
            get { return new S_DATA(m_pData); }
            set { m_pData = value.ToUshorts(); }
        }
    }
    /// <summary>
    /// Read EPC structures, configure this before read current EPC
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public class TagReadEpcParms
    {
        /// <summary>
        /// The access password for the tags.  A value of zero indicates no 
        /// access password. 
        /// </summary>
        public UInt32 accessPassword;
#if oldcode
        /// <summary>
        /// Number of retrial will retry if write failure
        /// </summary>
        public UInt32 retryCount;
#endif
        /// <summary>
        /// The offset, in the memory bank, of the first 16-bit word to read.
        /// </summary>
        public UInt16 offset;
        /// <summary>
        /// The number of 16-bit words that will be read. This field must be
        /// between 1 and 31, inclusive.                        
        /// </summary>          
        public UInt16 count;
        /// <summary>
        /// An EPC to the 16-bit values to write to the tag's memory bank.
        /// </summary>
        public UInt16[] m_epc = new ushort[31];
        /// <summary>
        /// 
        /// </summary>
        public TagReadEpcParms()
        {
            // NOP
        }
        /// <summary>
        /// An EPC to the 16-bit values to write to the tag's memory bank.
        /// </summary>
        public S_EPC epc
        {
            get { return new S_EPC(m_epc, count); }
        }
    }
    /// <summary>
    /// Read PC structures, configure this before read current PC
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public class TagReadPcParms
    {
        /// <summary>
        /// The access password for the tags.  A value of zero indicates no 
        /// access password. 
        /// </summary>
        public UInt32 accessPassword;
#if oldcode
        /// <summary>
        /// Number of retrial will retry if read failure
        /// </summary>
        public UInt32 retryCount;
#endif
        /// <summary>
        /// A PC to the 16-bit values to read from the tag's memory bank.
        /// </summary>
        public ushort m_pc = 0;
        /// <summary>
        /// 
        /// </summary>
        public TagReadPcParms()
        {
            // NOP
        }
        /// <summary>
        /// A PC to the 16-bit values to read from the tag's memory bank.
        /// </summary>
        public S_PC pc
        {
            get { return new S_PC(m_pc); }
        }
    }
    /// <summary>
    /// Read TID structures, configure this before read current TID
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public class TagReadTidParms
    {
        /// <summary>
        /// The access password for the tags.  A value of zero indicates no 
        /// access password. 
        /// </summary>
        public UInt32 accessPassword;
#if oldcode
        /// <summary>
        /// Number of retrial will retry if read failure
        /// </summary>
        public UInt32 retryCount;
#endif
        /// <summary>
        /// The offset, in the memory bank, of the first 16-bit word to read.
        /// </summary>
        public UInt16 offset = 0;
        /// <summary>
        /// The number of 16-bit words that will be read. This field must be
        /// between 1 and 31, inclusive.         
        /// </summary>
        public UInt16 count = 0;
        /// <summary>
        /// A pointer to the 16-bit values to read from the tag's memory bank.
        /// </summary>
        public UInt16[] pData = new UInt16[31];
        /// <summary>
        /// 
        /// </summary>
        public TagReadTidParms()
        {
            // NOP
        }
        /// <summary>
        /// An array to the 16-bit values to read from tag's memory bank.
        /// </summary>
        public S_TID tid
        {
            get
            {
                return new S_TID(pData, count);
            }
        }
    }
    /// <summary>
    /// Read password structures, configure this before read current password
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public class TagReadPwdParms
    {
        /// <summary>
        /// The access password for the tags.  A value of zero indicates no 
        /// access password. 
        /// </summary>
        public UInt32 accessPassword;
#if oldcode
        /// <summary>
        /// Number of retrial will retry if read failure
        /// </summary>
        public UInt32 retryCount;
#endif
        /// <summary>
        /// A password to the 32-bit values to read from the tag's memory bank.
        /// </summary>
        public UInt32 m_password = 0;
        /// <summary>
        /// 
        /// </summary>
        public TagReadPwdParms()
        {
            // NOP
        }
        /// <summary>
        /// A password to the 32-bit values to read from the tag's memory bank.
        /// </summary>
        public S_PWD password
        {
            get { return new S_PWD(m_password); }
        }

    }
    /// <summary>
    /// Read User memory structures, configure this before read current User memory
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public class TagReadUserParms
    {
        /// <summary>
        /// The access password for the tags.  A value of zero indicates no 
        /// access password. 
        /// </summary>
        public UInt32 accessPassword;
#if oldcode
        /// <summary>
        /// Number of retrial will retry if read failure
        /// </summary>
        public UInt32 retryCount;
#endif
        /// <summary>
        /// The offset, in the memory bank, of the first 16-bit word to read.
        /// </summary>
        public UInt16 offset;
        /// <summary>
        /// The number of 16-bit words that will be read.
        /// </summary>
        public UInt16 count;
        /// <summary>
        /// An array to the 16-bit values to read from the tag's memory bank.
        /// </summary>
        public UInt16[] m_pData = new ushort[0];
        /// <summary>
        /// constructor
        /// </summary>
        public TagReadUserParms()
        {
            // NOP
        }
        /// <summary>
        /// An array to the 16-bit values to read from the tag's memory bank.
        /// </summary>
        public S_DATA pData
        {
            get { return new S_DATA(m_pData); }
            set { m_pData = value.ToUshorts(); }
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/Basic_Structures/CSLibrary.Structures.TagWrite.cs">
using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;

namespace CSLibrary.Structures
{
    using Constants;

    /// <summary>
    /// Write User structures, configure this before write new user data
    /// </summary>
    public class TagWriteParms
    {
        /// <summary>
        /// The Bank for the tags.
        /// </summary>
        public MemoryBank bank;
        /// <summary>
        /// The access password for the tags.  A value of zero indicates no 
        /// access password. 
        /// </summary>
        public UInt32 accessPassword;
        /// <summary>
        /// The offset, in the memory bank, of the first 16-bit word to write.
        /// </summary>
        public UInt16 offset;
        /// <summary>
        /// The number of 16-bit words that will be written.  
        /// </summary>                                       
        public UInt16 count;
        /// <summary>
        /// A array to the 16-bit values to write to the tag's memory bank.
        /// </summary>
        public UInt16[] pData = new UInt16[0];
        /// <summary>
        /// Flag - Normal or combination of  Select or Post-Match
        /// </summary>
        public SelectFlags flags = SelectFlags.SELECT;
    }

    /// <summary>
    /// Write PC structures, configure this before write new PC value
    /// </summary>
    public class TagWritePcParms
    {
        /// <summary>
        /// The access password for the tags.  A value of zero indicates no 
        /// access password. 
        /// </summary>
        public UInt32 accessPassword;
#if oldcode
        /// <summary>
        /// Number of retrial will retry if write failure (Process Retry / Library Retry)
        /// </summary>
        public UInt32 retryCount;
        /// <summary>
        /// Number of retrial will retry if write failure (Write Retry / Firmware Retry)
        /// </summary>
        public UInt32 writeRetryCount = 32;
#endif
        /// <summary>
        /// A new pc to the 16-bit values to write to the tag's memory bank.
        /// </summary>
//        public S_PC pc = new S_PC();
        public UInt16 pc;
        /// <summary>
        /// Flag - Normal or combination of  Select or Post-Match
        /// </summary>
        public SelectFlags flags = SelectFlags.SELECT;
    }
/*
    /// <summary>
    /// Write PC structures, configure this before write new PC value
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public class TagWritePcParms
    {
        /// <summary>
        /// The access password for the tags.  A value of zero indicates no 
        /// access password. 
        /// </summary>
        public UInt32 accessPassword;
        /// <summary>
        /// Number of retrial will retry if write failure
        /// </summary>
        public UInt32 retryCount;
        /// <summary>
        /// A new pc to the 16-bit values to write to the tag's memory bank.
        /// </summary>
        public UInt16 pc;
        /// <summary>
        /// 
        /// </summary>
        public TagWritePcParms()
        {
            // NOP
        }
    }
 */
    /// <summary>
    /// Write EPC structures, configure this before write new EPC value
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public class TagWriteEpcParms
    {
        /// <summary>
        /// The access password for the tags.  A value of zero indicates no 
        /// access password. 
        /// </summary>
        public UInt32 accessPassword;
#if oldcode
        /// <summary>
        /// Number of retrial will retry if write failure (Process Retry / Library Retry)
        /// </summary>
        public UInt32 retryCount;
        /// <summary>
        /// Number of retrial will retry if write failure (Write Retry / Firmware Retry)
        /// </summary>
        public UInt32 writeRetryCount = 32;
#endif
        /// <summary>
        /// The offset, in the memory bank, of the first 16-bit word to write.
        /// </summary>
        public UInt16 offset;
        /// <summary>
        /// The number of 16-bit words that will be written.  This field must be
        /// between 1 and 31, inclusive.  
        /// </summary>
        public UInt16 count;
        /// <summary>
        /// A new epc to the 16-bit values to write to the tag's memory bank.
        /// </summary>
        public S_EPC epc;
        /// <summary>
        /// 
        /// </summary>
        public TagWriteEpcParms()
        {
            // NOP
        }
    }
    /// <summary>
    /// Write password structures, configure this before write new password value
    /// </summary>
    public class TagWritePwdParms
    {
        /// <summary>
        /// The access password for the tags.  A value of zero indicates no 
        /// access password. 
        /// </summary>
        public UInt32 accessPassword;
#if oldcode
        /// <summary>
        /// Number of retrial will retry if write failure (Process Retry / Library Retry)
        /// </summary>
        public UInt32 retryCount;
        /// <summary>
        /// Number of retrial will retry if write failure (Write Retry / Firmware Retry)
        /// </summary>
        public UInt32 writeRetryCount = 32;
#endif
        /// <summary>
        /// A new password to the 32-bit values to write to the tag's memory bank.
        /// </summary>
        //public S_PWD password = new S_PWD();
        public UInt32 password;
        /// <summary>
        /// Flag - Normal or combination of  Select or Post-Match
        /// </summary>
        public SelectFlags flags = SelectFlags.SELECT;
    }

/*    
    /// <summary>
    /// Write password structures, configure this before write new password value
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public class TagWritePwdParms
    {
        /// <summary>
        /// The access password for the tags.  A value of zero indicates no 
        /// access password. 
        /// </summary>
        public UInt32 accessPassword;
        /// <summary>
        /// Number of retrial will retry if write failure
        /// </summary>
        public UInt32 retryCount;
        /// <summary>
        /// A new password to the 32-bit values to write to the tag's memory bank.
        /// </summary>
        public uint password;
        /// <summary>
        /// 
        /// </summary>
        public TagWritePwdParms()
        {
            // NOP
        }
    }
*/

    /// <summary>
    /// Write User structures, configure this before write new user data
    /// </summary>
    public class TagWriteUserParms
    {
        /// <summary>
        /// The access password for the tags.  A value of zero indicates no 
        /// access password. 
        /// </summary>
        public UInt32 accessPassword;
#if oldcode
        /// <summary>
        /// Number of retrial will retry if write failure (Process Retry / Library Retry)
        /// </summary>
        public UInt32 retryCount;
        /// <summary>
        /// Number of retrial will retry if write failure (Write Retry / Firmware Retry)
        /// </summary>
        public UInt32 writeRetryCount = 32;
#endif
        /// <summary>
        /// The offset, in the memory bank, of the first 16-bit word to write.
        /// </summary>
        public UInt16 offset;
        /// <summary>
        /// The number of 16-bit words that will be written.  
        /// </summary>                                       
        public UInt16 count;
        /// <summary>
        /// A array to the 16-bit values to write to the tag's memory bank.
        /// </summary>
        public UInt16[] pData = new UInt16[0];
        //public S_DATA pData = new S_DATA();
        /// <summary>
        /// Flag - Normal or combination of  Select or Post-Match
        /// </summary>
        public SelectFlags flags = SelectFlags.SELECT;




    }

    /// <summary>
    /// The ISO 18000-6C tag-block write operation parameters
    /// </summary>
    public class TAG_BLOCK_WRITE_PARMS
    {
        /// <summary>
        /// The maximum number of times the write should be retried in the event 
        /// of write-verify failure(s).  In the event of write-verify failure(s), the write 
        /// will be retried either for the specified number of retries or until the data 
        /// written is successfully verified.  If the specified number of retries are 
        /// performed without successfully verifying the written data, the write 
        /// operation is considered to have failed and the tag-access operation-
        /// response packet will indicate the error.  This value must be between 0 
        /// and 31, inclusive. 
        /// If verify is non-zero, this parameter is ignored.
        /// </summary>
        public uint retryCount = 31;
        /// <summary>
        /// Starting offset
        /// </summary>
        public ushort offset;
        /// <summary>
        /// Total number of words written to user memory
        /// </summary>
        public ushort count;
        /// <summary>
        /// Write Buffer data to target tag
        /// </summary>
        public UInt16[] data = new UInt16[0];
        /// <summary>
        /// Target Memory Bank
        /// </summary>
        public MemoryBank bank = MemoryBank.UNKNOWN;
        /// <summary>
        /// Target Access Password
        /// </summary>
        public uint accessPassword;
        /// <summary>
        /// Flag - Zero or combination of  Select or Post-Match
        /// </summary>
        public SelectFlags flags = SelectFlags.SELECT;
    }
    
    /*
     * /// <summary>
        /// Write User structures, configure this before write new user data
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public class TagWriteUserParms
        {
            /// <summary>
            /// The access password for the tags.  A value of zero indicates no 
            /// access password. 
            /// </summary>
            public UInt32 accessPassword;
            /// <summary>
            /// Number of retrial will retry if write failure
            /// </summary>
            public UInt32 retryCount;
            /// <summary>
            /// The offset, in the memory bank, of the first 16-bit word to write.
            /// </summary>
            public UInt16 offset;
            /// <summary>
            /// The number of 16-bit words that will be written.  
            /// </summary>                                       
            public UInt16 count;
            /// <summary>
            /// A array to the 16-bit values to write to the tag's memory bank.
            /// </summary>
            public UInt16[] pData = new UInt16[0];
            /// <summary>
            /// Constructor
            /// </summary>
            public TagWriteUserParms()
            {
                // NOP
            }
        }
    */
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/TAG_ASYN/ClassRFID.ASYN.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace CSLibrary
{
    using Constants;
    using Structures;
    using Events;
    using Tools;
    public class ClassASYN
    {
        public class TagCallbackInfo : CSLibrary.Structures.TagCallbackInfo
        {
            public TagCallbackInfo()
            {
            }
        }

        //public class OnAsyncCallbackEventArgs() : CSLibrary.Events.OnAsyncCallbackEventArgs
        //{
        //}

        private HighLevelInterface _deviceHandler;

        public event EventHandler<OnAsyncCallbackEventArgs> OnAsyncCallback;

        internal ClassASYN(HighLevelInterface handler)
        {
            _deviceHandler = handler;
        }

        void TagInventoryEvent(object sender, CSLibrary.Events.OnAsyncCallbackEventArgs e)
        {
            if (e.type != CSLibrary.Constants.CallbackType.TAG_RANGING)
                return;

            CSLibrary.Constants.CallbackType type = CSLibrary.Constants.CallbackType.TAG_RANGING;
            //CSLibrary.Events.OnAsyncCallbackEventArgs callBackData = new Events.OnAsyncCallbackEventArgs(info, type);

            //if (OnAsyncCallback != null)
            //    OnAsyncCallback(_deviceHandler, callBackData);
        }

        public Result ClearEventHandler()
        {
            this.OnAsyncCallback = null;
            return Result.OK;
        }

        public Result StartInventory ()
        {
            _deviceHandler.rfid.ClearOnAsyncCallback();
            _deviceHandler.rfid.OnAsyncCallback += new EventHandler<CSLibrary.Events.OnAsyncCallbackEventArgs>(TagInventoryEvent);
            _deviceHandler.rfid.Options.TagRanging.multibanks = 2;
            _deviceHandler.rfid.Options.TagRanging.bank1 = MemoryBank.USER ;
            _deviceHandler.rfid.Options.TagRanging.offset1 = 0;
            _deviceHandler.rfid.Options.TagRanging.count1 = 1;
            _deviceHandler.rfid.Options.TagRanging.bank2 = MemoryBank.USER;
            _deviceHandler.rfid.Options.TagRanging.offset2 = 0;
            _deviceHandler.rfid.Options.TagRanging.count2 = 1;

            return _deviceHandler.rfid.StartOperation(Operation.TAG_RANGING);
        }

        public void StopInventory ()
        {
            _deviceHandler.rfid.StopOperation();
        }

        public Result Configuration(S_EPC tagid)
        {
            return _deviceHandler.rfid.StartOperation(Operation.TAG_RANGING);
        }


    }
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/TAG_EM4325/ClassRFID.EM4325.cs">
using System;
using System.Collections.Generic;
using System.Text;

using CSLibrary;
using CSLibrary.Constants;
using CSLibrary.Structures;
using CSLibrary.Events;
using CSLibrary.Tools;

namespace CSLibrary
{
	public class ClassEM4325
	{
		public enum Operation
		{
			GETSENSORDATA
		}

		public class GETSENSORDATAPARAMETERS
		{
			public bool sendUID = false;
			public bool newSample = false;
			public double temperatureC = 0;
		}

		public class EM4325Paras
		{
			public GETSENSORDATAPARAMETERS GetSensorData = new GETSENSORDATAPARAMETERS();
		}

		public class OnAccessCompletedEventArgs : EventArgs
		{
			public Operation operation;
			public bool success;

			public OnAccessCompletedEventArgs(Operation operation, bool success)
			{
				this.operation = operation;
				this.success = success;
			}
		}


		public event EventHandler<OnAccessCompletedEventArgs> OnAccessCompleted;
		public EM4325Paras Options = new EM4325Paras();

		private HighLevelInterface _deviceHandler;

		internal ClassEM4325(HighLevelInterface handler)
		{
			_deviceHandler = handler;
		}

		public void ClearEventHandler()
		{
			OnAccessCompleted = null;
		}

		// call by Application
		public int StartOperation(Operation operation)
		{
			switch (operation)
			{
				case Operation.GETSENSORDATA:
					GetSenseDataProc();
					return 0;
			}

			return -1;
		}

		private void GetSensorData(bool sendUID, bool newSample)
		{
			UInt32 value = 0;

			if (sendUID)
				value |= 0x01;

			if (newSample)
				value |= 0x02;

			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.EM4325_CFG, value);
			_deviceHandler.SendAsync(0, 0, RFIDReader.DOWNLINKCMD.RFIDCMD, _deviceHandler.rfid.PacketData(0xf000, (UInt32)RFIDReader.HST_CMD.CUSTOMEMGETSENSORDATA), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.EM_GetSensorData);
		}

		private bool GetSenseDataProc()
		{
			GetSensorData(Options.GetSensorData.sendUID, Options.GetSensorData.newSample);
			return true;
		}


		// call by Library core
		/// <summary>
		/// System Operation
		///	Subsystem Operation
		///	Sequence
		/// </summary>
		/// <param name="operation"></param>
		/// <param name="TagAccessPacket"></param>
		/// <returns></returns>
		//internal int TagAccessProc(CSLibrary.Constants.Operation mainOperation, Operation subOperation, int sqr, byte[] TagAccessPacket)
		internal bool TagAccessProc(CSLibrary.Constants.Operation mainOperation, byte[] TagAccessPacket)
		{
			switch (mainOperation)
			{
				case CSLibrary.Constants.Operation.EM_GetSensorData:
					{
						var SensorDataMsw = (TagAccessPacket[32] << 0x08 | TagAccessPacket[33]);
						var Temp = (SensorDataMsw & 0x00ff);
						if ((SensorDataMsw & 0x0100) != 00)
							Temp -= 256;

						Options.GetSensorData.temperatureC = Temp * 0.25;
					}
					return true;
			}

			return false;
		}

		// call by Library core
		internal bool CommandEndProc(CSLibrary.Constants.Operation mainOperation, bool success)
		{
			switch (mainOperation)
			{
				case CSLibrary.Constants.Operation.EM_GetSensorData:
					if (OnAccessCompleted != null)
						OnAccessCompleted(this, new OnAccessCompletedEventArgs(Operation.GETSENSORDATA, success));
					return true;
			}

			return false;
		}
	}
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/TAG_FM13DT160/ClassRFID.FM13DT160.cs">
using System;
using System.Collections.Generic;
using System.Text;

using CSLibrary;
using CSLibrary.Constants;
using CSLibrary.Structures;
using CSLibrary.Events;
using CSLibrary.Tools;

namespace CSLibrary
{
	public class ClassFM13DT160
	{
		public enum Operation
		{
			READMEMORY,		// Read memory
			WRITEMEMORY,	// Write memory
			READREGISTER,	// Read Register
			WRITEREGISTER,	// Write Register
			AUTH,			// Auth
			GETTEMP,		// Get Temp
			STARTLOG,		// Start Log
			STOPLOG,		// Stop Log
			DEEPSLEEP,		// Reset to sleep mode
			OPMODECHK,		// Operation
			INITIALREGFILE,	// Init Tag
			LEDCTRL			// Tuen on LED 1s
		}

		/// <summary>
		/// offset = Starting address
		/// count = Read size (byte)
		/// data = Result
		/// </summary>
		public class ReadMemoryParms
		{
			public UInt16 offset;
			public uint count;		// Byte size (divide by 4)
			public byte[] data;
		}

		/// <summary>
		/// offset = Starting address
		/// count = Write size (byte)
		/// data = Data
		/// </summary>
		public class WriteMemoryParms
		{
			public UInt16 offset;
			public uint count;		// Byte size (max 4)
			public byte[] data;
		}

		/// <summary>
		/// offset = Starting address
		/// count = Write size (byte)
		/// data = Data
		/// </summary>
		public class ReadRegisterParms
		{
			public UInt16 address;
			public UInt16 value;
		}

		/// <summary>
		/// offset = Starting address
		/// count = Read size (byte)
		/// data = Result
		/// </summary>
		public class WriteRegisterParms
		{
			public UInt16 address;
			public UInt16 value;
		}

		/// <summary>
		/// </summary>
		public class AuthParms
		{
		}

		/// <summary>
		/// </summary>
		public class GetTempParms
		{
			public enum CMDCFG : UInt32
			{
				TEMP = 0x86,
				BATTERY = 0x92
			}

			public UInt32 cmd_cfg = (UInt32)CMDCFG.TEMP;
			public UInt32 ewblock_addr = 0x00;
		}

		/// <summary>
		/// </summary>
		public class StartLogParms
		{
		}

		/// <summary>
		/// </summary>
		public class StopLogParms
		{
			public UInt32 password;
		}

		public class DeepSleepParms
		{
			public bool enable;
		}

		public class OpModeChkParms
		{
			public bool enable;
			public bool user_access_en;
			public bool RTC_logging;
			public bool vdet_process_flag;
			public bool light_chk_flag;
			public bool vbat_pwr_flag;
		}

		public class LedCtrlParms
		{
			public bool enable;
		}

		public class FM13DT160Paras
		{
			public ReadMemoryParms ReadMemory = new ReadMemoryParms();
			public WriteMemoryParms WriteMemory = new WriteMemoryParms();
			public ReadRegisterParms ReadRegister = new ReadRegisterParms();
			public WriteRegisterParms WriteRegister = new WriteRegisterParms();
			public AuthParms Auth = new AuthParms();
			public GetTempParms GetTemp = new GetTempParms();
			public StartLogParms StartLog = new StartLogParms();
			public StopLogParms StopLog = new StopLogParms();
			public DeepSleepParms DeepSleep = new DeepSleepParms();
			public OpModeChkParms OpModeChk = new OpModeChkParms();
			public LedCtrlParms LedCtrl = new LedCtrlParms();
		}

		public class OnAccessCompletedEventArgs : EventArgs
		{
			public Operation operation;
			public bool success;

			public OnAccessCompletedEventArgs(Operation operation, bool success)
			{
				this.operation = operation;
				this.success = success;
			}
		}

		public event EventHandler<OnAccessCompletedEventArgs> OnAccessCompleted;
		public FM13DT160Paras Options = new FM13DT160Paras();

		private HighLevelInterface _deviceHandler;

		internal ClassFM13DT160(HighLevelInterface handler)
		{
			_deviceHandler = handler;
		}

		public void ClearEventHandler()
		{
			OnAccessCompleted = null;
		}

		// call by Application
		public int StartOperation(Operation operation)
		{
			switch (operation)
			{
				case Operation.READMEMORY:
					FM13DTReadMemoryThreadProc();
					break;

				case Operation.WRITEMEMORY:
					FM13DTWriteMemoryThreadProc();
					break;

				case Operation.READREGISTER:
					FM13DTReadRegThreadProc();
					break;

				case Operation.WRITEREGISTER:
					FM13DTWriteRegThreadProc();
					break;

				case Operation.AUTH:
					FM13DTAuthThreadProc();
					break;

				case Operation.GETTEMP:
					FM13DTGetTempThreadProc();
					break;

				case Operation.STARTLOG:
					FM13DTStartLogThreadProc();
					break;

				case Operation.STOPLOG:
					FM13DTStopLogChkThreadProc();
					break;

				case Operation.DEEPSLEEP:
					FM13DTDeepSleepThreadProc();
					break;

				case Operation.OPMODECHK:
					FM13DTOpModeChkThreadProc();
					break;

				case Operation.INITIALREGFILE:
					FM13DTInitialRegFileThreadProc();
					break;

				case Operation.LEDCTRL:
					FM13DTLedCtrlThreadProc();
					break;
			}

			return -1;
		}

		private bool FM13DTReadMemoryThreadProc()
		{
			if (Options.ReadMemory.offset > 0xffff)
				return false;

			if ((Options.ReadMemory.count & 0x3) != 0)
				return false;

			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_STARTADDRPAR, (uint)Options.ReadMemory.offset);
			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_READWRITELENPAR, (uint)Options.ReadMemory.count);
			_deviceHandler.SendAsync(0, 0, RFIDReader.DOWNLINKCMD.RFIDCMD, _deviceHandler.rfid.PacketData(0xf000, (UInt32)RFIDReader.HST_CMD.CUSTOMMFM13DTREADMEMORY), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_READMEMORY);

			return true;
		}

		private bool FM13DTWriteMemoryThreadProc()
		{
			if (Options.WriteMemory.offset > 0xffff)
				return false;

			if ((Options.WriteMemory.count & 0x1) != 0)
				return false;

			UInt32 value = (UInt32)((Options.WriteMemory.data[0] << 24) | (Options.WriteMemory.data[1] << 16) | (Options.WriteMemory.data[2] << 8) | Options.WriteMemory.data[3]);

			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_STARTADDRPAR, (uint)Options.WriteMemory.offset);
			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_READWRITELENPAR, (uint)Options.WriteMemory.count);
			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_DATAPAR, value);
			//_deviceHandler.SendAsync(0, 0, RFIDReader.DOWNLINKCMD.RFIDCMD, _deviceHandler.rfid.PacketData(0xf000, (UInt32)RFIDReader.HST_CMD.CUSTOMMFM13DTWRITEMEMORY), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_WRITEMEMORY);

			return true;
		}

		private bool FM13DTReadRegThreadProc()
		{
			if (Options.ReadRegister.address < 0xc000 || Options.ReadRegister.address > 0xc0ff)
				return false;

			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_REGADDRPAR, (uint)Options.ReadRegister.address);
			_deviceHandler.SendAsync(0, 0, RFIDReader.DOWNLINKCMD.RFIDCMD, _deviceHandler.rfid.PacketData(0xf000, (UInt32)RFIDReader.HST_CMD.CUSTOMMFM13DTREADREG), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_READREGISTER);
			return true;
		}

		private bool FM13DTWriteRegThreadProc()
		{
			if (Options.ReadRegister.address < 0xc000 || Options.ReadRegister.address > 0xcff)
				return false;

			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_REGADDRPAR, (uint)Options.WriteRegister.address);
			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_WRITEPAR, (uint)Options.WriteRegister.value);
			_deviceHandler.SendAsync(0, 0, RFIDReader.DOWNLINKCMD.RFIDCMD, _deviceHandler.rfid.PacketData(0xf000, (UInt32)RFIDReader.HST_CMD.CUSTOMMFM13DTWRITEREG), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_WRITEREGISTER);
			return true;
		}

		private bool FM13DTAuthThreadProc()
		{
//			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_CMDCFGPAR, (uint)mode);
//			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_PWDPAR, password);

			_deviceHandler.SendAsync(0, 0, RFIDReader.DOWNLINKCMD.RFIDCMD, _deviceHandler.rfid.PacketData(0xf000, (UInt32)RFIDReader.HST_CMD.CUSTOMMFM13DTAUTH), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_AUTH);
			return true;
		}

		private bool FM13DTGetTempThreadProc()
		{
			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_CMDCFGPAR, Options.GetTemp.cmd_cfg);
			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_STOBLOCKADDPAR, Options.GetTemp.ewblock_addr);
			_deviceHandler.SendAsync(0, 0, RFIDReader.DOWNLINKCMD.RFIDCMD, _deviceHandler.rfid.PacketData(0xf000, (UInt32)RFIDReader.HST_CMD.CUSTOMMFM13DTGETTEMP), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_GETTEMP);
			return true;
		}
		private bool FM13DTStartLogThreadProc()
		{
			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_CMDCFGPAR, 0x00);

//			_deviceHandler.SendAsync(0, 0, RFIDReader.DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)RFIDReader.HST_CMD.CUSTOMMFM13DTSTARTLOG), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_STARTLOG);
			return true;
		}

		private bool FM13DTStopLogChkThreadProc()
		{
			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_CMDCFGPAR, 0x50);
			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_PWDPAR, Options.StopLog.password);
			_deviceHandler.SendAsync(0, 0, RFIDReader.DOWNLINKCMD.RFIDCMD, _deviceHandler.rfid.PacketData(0xf000, (UInt32)RFIDReader.HST_CMD.CUSTOMMFM13DTSTOPLOG), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_STOPLOG);
			return true;
		}
		private bool FM13DTDeepSleepThreadProc()
		{
			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_CMDCFGPAR, 1U);
			_deviceHandler.SendAsync(0, 0, RFIDReader.DOWNLINKCMD.RFIDCMD, _deviceHandler.rfid.PacketData(0xf000, (UInt32)RFIDReader.HST_CMD.CUSTOMMFM13DTDEEPSLEEP), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_DEEPSLEEP);
			return true;
		}
		private bool FM13DTOpModeChkThreadProc()
		{
			uint value = 0;

			if (Options.OpModeChk.enable)
				value = 0x01;

			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_CMDCFGPAR, value);
			_deviceHandler.SendAsync(0, 0, RFIDReader.DOWNLINKCMD.RFIDCMD, _deviceHandler.rfid.PacketData(0xf000, (UInt32)RFIDReader.HST_CMD.CUSTOMMFM13DTOPMODECHK), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1, (uint)CSLibrary.Constants.Operation.FM13DT_OPMODECHK);

			return true;
		}

		private bool FM13DTInitialRegFileThreadProc()
		{
			_deviceHandler.SendAsync(0, 0, RFIDReader.DOWNLINKCMD.RFIDCMD, _deviceHandler.rfid.PacketData(0xf000, (UInt32)RFIDReader.HST_CMD.CUSTOMMFM13DTINITIALREGFILE), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_INITIALREGFILE);
			return true;
		}

		private bool FM13DTLedCtrlThreadProc()
		{
			uint value = 0;

			if (Options.LedCtrl.enable)
				value = 0x02;

			_deviceHandler.rfid.MacWriteRegister(RFIDReader.MACREGISTER.FM13DT160_CMDCFGPAR, value);
			_deviceHandler.SendAsync(0, 0, RFIDReader.DOWNLINKCMD.RFIDCMD, _deviceHandler.rfid.PacketData(0xf000, (UInt32)RFIDReader.HST_CMD.CUSTOMMFM13DTLEDCTRL), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1, (uint)CSLibrary.Constants.Operation.FM13DT_LEDCTRL);

			return true;
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="TagAccessPacket"></param>
		/// <returns></returns>
		internal bool TagAccessProc(CSLibrary.Constants.Operation operation, byte[] TagAccessPacket)
		{
			var a = 10;

			switch (operation)
			{
				case CSLibrary.Constants.Operation.FM13DT_AUTH:

					break;

				case CSLibrary.Constants.Operation.FM13DT_DEEPSLEEP:
					break;

				case CSLibrary.Constants.Operation.FM13DT_GETTEMP:
					{
						int returnvalue = (TagAccessPacket[TagAccessPacket.Length - 4] << 8) | TagAccessPacket[TagAccessPacket.Length - 3];

						switch (returnvalue)
						{
							case 0x0f:
								break;

							case 0xfffa: // 
								return true;

							case 0xfff5: // 
								return true;

							case 0xfff0: // 
								return true;
						}
					}
					break;

				case CSLibrary.Constants.Operation.FM13DT_INITIALREGFILE:
					{
						var returnvalue = TagAccessPacket[TagAccessPacket.Length - 4];
						if (TagAccessPacket[TagAccessPacket.Length - 4] != 00 || TagAccessPacket[TagAccessPacket.Length - 3] != 00)
							break;
					}
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_LEDCTRL:
					{
						var returnvalue = TagAccessPacket[TagAccessPacket.Length - 4];
					}
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_OPMODECHK:
					{
						/*
												result[15:14]= 00 RFU
												result[13]= 1 user_access_en
												result[12]= 0 RTC loggingrtc
												result[11]= 0 vdet_process_flag
												result[10]= 0 RFU
												result[9]= 0 light_chk_flag
												result[8]= 1 vbat_pwr_flag0.9V

												result[7:4]= 0000 RFU
												result[3:0]: = 0001 RFU
						*/
						var returnvalue = TagAccessPacket[TagAccessPacket.Length - 4];

						Options.OpModeChk.user_access_en = (returnvalue >> 5 & 0x01) != 0;
						Options.OpModeChk.RTC_logging = (returnvalue >> 4 & 0x01) != 0;
						Options.OpModeChk.vdet_process_flag = (returnvalue >> 3 & 0x01) != 0;
						Options.OpModeChk.light_chk_flag = (returnvalue >> 1 & 0x01) != 0;
						Options.OpModeChk.vbat_pwr_flag = (returnvalue & 0x01) != 0;
					}
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_READMEMORY:
					{
						if (TagAccessPacket.Length != (Options.ReadMemory.count + 20))
							break;

						Options.ReadMemory.data = new byte[Options.ReadMemory.count];
						Buffer.BlockCopy(TagAccessPacket, 20, Options.ReadMemory.data, 0, (int)(Options.ReadMemory.count));
					}
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_READREGISTER:
					Options.ReadRegister.value = (UInt16)((TagAccessPacket[20] << 8) | TagAccessPacket[21]);
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_STARTLOG:
					break;

				case CSLibrary.Constants.Operation.FM13DT_STOPLOG:
					break;

				case CSLibrary.Constants.Operation.FM13DT_WRITEMEMORY:
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_WRITEREGISTER:
					return true;
					break;
			}

			return false;
		}

		internal bool CommandEndPProc(CSLibrary.Constants.Operation operation, bool success)
		{
			switch (operation)
			{
				case CSLibrary.Constants.Operation.FM13DT_AUTH:
					if (OnAccessCompleted != null)
						OnAccessCompleted(this, new OnAccessCompletedEventArgs(Operation.AUTH, success));
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_DEEPSLEEP:
					if (OnAccessCompleted != null)
						OnAccessCompleted(this, new OnAccessCompletedEventArgs(Operation.DEEPSLEEP, success));
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_GETTEMP:
					if (OnAccessCompleted != null)
						OnAccessCompleted(this, new OnAccessCompletedEventArgs(Operation.GETTEMP, success));
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_INITIALREGFILE:
					if (OnAccessCompleted != null)
						OnAccessCompleted(this, new OnAccessCompletedEventArgs(Operation.INITIALREGFILE, success));
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_LEDCTRL:
					if (OnAccessCompleted != null)
						OnAccessCompleted(this, new OnAccessCompletedEventArgs(Operation.LEDCTRL, success));
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_OPMODECHK:
					if (OnAccessCompleted != null)
						OnAccessCompleted(this, new OnAccessCompletedEventArgs(Operation.OPMODECHK, success));
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_READMEMORY:
					if (OnAccessCompleted != null)
						OnAccessCompleted(this, new OnAccessCompletedEventArgs(Operation.READMEMORY, success));
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_READREGISTER:
					if (OnAccessCompleted != null)
						OnAccessCompleted(this, new OnAccessCompletedEventArgs(Operation.READREGISTER, success));
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_STARTLOG:
					if (OnAccessCompleted != null)
						OnAccessCompleted(this, new OnAccessCompletedEventArgs(Operation.STARTLOG, success));
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_STOPLOG:
					if (OnAccessCompleted != null)
						OnAccessCompleted(this, new OnAccessCompletedEventArgs(Operation.STOPLOG, success));
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_WRITEMEMORY:
					if (OnAccessCompleted != null)
						OnAccessCompleted(this, new OnAccessCompletedEventArgs(Operation.WRITEMEMORY, success));
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_WRITEREGISTER:
					if (OnAccessCompleted != null)
						OnAccessCompleted(this, new OnAccessCompletedEventArgs(Operation.WRITEREGISTER, success));
					return true;
					break;

				default:
					break;
			}

			return false;
		}
	}
}
</file>

<file path="Library/CSLibrary/Source/RFIDReader/CSLUnifiedAPI/TAG_FM13DT160/ClassRFID.Private.FM13DT160.cs">
using System;
using System.Collections.Generic;
using System.Text;

using CSLibrary;
using CSLibrary.Constants;
using CSLibrary.Structures;
using CSLibrary.Events;
using CSLibrary.Tools;

namespace CSLibrary
{
	public partial class RFIDReader
	{
		/// <summary>
		/// FM13DT Tag Access completed event
		/// </summary>
		public event EventHandler<CSLibrary.Events.OnFM13DTAccessCompletedEventArgs> OnFM13DTAccessCompleted;

		//MacWriteRegister(MACREGISTER.HST_ANT_DESC_SEL, 0);
		//MacReadRegister(MACREGISTER.HST_ANT_DESC_RFPOWER, ref pwrlvl);
		//FM13DT160_CMDCFGPAR = 0x117,
		//FM13DT160_REGADDRPAR = 0x118,
		//FM13DT160_WRITEPAR = 0x119,
		//FM13DT160_PWDPAR = 0x11a,
		//FM13DT160_STOBLOCKADDPAR = 0x11b,
		//FM13DT160_STARTADDRPAR = 0x11c,
		//FM13DT160_READWRITELENPAR = 0x11d,
		//FM13DT160_DATAPAR = 0x11e,

		void FM13DT160_ReadMemory(uint offset, uint size)
		{
			MacWriteRegister(MACREGISTER.FM13DT160_STARTADDRPAR, (uint)offset);
			MacWriteRegister(MACREGISTER.FM13DT160_READWRITELENPAR, (uint)size);

			_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.CUSTOMMFM13DTREADMEMORY), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_READMEMORY);
		}

		void FM13DT160_WriteMemory(uint offset, byte [] data)
		{
			UInt32 value = (UInt32)((data[0] << 24) | (data[1] << 16) | (data[2] << 8) | data[3]);

			MacWriteRegister(MACREGISTER.FM13DT160_STARTADDRPAR, (uint)offset);
			MacWriteRegister(MACREGISTER.FM13DT160_DATAPAR, value);

			_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.CUSTOMMFM13DTWRITEMEMORY), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_WRITEMEMORY);
		}

		/// <summary>
		/// mode = user, unlock, stop logging
		/// </summary>
		/// <param name="mode"></param>
		/// <param name="password"></param>
		/// <returns></returns>
		void FM13DT160_Auth(uint mode, uint password)
		{
			MacWriteRegister(MACREGISTER.FM13DT160_CMDCFGPAR, (uint)mode);
			MacWriteRegister(MACREGISTER.FM13DT160_PWDPAR, password);

			_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.CUSTOMMFM13DTAUTH), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_AUTH);
		}

		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		void FM13DT160_GetTemp(int mode, int flag, uint storeto)
		{
			uint value = (uint)(0x80 | (flag = 0x04) | (flag = 0x02) | (flag = 0x01));

			MacWriteRegister(MACREGISTER.FM13DT160_CMDCFGPAR, value);
			MacWriteRegister(MACREGISTER.FM13DT160_READWRITELENPAR, storeto);
			
			_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.CUSTOMMFM13DTGETTEMP), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_GETTEMP);
		}

		void FM13DT160_StartLog()
		{
			MacWriteRegister(MACREGISTER.FM13DT160_CMDCFGPAR, 0x00);

			_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.CUSTOMMFM13DTSTARTLOG), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_STARTLOG);

		}

		void FM13DT160_StopLog(uint password)
		{
			MacWriteRegister(MACREGISTER.FM13DT160_CMDCFGPAR, 0x50);
			MacWriteRegister(MACREGISTER.FM13DT160_PWDPAR, password);

			_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.CUSTOMMFM13DTSTOPLOG), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_STOPLOG);
		}

		void FM13DT160_WriteReg(int offset, int value)
		{
			MacWriteRegister(MACREGISTER.FM13DT160_REGADDRPAR, (uint)offset);
			MacWriteRegister(MACREGISTER.FM13DT160_WRITEPAR, (uint)value);

			_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.CUSTOMMFM13DTWRITEREG), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_WRITEREGISTER);
		}

		void FM13DT160_ReadReg(int offset)
		{
			MacWriteRegister(MACREGISTER.FM13DT160_REGADDRPAR, (uint)offset);

			_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.CUSTOMMFM13DTREADREG), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_READREGISTER);
		}

		void FM13DT160_DeepSleep(bool enable)
		{
			MacWriteRegister(MACREGISTER.FM13DT160_CMDCFGPAR, enable ? 1U : 0U);

			_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.CUSTOMMFM13DTDEEPSLEEP), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_DEEPSLEEP);
		}

		void FM13DT160_OpModeChk(bool enable)
		{
			uint value = 0;

			if (enable)
				value = 0x01;

			MacWriteRegister(MACREGISTER.FM13DT160_CMDCFGPAR, value);

			_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.CUSTOMMFM13DTOPMODECHK), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1, (uint)CSLibrary.Constants.Operation.FM13DT_OPMODECHK);
		}

		void FM13DT160_InitialRegFile()
		{
			_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.CUSTOMMFM13DTINITIALREGFILE), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_COMMANDENDRESPONSE, (uint)CSLibrary.Constants.Operation.FM13DT_INITIALREGFILE);
		}

		void FM13DT160_LedCtrl(bool enable)
		{
			uint value = 0;

			if (enable)
				value = 0x02;

			MacWriteRegister(MACREGISTER.FM13DT160_CMDCFGPAR, value);

			_deviceHandler.SendAsync(0, 0, DOWNLINKCMD.RFIDCMD, PacketData(0xf000, (UInt32)HST_CMD.CUSTOMMFM13DTLEDCTRL), HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE_DATA1, (uint)CSLibrary.Constants.Operation.FM13DT_LEDCTRL);
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="TagAccessPacket"></param>
		/// <returns></returns>
		bool FM13DT160_TagAccessProc (CSLibrary.Constants.Operation operation, byte[] TagAccessPacket)
		{
			switch (operation)
			{
				case CSLibrary.Constants.Operation.FM13DT_AUTH:
					
					break;

				case CSLibrary.Constants.Operation.FM13DT_DEEPSLEEP:
					break;

				case CSLibrary.Constants.Operation.FM13DT_GETTEMP:
					{
						int returnvalue = (TagAccessPacket[TagAccessPacket.Length - 4] << 8) | TagAccessPacket[TagAccessPacket.Length - 3];

						switch (returnvalue)
						{
							case 0x0f:
								break;

							case 0xfffa: // 
								return true;

							case 0xfff5: // 
								return true;

							case 0xfff0: // 
								return true;
						}
					}
					break;

				case CSLibrary.Constants.Operation.FM13DT_INITIALREGFILE:
					{
						var returnvalue = TagAccessPacket[TagAccessPacket.Length - 4];
						if (TagAccessPacket[TagAccessPacket.Length - 4] != 00 || TagAccessPacket[TagAccessPacket.Length - 3] != 00)
							break;
					}
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_LEDCTRL:
					{
						var returnvalue = TagAccessPacket[TagAccessPacket.Length - 4];
					}
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_OPMODECHK:
					{
/*
						result[15:14]= 00 RFU
						result[13]= 1 user_access_en
						result[12]= 0 RTC loggingrtc
						result[11]= 0 vdet_process_flag
						result[10]= 0 RFU
						result[9]= 0 light_chk_flag
						result[8]= 1 vbat_pwr_flag0.9V

						result[7:4]= 0000 RFU
						result[3:0]: = 0001 RFU
*/
						var returnvalue = TagAccessPacket[TagAccessPacket.Length - 4];

						m_rdr_opt_parms.FM13DTOpModeChk.user_access_en = (returnvalue >> 5 & 0x01) != 0;
						m_rdr_opt_parms.FM13DTOpModeChk.RTC_logging = (returnvalue >> 4 & 0x01) != 0;
						m_rdr_opt_parms.FM13DTOpModeChk.vdet_process_flag = (returnvalue >> 3 & 0x01) != 0;
						m_rdr_opt_parms.FM13DTOpModeChk.light_chk_flag = (returnvalue >> 1 & 0x01) != 0;
						m_rdr_opt_parms.FM13DTOpModeChk.vbat_pwr_flag = (returnvalue & 0x01) != 0;
					}
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_READMEMORY:
					{
						if (TagAccessPacket.Length != (m_rdr_opt_parms.FM13DTReadMemory.count + 20))
							break;

						m_rdr_opt_parms.FM13DTReadMemory.data = new byte[m_rdr_opt_parms.FM13DTReadMemory.count];
						Buffer.BlockCopy(TagAccessPacket, 20, m_rdr_opt_parms.FM13DTReadMemory.data, 0, (int)(m_rdr_opt_parms.FM13DTReadMemory.count));
					}
					return true;
					break;

				case CSLibrary.Constants.Operation.FM13DT_READREGISTER:
					break;

				case CSLibrary.Constants.Operation.FM13DT_STARTLOG:
					break;

				case CSLibrary.Constants.Operation.FM13DT_STOPLOG:
					break;

				case CSLibrary.Constants.Operation.FM13DT_WRITEMEMORY:
					break;

				case CSLibrary.Constants.Operation.FM13DT_WRITEREGISTER:
					break;
			}

			return false;
		}

		int FM13DT160_CommandEnd(CSLibrary.Constants.Operation operation, bool success)
		{
			//if (OnFM13DTAccessCompleted == null)
			//	return 0;

			switch (operation)
			{
				case CSLibrary.Constants.Operation.FM13DT_AUTH:
					if (OnFM13DTAccessCompleted != null)
					OnFM13DTAccessCompleted(this, new OnFM13DTAccessCompletedEventArgs(FM13DTAccess.AUTH, success));
					break;

				case CSLibrary.Constants.Operation.FM13DT_DEEPSLEEP:
					if (OnFM13DTAccessCompleted != null)
						OnFM13DTAccessCompleted(this, new OnFM13DTAccessCompletedEventArgs(FM13DTAccess.DEEPSLEEP, success));
					break;

				case CSLibrary.Constants.Operation.FM13DT_GETTEMP:
					if (OnFM13DTAccessCompleted != null)
						OnFM13DTAccessCompleted(this, new OnFM13DTAccessCompletedEventArgs(FM13DTAccess.GETTEMP, success));
					break;

				case CSLibrary.Constants.Operation.FM13DT_INITIALREGFILE:
					if (OnFM13DTAccessCompleted != null)
						OnFM13DTAccessCompleted(this, new OnFM13DTAccessCompletedEventArgs(FM13DTAccess.INITIALREGFILE, success));
					break;

				case CSLibrary.Constants.Operation.FM13DT_LEDCTRL:
					if (OnFM13DTAccessCompleted != null)
						OnFM13DTAccessCompleted(this, new OnFM13DTAccessCompletedEventArgs(FM13DTAccess.LEDCTRL, success));
					break;

				case CSLibrary.Constants.Operation.FM13DT_OPMODECHK:
					if (OnFM13DTAccessCompleted != null)
						OnFM13DTAccessCompleted(this, new OnFM13DTAccessCompletedEventArgs(FM13DTAccess.OPMODECHK, success));
					break;

				case CSLibrary.Constants.Operation.FM13DT_READMEMORY:
					if (OnFM13DTAccessCompleted != null)
						OnFM13DTAccessCompleted(this, new OnFM13DTAccessCompletedEventArgs(FM13DTAccess.READMEMORY, success));
					break;

				case CSLibrary.Constants.Operation.FM13DT_READREGISTER:
					if (OnFM13DTAccessCompleted != null)
						OnFM13DTAccessCompleted(this, new OnFM13DTAccessCompletedEventArgs(FM13DTAccess.READREGISTER, success));
					break;

				case CSLibrary.Constants.Operation.FM13DT_STARTLOG:
					if (OnFM13DTAccessCompleted != null)
						OnFM13DTAccessCompleted(this, new OnFM13DTAccessCompletedEventArgs(FM13DTAccess.STARTLOG, success));
					break;

				case CSLibrary.Constants.Operation.FM13DT_STOPLOG:
					if (OnFM13DTAccessCompleted != null)
						OnFM13DTAccessCompleted(this, new OnFM13DTAccessCompletedEventArgs(FM13DTAccess.STOPLOG, success));
					break;

				case CSLibrary.Constants.Operation.FM13DT_WRITEMEMORY:
					if (OnFM13DTAccessCompleted != null)
						OnFM13DTAccessCompleted(this, new OnFM13DTAccessCompletedEventArgs(FM13DTAccess.WRITEMEMORY, success));
					break;

				case CSLibrary.Constants.Operation.FM13DT_WRITEREGISTER:
					if (OnFM13DTAccessCompleted != null)
						OnFM13DTAccessCompleted(this, new OnFM13DTAccessCompletedEventArgs(FM13DTAccess.WRITEREGISTER, success));
					break;

				default:
					return 0;
			}

			return 1;




			/*
			switch (operation)
			{
				case CSLibrary.Constants.Operation.FM13DT_OPMODECHK:
					break;
			}


						switch (operation)
						{
							case CSLibrary.Constants.Operation.FM13DT_READMEMORY:
								{
									FireFM13DTAccessCompletedEvent(
										new OnFM13DTAccessCompletedEventArgs(
										(((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
										FM13DTAccess.READMEMORY));
								}
								break;

							case CSLibrary.Constants.Operation.FM13DT_WRITEMEMORY:
								{
									CSLibrary.Debug.WriteLine("Tag lock end {0}", currentCommandResponse);

									FireAccessCompletedEvent(
										new OnAccessCompletedEventArgs(
										(((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
										Bank.UNKNOWN,
										TagAccess.LOCK,
										null));
								}
								break;

							case CSLibrary.Constants.Operation.FM13DT_READREGISTER:
								{
									CSLibrary.Debug.WriteLine("Tag lock end {0}", currentCommandResponse);

									FireAccessCompletedEvent(
										new OnAccessCompletedEventArgs(
										(((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
										Bank.UNKNOWN,
										TagAccess.LOCK,
										null));
								}
								break;

							case CSLibrary.Constants.Operation.FM13DT_WRITEREGISTER:
								{
									CSLibrary.Debug.WriteLine("Tag lock end {0}", currentCommandResponse);

									FireAccessCompletedEvent(
										new OnAccessCompletedEventArgs(
										(((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
										Bank.UNKNOWN,
										TagAccess.LOCK,
										null));
								}
								break;

							case CSLibrary.Constants.Operation.FM13DT_AUTH:
								{
									CSLibrary.Debug.WriteLine("Tag lock end {0}", currentCommandResponse);

									FireAccessCompletedEvent(
										new OnAccessCompletedEventArgs(
										(((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
										Bank.UNKNOWN,
										TagAccess.LOCK,
										null));
								}
								break;
							case CSLibrary.Constants.Operation.FM13DT_GETTEMP:
								{
									CSLibrary.Debug.WriteLine("Tag lock end {0}", currentCommandResponse);

									FireAccessCompletedEvent(
										new OnAccessCompletedEventArgs(
										(((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
										Bank.UNKNOWN,
										TagAccess.LOCK,
										null));
								}
								break;
							case CSLibrary.Constants.Operation.FM13DT_STARTLOG:
								{
									CSLibrary.Debug.WriteLine("Tag lock end {0}", currentCommandResponse);

									FireAccessCompletedEvent(
										new OnAccessCompletedEventArgs(
										(((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
										Bank.UNKNOWN,
										TagAccess.LOCK,
										null));
								}
								break;
							case CSLibrary.Constants.Operation.FM13DT_STOPLOG:
								{
									CSLibrary.Debug.WriteLine("Tag lock end {0}", currentCommandResponse);

									FireAccessCompletedEvent(
										new OnAccessCompletedEventArgs(
										(((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
										Bank.UNKNOWN,
										TagAccess.LOCK,
										null));
								}
								break;
							case CSLibrary.Constants.Operation.FM13DT_DEEPSLEEP:
								{
									CSLibrary.Debug.WriteLine("Tag lock end {0}", currentCommandResponse);

									FireAccessCompletedEvent(
										new OnAccessCompletedEventArgs(
										(((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
										Bank.UNKNOWN,
										TagAccess.LOCK,
										null));
								}
								break;
							case CSLibrary.Constants.Operation.FM13DT_OPMODECHK:
								{
									FireAccessCompletedEvent(
										new OnFM13DTAccessCompletedEventArgs(
											FM13DTAccess.OPMODECHK, 
											(((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) == 0
									)));
								}
								break;
							case CSLibrary.Constants.Operation.FM13DT_INITIALREGFILE:
								{
									CSLibrary.Debug.WriteLine("Tag lock end {0}", currentCommandResponse);

									FireAccessCompletedEvent(
										new OnAccessCompletedEventArgs(
										(((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
										Bank.UNKNOWN,
										TagAccess.LOCK,
										null));
								}
								break;
							case CSLibrary.Constants.Operation.FM13DT_LEDCTRL:
								{
									CSLibrary.Debug.WriteLine("Tag lock end {0}", currentCommandResponse);

									FireAccessCompletedEvent(
										new OnAccessCompletedEventArgs(
										(((currentCommandResponse | result) & HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.DATA1) != 0),
										Bank.UNKNOWN,
										TagAccess.LOCK,
										null));
								}
								break;
						}
			*/
			return -1;
		}



#if nouse
		bool FM13DT160_GetTemp()
		{
/*
			set 117 = 0
			call 5c
			set 119 = 0
			set 1108 = c012
			call 59
			set 117 = 6
			call 56
			set 117 = 86
			call 56
*/
			FM13DT160_OpModeChk(false);
			FM13DT160_WriteReg(0xc012, 0);

			FM13DT160_GetTemp(int mode, int flag, int storeto); // 0x06
			FM13DT160_GetTemp(int mode, int flag, int storeto); // 0x86
		}

		bool FM13DT160_GetBat()
		{
			/*
			117 = 0
			call 5c
			119 = 08
			118 = c012
			call 59
			117 = 12
			call 56
			117 = 92
			call 56 */

			FM13DT160_OpModeChk(false);
			FM13DT160_WriteReg(0xc012, 0x08);

			FM13DT160_GetTemp(int mode, int flag, int storeto); // 0x12
			FM13DT160_GetTemp(int mode, int flag, int storeto); // 0x92
		}

		bool FM13DT160_StartLog()
		{
			/*
			117 = 0
			call 5c
			11c = b040
			11d = 0004
			11e = 4cb329d6
			call 54
			11c = b094
			11d = 0004
			11e = 03000000 --
			call 54
			11c = b0a4
			11d = 0004
			11e = 0a000100
			call 54
			118 = c084
			119 = 01     --
			call 59
			line 3638344
			118 = c085
			119 = 0014   --
			call 59
			118 = c099
			119 = 0
			call 59
			118 = c098
			119 = 00000100
			call 59
			117 = 0
			call 57
			118 = c084
			call 5a */

			FM13DT160_OpModeChk(false);
			FM13DT160_WriteMemory(0xb040, 4, 0x4cb329d6);
			FM13DT160_WriteMemory(0xb094, 4, 0x03);
			FM13DT160_WriteMemory(0xb0a4, 4, 0x0a000100);
			FM13DT160_WriteReg(0xc084, 0x1);
			FM13DT160_WriteReg(0xc085, 0x14);
			FM13DT160_WriteReg(0xc099, 0);
			FM13DT160_WriteReg(0xc098, 0x100);
			FM13DT160_StartLog();
			FM13DT160_ReadReg(0xc084);
		}
#endif






	}
}
</file>

<file path="Library/CSLibrary/Source/SiliconLabIC/ClassEvent.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary
{
    public partial class SiliconLabIC
    {
        public class Constants
        {
            /// <summary>
            /// SiliconLab IC Callback Type
            /// </summary>
            public enum AccessCompletedCallbackType
            {
                SERIALNUMBER,
                UNKNOWN
            }
        }

        public class Events
        {
            public class OnAccessCompletedEventArgs : EventArgs
            {
                public readonly object info;
                public readonly Constants.AccessCompletedCallbackType type = Constants.AccessCompletedCallbackType.UNKNOWN;

                public OnAccessCompletedEventArgs(object info, Constants.AccessCompletedCallbackType type)
                {
                    this.info = info;
                    this.type = type;
                }
            }
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/SiliconLabIC/ClassSiliconLabIC.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Xml.Schema;
using CSLibrary.Barcode;
using CSLibrary.Barcode.Constants;
using CSLibrary.Barcode.Structures;

namespace CSLibrary
{
    public partial class SiliconLabIC
    {
        public event EventHandler<CSLibrary.SiliconLabIC.Events.OnAccessCompletedEventArgs> OnAccessCompleted;

        uint _firmwareVersion;
        public bool _firmwareOlderT108 = false;
        string _serailNumber = null;
        string _PcbVersion;
        string _Model;


        // RFID event code
        private class DOWNLINKCMD
		{
			public static readonly byte[] GETVERSION = { 0xB0, 0x00 };
            public static readonly byte[] GETSERIALNUMBER = { 0xB0, 0x04 };

            // for CS710S only
            public static readonly byte[] GETMODEL = { 0xB0, 0x06 };
            public static readonly byte[] RESETATMEL = { 0xB0, 0x0C };
        }

        private HighLevelInterface _deviceHandler;

        internal SiliconLabIC(HighLevelInterface handler)
		{
			_deviceHandler = handler;
        }

        internal void Connect (CSLibrary.RFIDDEVICE.MODEL model)
        {
            //internal void GetVersion()
            //{
            _deviceHandler.SendAsync(0, 3, DOWNLINKCMD.GETVERSION, null, HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
            //}

            //internal void GetSerialNumber()
            //{
            _deviceHandler.SendAsync(0, 3, DOWNLINKCMD.GETSERIALNUMBER, new byte[1], HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
            //}

            if (model == RFIDDEVICE.MODEL.CS710S)
                _deviceHandler.SendAsync(0, 3, DOWNLINKCMD.GETMODEL, new byte[1], HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.WAIT_BTAPIRESPONSE);
        }

        internal HighLevelInterface.BTWAITCOMMANDRESPONSETYPE ProcessDataPacket (byte [] data)
        {
            uint pktType = (uint)(data[8] << 8 | data[9]);

            switch (pktType)
            {
                case 0xb000:    // version
                    if (data[2] == 0x03) // for CS463
                    {
                        _firmwareVersion = 0;
                        _firmwareOlderT108 = false;
                        return HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE;
                    }

                    _firmwareVersion = (uint)((data[10] << 16) | (data[11] << 8) | (data[12]));
                    if (_firmwareVersion < 0x00010008)
                        _firmwareOlderT108 = true;
                    return HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE;

                case 0xb004:    // serial number
                                //_serailNumber = System.Text.Encoding.UTF8.GetString(data, 10, 13);
                                //_PcbVersion = (uint)(((data[23] - 0x30) << 16) | ((data[24] - 0x30) << 8) | (data[25] - 0x30));
                                //_PcbVersion = (uint)(((((data[23] & 0x0f) << 8) * 10) + ((data[24] &0x0f) << 8)) | (data[25] - 0x30));
                    try
                    {
                        _serailNumber = System.Text.Encoding.UTF8.GetString(data, 10, 16);
                    }
                    catch (Exception ex)
                    {
                        _serailNumber = "";

                    }

                    try
                    {
                        if (data[25] == 0x00)
                            data[25] = 0x30;
                        else if (data[23] == 0x30)
                        {
                            data[23] = data[24];
                            data[24] = data[25];
                            data[25] = 0x30;
                        }

                        _PcbVersion = System.Text.Encoding.UTF8.GetString(data, 23, 3);
                    }
                    catch (Exception ex)
                    {
                        _PcbVersion = "";
                    }
                    return HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE;

                case 0xb006:    // get CS710S model
                    try
                    {
                        _Model = System.Text.Encoding.UTF8.GetString(data, 10, 32);
                    }
                    catch (Exception ex)
                    {
                        _Model = "";
                    }
                    return HighLevelInterface.BTWAITCOMMANDRESPONSETYPE.BTAPIRESPONSE;
            }

            return 0;
        }

        public UInt32 GetFirmwareVersion ()
        {
            return _firmwareVersion;
        }

        public void GetSerialNumber()
        {
            if (OnAccessCompleted != null)
            {
                try
                {
                    Events.OnAccessCompletedEventArgs args = new Events.OnAccessCompletedEventArgs(_serailNumber, Constants.AccessCompletedCallbackType.SERIALNUMBER);

                    OnAccessCompleted(this, args);
                }
                catch (Exception ex)
                {
                }
            }
        }

        public string GetSerialNumberSync()
        {
            return _serailNumber;
        }

        public string GetPCBVersion ()
        {
            return _PcbVersion;
        }

        public void ClearEventHandler()
        {
            OnAccessCompleted = delegate { };
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/SystemInformation/ClassCountryInformation.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace CSLibrary
{
    using static FrequencyBand;

    public static class DEVICE
    {
        class COUNTRY
        {
            public int countryCode;
            public int specialCountryCode;
            public string countryName;
            public RegionCode defaultRegion;     // for old API

            public COUNTRY (int countryCode, int specialCountryCode, string countryName, RegionCode defaultRegion)
            {
                this.countryCode = countryCode;
                this.specialCountryCode = specialCountryCode;
                this.countryName = countryName;
                this.defaultRegion = defaultRegion;
            }
        }

        static List<COUNTRY> country;

        static DEVICE ()
        {
            country = new List<COUNTRY>();

            country.Add(new COUNTRY(1, 0x0, "", RegionCode.ETSI));
            country.Add(new COUNTRY(2, 0x0, "", RegionCode.FCC));
            country.Add(new COUNTRY(2, 0x2A2A5257, " RW", RegionCode.FCC));
            country.Add(new COUNTRY(2, 0x4F464341, " OFCA", RegionCode.HK));
            country.Add(new COUNTRY(2, 0x2A2A4153, " AS", RegionCode.AU));
            country.Add(new COUNTRY(2, 0x2A2A4E5A, " NZ", RegionCode.NZ));
            country.Add(new COUNTRY(2, 0x20937846, " ZA", RegionCode.ZA));
            country.Add(new COUNTRY(2, 0x2A2A5347, " SG", RegionCode.SG));
            country.Add(new COUNTRY(2, 0x2A2A5448, " TH", RegionCode.TH));
            country.Add(new COUNTRY(4, 0x0, "", RegionCode.TW));
            country.Add(new COUNTRY(6, 0x0, "", RegionCode.KR));
            country.Add(new COUNTRY(7, 0x0, "", RegionCode.CN));
            country.Add(new COUNTRY(8, 0x0, " JP4", RegionCode.JP));
            country.Add(new COUNTRY(8, 0x2A4A5036, " JP6", RegionCode.JP));
            country.Add(new COUNTRY(9, 0x0, "", RegionCode.ETSIUPPERBAND));
        }

        public static string GetModelName (int countryCode, int specialCountryCode)
        {
            foreach (var i in country)
                if (i.countryCode == countryCode && i.specialCountryCode == specialCountryCode)
                    return ("-" + countryCode.ToString() + i.countryName);

            throw new ArgumentOutOfRangeException("Country not found.");
        }

        // for old API
        public static RegionCode GetDefauleRegion(int countryCode, int specialCountryCode)
        {
            foreach (var i in country)
                if (i.countryCode == countryCode && i.specialCountryCode == specialCountryCode)
                    return (i.defaultRegion);

            return RegionCode.UNKNOWN;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/SystemInformation/ClassDeviceInformation.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace CSLibrary
{
    using Constants;

    public static class RFIDDEVICE
    {
        /// <summary>
        /// CSL RFID Reader model (OEM model code)
        /// </summary>
        public enum MODEL
        {
            CS101 = 0,
            CS203 = 1,
            CS333 = 2,
            CS468 = 3,
            CS468INT = 5,
            CS463 = 6,
            CS469 = 7,
            CS208 = 8,
            CS209 = 9,
            CS103 = 10,
            CS108 = 11,
            CS206 = 12,
            CS468X = 13,
            CS203X = 14,
            CS468XJ = 15,
            CS710S = 16,
            UNKNOWN = 0xff
        }

        public class HARDWARECONFIGURATION
        {
            public MODEL model;
            public int totalAntenna;
            internal int firstAntenna;

            public HARDWARECONFIGURATION (MODEL model, int totalAntenna, int firstAntenna)
            {
                this.model = model;
                this.totalAntenna = totalAntenna;
                this.firstAntenna = firstAntenna;
            }
        }

        public static List<HARDWARECONFIGURATION> info;

        static RFIDDEVICE()
        {
            info = new List<HARDWARECONFIGURATION>();

            info.Add(new HARDWARECONFIGURATION(MODEL.CS108, 1, 0));
            info.Add(new HARDWARECONFIGURATION(MODEL.CS203, 2, 3));
            info.Add(new HARDWARECONFIGURATION(MODEL.CS463, 4, 0));
            info.Add(new HARDWARECONFIGURATION(MODEL.CS710S, 1, 0));
        }

        public static int GetTotalAntenna(MODEL model)
        {
            return ((info.Find(item => item.model == model)).totalAntenna);
        }

        public static int GetfirstAntenna(MODEL model)
        {
            return ((info.Find(item => item.model == model)).firstAntenna);
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/SystemInformation/ClassFrequencyBandInformation.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace CSLibrary
{
    using static RFIDDEVICE;
    using Constants;
    using System.Threading;
    using static CSLibrary.FrequencyBand;
    using static CSLibrary.RFIDDEVICE;

    public static class FrequencyBand
    {
        /// <summary>
        /// Region Profile
        /// </summary>
        public enum RegionCode
        {
            /// <summary>
            /// USA
            /// </summary>
            FCC = 1,
            /// <summary>
            /// Europe
            /// </summary>
            ETSI,
            /// <summary>
            /// China all frequency
            /// </summary>
            CN,
            /// <summary>
            /// Taiwan
            /// </summary>
            TW,
            /// <summary>
            /// Korea
            /// </summary>
            KR,
            /// <summary>
            /// Hong Kong
            /// </summary>
            HK,
            /// <summary>
            /// Japan
            /// </summary>
            JP,
            /// <summary>
            /// Australia
            /// </summary>
            AU,
            /// <summary>
            /// Malaysia
            /// </summary>
            MY,
            /// <summary>
            /// Singapore
            /// </summary>
            SG,
            /// <summary>
            /// India
            /// </summary>
            IN,
            /// <summary>
            /// G800 same as India
            /// </summary>
            G800,
            /// <summary>
            /// South Africa
            /// </summary>
            ZA,
            //New added
            /// <summary>
            /// Brazil
            /// </summary>
            BR1,
            /// <summary>
            /// Brazil
            /// </summary>
            BR2,
            /// <summary>
            /// Brazil
            /// </summary>
            BR3,
            /// <summary>
            /// Brazil
            /// </summary>
            BR4,
            /// <summary>
            /// Brazil
            /// </summary>
            BR5,
            /// <summary>
            /// Indonesia 
            /// </summary>
            ID,
            /// <summary>
            /// Thailand
            /// </summary>
            TH,
            /// <summary>
            /// Israel
            /// </summary>
            JE,
            /// <summary>
            /// Philippine
            /// </summary>
            PH,
            /// <summary>
            /// ETSI Upper Band
            /// </summary>
            ETSIUPPERBAND,
            /// <summary>
            /// New Zealand
            /// </summary>
            NZ,
            /// <summary>
            /// UH1
            /// </summary>
            UH1,
            /// <summary>
            /// UH2
            /// </summary>
            UH2,
            /// <summary>
            /// LH
            /// </summary>
            LH,
            /// <summary>
            /// LH
            /// </summary>
            LH1,
            /// <summary>
            /// LH
            /// </summary>
            LH2,
            /// <summary>
            /// Venezuela
            /// </summary>
            VE,
            /// <summary>
            /// Argentina
            /// </summary>
            AR,
            /// Chile
            CL,
            /// <summary>
            /// Colombia
            /// </summary>
            CO,
            /// <summary>
            /// Costa Rica??? ????????
            /// </summary>
            CR,
            /// <summary>
            /// Dominican Republic
            /// </summary>
            DO,
            /// <summary>
            /// Panama
            /// </summary>
            PA,
            /// <summary>
            /// Peru
            /// </summary>
            PE,
            /// <summary>
            /// Uruguay
            /// </summary>
            UY,
            /// <summary>
            /// Bangladesh
            /// </summary>
            BA,
            /// <summary>
            /// Vietnam
            /// </summary>
            VI,
            /// <summary>
            /// Unknow Country
            /// </summary>
            UNKNOWN = 0,
            /// <summary>
            /// Current Country
            /// </summary>
            CURRENT = -1
        }

        public class FREQUENCYSET
        {
            public RegionCode code;
            public string name;
            public int year;
            public bool hopping;

            public FREQUENCYSET(RegionCode code, string name, int year, bool hopping)
            {
                this.code = code; // RegionCode
                this.name = name;
                this.year = year;
                this.hopping = hopping;
            }

        }

        public static List<FREQUENCYSET> frequencySet;
        static List<RegionCode> m_save_country_list;

        static FrequencyBand()
        {
            frequencySet = new List<FREQUENCYSET>();

            frequencySet.Add(new FREQUENCYSET(RegionCode.FCC, "USA/Canada", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.ETSI, "Europe", 0, false));
            frequencySet.Add(new FREQUENCYSET(RegionCode.CN, "China", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.TW, "Taiwan", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.KR, "Korea", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.HK, "Hong Kong", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.JP, "Japan", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.AU, "Australia", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.MY, "Malaysia", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.SG, "Singapore", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.IN, "India", 0, false));
            frequencySet.Add(new FREQUENCYSET(RegionCode.G800, "G800", 0, false));
            frequencySet.Add(new FREQUENCYSET(RegionCode.ZA, "South Africa", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.BR1, "Brazil 915-927", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.BR2, "Brazil 902-906, 915-927", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.BR3, "Brazil 902-906", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.BR4, "Brazil 902-904", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.BR5, "Brazil 917-924", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.ID, "Indonesia", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.TH, "Thailand", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.JE, "Israel", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.PH, "Philippine", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.ETSIUPPERBAND, "ETSI Upper Band", 0, false));
            frequencySet.Add(new FREQUENCYSET(RegionCode.NZ, "New Zealand", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.UH1, "UH1", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.UH2, "UH2", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.LH, "LH", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.LH1, "LH1", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.LH2, "LH2", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.VE, "Venezuela", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.AR, "Argentina", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.CL, "Chile", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.CO, "Colombia", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.CR, "Costa Rica", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.DO, "Dominican Republic", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.PA, "Panama", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.PE, "Peru", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.UY, "Uruguay", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.BA, "Bangladesh", 0, true));
            frequencySet.Add(new FREQUENCYSET(RegionCode.VI, "Vietnam", 0, true));
        }

        public static RegionCode GetRegionCode(string name)
        {
            foreach (var i in frequencySet)
                if (i.name == name)
                    return i.code;

            return RegionCode.UNKNOWN;
            //return ((frequencySet.Find(item => item.name == name)).code);
        }

        public static string GetRegionName(RegionCode code)
        {
            foreach (var i in frequencySet)
                if (i.code == code)
                    return i.name;

            return null;
            //return ((frequencySet.Find(item => item.code == code)).name);
        }

        public static bool HoppingAvalibable(RegionCode code)
        {
            foreach (var i in frequencySet)
                if (i.code == code)
                    return i.hopping;

            return false;
            //return ((frequencySet.Find(item => item.code == code)).hopping);
        }

        public static RegionCode[] GetRegionCodeList()
        {
            RegionCode[] list = new RegionCode[frequencySet.Count];

            for (int cnt = 0; cnt < list.Length; cnt++)
                list[cnt] = frequencySet[cnt].code;

            return list;
        }

        public static string[] GetRegionNameList()
        {
            string[] list = new string[frequencySet.Count];

            for (int cnt = 0; cnt < frequencySet.Count; cnt++)
                list[cnt] = frequencySet[cnt].name;

            return list;
        }

        public static string[] GetRegionNameList(RegionCode[] code)
        {
            string[] list = new string[code.Length];

            for (int cnt = 0; cnt < code.Length; cnt++)
                list[cnt] = GetRegionName(code[cnt]);

            return list;
        }

        public static string[] GetRegionNameList(List <RegionCode> code)
        {
            string[] list = new string[code.Count];

            for (int cnt = 0; cnt < code.Count; cnt++)
                list[cnt] = GetRegionName(code[cnt]);

            return list;
        }
    }
    
    public static class FrequencyBand_CS710S
    {
        public class FREQUENCYSET
        {
            public int index;                  // CSL E710 Country Enum
            public string name;                // CSL E710 Country Name
            public string modelCode;           // CSL Reader Model Code(Region Code)
            public int totalFrequencyChannel;  // Frequency Channel #
            public string hopping;             // Fixed or Hop
            public int onTime;                 // Hop Time or On Time
            public int offTime;                // Off Time
            public int channelSepatration;     // Channel separation
            public double firstChannel;        // First Channel
            public double lastChannel;         // Last Channel
            public string note;                // Note

            public FREQUENCYSET(int index, string name, string modelCode, int totalFrequencyChannel, string hopping, int onTime, int offTime, int channelSepatration, double firstChannel, double lastChannel, string note)
            {
                this.index = index;
                this.name = name;
                this.modelCode = modelCode;
                this.totalFrequencyChannel = totalFrequencyChannel;
                this.hopping = hopping;
                this.onTime = onTime;
                this.offTime = offTime;
                this.channelSepatration = channelSepatration;
                this.firstChannel = firstChannel;
                this.lastChannel = lastChannel;
                this.note = note;
            }
        }

        public static List<FREQUENCYSET> frequencySet;
        static List<RegionCode> m_save_country_list;

        static FrequencyBand_CS710S()
        {
            frequencySet = new List<FREQUENCYSET>();

            frequencySet.Add(new FREQUENCYSET(0, "UNKNOW", "", 0, "", 0, 0, 0, 0, 0, ""));
            frequencySet.Add(new FREQUENCYSET(1, "Albania1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(2, "Albania2", "-2 RW"       , 23, "Hop", 400, -1, 250, 915.25, 920.75, "915-921"));
            frequencySet.Add(new FREQUENCYSET(3, "Algeria1", "-1"          , 4, "Fixed", 3900, 100, 600, 871.6, 873.4, "870-876"));
            frequencySet.Add(new FREQUENCYSET(4, "Algeria2", "-1"          , 4, "Fixed", 3900, 100, 600, 881.6, 883.4, "880-885"));
            frequencySet.Add(new FREQUENCYSET(5, "Algeria3", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, "915-921"));
            frequencySet.Add(new FREQUENCYSET(6, "Algeria4", "-7"          , 2, "Fixed", 3900, 100, 500, 925.25, 925.75, "925-926"));
            frequencySet.Add(new FREQUENCYSET(7, "Argentina", "-2 RW"       , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(8, "Armenia", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(9, "Australia1", "-2 AS"        , 10, "Hop", 400, -1, 500, 920.75, 925.25, ""));
            frequencySet.Add(new FREQUENCYSET(10, "Australia2", "-2 AS"        , 14, "Hop", 400, -1, 500, 918.75, 925.25, ""));
            frequencySet.Add(new FREQUENCYSET(11, "Austria1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(12, "Austria2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(13, "Azerbaijan", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(14, "Bahrain", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(15, "Bangladesh", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(16, "Belarus", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(17, "Belgium1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(18, "Belgium2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(19, "Bolivia", "-2"          , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(20, "Bosnia", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(21, "Botswana", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(22, "Brazil1", "-2 RW"       , 9, "Fixed", 3900, 100, 500, 902.75, 906.75, ""));
            frequencySet.Add(new FREQUENCYSET(23, "Brazil2", "-2 RW"       , 24, "Fixed", 3900, 100, 500, 915.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(24, "Brunei1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(25, "Brunei2", "-7"          , 7, "Fixed", 3900, 100, 250, 923.25, 924.75, "923 - 925"));
            frequencySet.Add(new FREQUENCYSET(26, "Bulgaria1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(27, "Bulgaria2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(28, "Cambodia", "-7"          , 16, "Hop", 400, -1, 250, 920.625, 924.375, ""));
            frequencySet.Add(new FREQUENCYSET(29, "Cameroon", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(30, "Canada", "-2"          , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(31, "Chile1", "-2 RW"       , 3, "Fixed", 3900, 100, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(32, "Chile2", "-2 RW"       , 24, "Hop", 400, -1, 500, 915.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(33, "Chile3", "-2 RW"       , 4, "Hop", 400, -1, 500, 925.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(34, "China", "-7"          , 16, "Hop", 2000, -1, 250, 920.625, 924.375, ""));
            frequencySet.Add(new FREQUENCYSET(35, "Colombia", "-2 RW"       , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(36, "Congo", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(37, "CostaRica", "-2 RW"       , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(38, "Cotedlvoire", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(39, "Croatia", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(40, "Cuba", "-2 RW"       , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(41, "Cyprus1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(42, "Cyprus2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(43, "Czech1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(44, "Czech2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(45, "Denmark1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(46, "Denmark2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(47, "Dominican", "-2 RW"       , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(48, "Ecuador", "-2 RW"       , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(49, "Egypt", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(50, "ElSalvador", "-2 RW"       , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(51, "Estonia", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(52, "Finland1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(53, "Finland2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(54, "France", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(55, "Georgia", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(56, "Germany", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(57, "Ghana", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(58, "Greece", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(59, "Guatemala", "-2 RW"       , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(60, "HongKong1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(61, "HongKong2", "-2 OFCA", 50, "Hop", 400, -1, 50,  921.25 , 923.7, ""));
            frequencySet.Add(new FREQUENCYSET(62, "Hungary1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(63, "Hungary2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(64, "Iceland", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(65, "India", "-1"          , 3, "Fixed", 3900, 100, 600, 865.7, 866.9, ""));
            frequencySet.Add(new FREQUENCYSET(66, "Indonesia", "-7"          , 4, "Hop", 400, -1, 500, 923.75, 924.25, ""));
            frequencySet.Add(new FREQUENCYSET(67, "Iran", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(68, "Ireland1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(69, "Ireland2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(70, "Israel", "-9"          , 3, "Fixed", 3900, -1, 500, 915.5, 916.5, ""));
            frequencySet.Add(new FREQUENCYSET(71, "Italy", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(72, "Jamaica", "-2 RW"       , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(73, "Japan4", "-8 JP4", 4, "Fixed", 3900, -1, 1200, 916.8, 920.4, ""));
            frequencySet.Add(new FREQUENCYSET(74, "Japan6", "-8 JP6", 6, "Fixed", 3900, 100, 1200, 916.8, 920.8, "Channel separation 200 KHz Last 2, LBT carrier sense with Transmission Time Control"));
            frequencySet.Add(new FREQUENCYSET(75, "Jordan", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(76, "Kazakhstan", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(77, "Kenya", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(78, "Korea", "-6	", 6, "Hop", 400, -1, 600, 917.3, 920.3, ""));
            frequencySet.Add(new FREQUENCYSET(79, "KoreaDPR", "-7"          , 16, "Hop", 400, -1, 250, 920.625, 924.375, ""));
            frequencySet.Add(new FREQUENCYSET(80, "Kuwait", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(81, "Kyrgyz", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(82, "Latvia", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(83, "Lebanon", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(84, "Libya", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(85, "Liechtenstein1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(86, "Liechtenstein2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(87, "Lithuania1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(88, "Lithuania2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(89, "Luxembourg1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(90, "Luxembourg2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(91, "Macao", "-7"          , 16, "Hop", 400, -1, 250, 920.625, 924.375, ""));
            frequencySet.Add(new FREQUENCYSET(92, "Macedonia", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(93, "Malaysia", "-7"          , 6, "Hop", 400, -1, 500, 919.75, 922.25, ""));
            frequencySet.Add(new FREQUENCYSET(94, "Malta1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(95, "Malta2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(96, "Mauritius", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(97, "Mexico", "-2"          , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(98, "Moldova1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(99, "Moldova2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(100, "Mongolia", "-7"          , 16, "Hop", 400, -1, 250, 920.625, 924.375, ""));
            frequencySet.Add(new FREQUENCYSET(101, "Montenegro", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(102, "Morocco", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(103, "Netherlands", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(104, "NewZealand1", "-1"          , 4, "Hop", 400, -1, 500, 864.75, 867.25, ""));
            frequencySet.Add(new FREQUENCYSET(105, "NewZealand2", "-2 NZ"   , 14, "Hop", 400, -1, 500, 920.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(106, "Nicaragua", "-2 RW"       , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(107, "Nigeria", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(108, "Norway1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(109, "Norway2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(110, "Oman", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(111, "Pakistan", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(112, "Panama", "-2 RW"       , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(113, "Paraguay", "-2 RW"       , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(114, "Peru", "-2 RW"       , 24, "Hop", 400, -1, 500, 915.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(115, "Philippines", "-2 RW"       , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(116, "Poland", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(117, "Portugal", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(118, "Romania", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(119, "Russia1", "-1"          , 4, "Fixed", 3900, 100, 600, 866.3, 867.5, "2 W ERP"));
            frequencySet.Add(new FREQUENCYSET(120, "Russia3", "-9"          , 4, "Fixed", 3900, -1, 1200, 915.6, 919.2, "1 W ERP"));
            frequencySet.Add(new FREQUENCYSET(121, "Senegal", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(122, "Serbia", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(123, "Singapore1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(124, "Singapore2", "-2 SG"    , 8, "Hop", 400, -1, 500, 920.75, 924.25, ""));
            frequencySet.Add(new FREQUENCYSET(125, "Slovak1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(126, "Slovak2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(127, "Slovenia1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(128, "Solvenia2", "-9"          , 3, "Fixed", 3900, 100, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(129, "SAfrica1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(130, "SAfrica2", "-9"          , 7, "Fixed", 400, -1, 500, 915.7, 918.7, "915.4-919"));
            frequencySet.Add(new FREQUENCYSET(131, "Spain", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(132, "SriLanka", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(133, "Sudan", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(134, "Sweden1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(135, "Sweden2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(136, "Switzerland1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(137, "Switzerland2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(138, "Syria", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(139, "Taiwan1", "-4"        , 12, "Hop", 400, -1, 375, 922.875, 927.000, "1 Watt ERP for Indoor"));
            frequencySet.Add(new FREQUENCYSET(140, "Taiwan2", "-4"        , 12, "Hop", 400, -1, 375, 922.875, 927.000, "0.5 Watt ERP for Outdoor"));
            frequencySet.Add(new FREQUENCYSET(141, "Tajikistan", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(142, "Tanzania", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(143, "Thailand", "-2 RW"       , 8, "Hop", 400, -1, 500, 920.75, 924.25, ""));
            frequencySet.Add(new FREQUENCYSET(144, "Trinidad", "-2 RW"       , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(145, "Tunisia", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(146, "Turkey", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(147, "Turkmenistan", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(148, "Uganda", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(149, "Ukraine", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(150, "UAE", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(151, "UK1", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(152, "UK2", "-9"          , 3, "Fixed", 3900, -1, 1200, 916.3, 918.7, ""));
            frequencySet.Add(new FREQUENCYSET(153, "USA", "-2"          , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(154, "Uruguay", "-2 RW"       , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(155, "Venezuela", "-2 RW"       , 50, "Hop", 400, -1, 500, 902.75, 927.25, ""));
            frequencySet.Add(new FREQUENCYSET(156, "Vietnam1", "-1"          , 4, "Fixed", 3900, 100, 600, 866.7, 868.5, "866-869"));
            frequencySet.Add(new FREQUENCYSET(157, "Vietnam2", "-7"          , 16, "Hop", 400, -1, 250, 920.625, 924.375, ""));
            frequencySet.Add(new FREQUENCYSET(158, "Yemen", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
            frequencySet.Add(new FREQUENCYSET(159, "Zimbabwe", "-1"          , 4, "Fixed", 3900, 100, 600, 865.7, 867.5, ""));
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/SystemInformation/CS710SErrorCode.cs">
using System.Collections.Generic;

namespace CSLibrary
{
    internal class ErrorCode
    {
        public int Code { get; set; }
        public string Description { get; set; }

        public ErrorCode(int code, string description)
        {
            Code = code;
            Description = description;
        }
    }

    public static class CS710SErrorCodes
    {
        private static List<ErrorCode> ErrorCodes;

        static CS710SErrorCodes()
        {
            ErrorCodes = new List<ErrorCode>
            {
                new ErrorCode(0x0001, "Tag cache table buffer is overflowed."),
                new ErrorCode(0x0002, "Wrong register address"),
                new ErrorCode(0x0003, "Register length too large"),
                new ErrorCode(0x0004, "E710 not powered up"),
                new ErrorCode(0x0005, "Invalid parameter"),
                new ErrorCode(0x0006, "Event fifo full"),
                new ErrorCode(0x0007, "TX not ramped up"),
                new ErrorCode(0x0008, "Register read only"),
                new ErrorCode(0x0009, "Failed to halt"),
                new ErrorCode(0x000A, "PLL not locked"),
                new ErrorCode(0x000B, "Power control target failed"),
                new ErrorCode(0x000C, "Radio power not enabled"),
                new ErrorCode(0x000D, "E710 command error (e.g. battery low)"),
                new ErrorCode(0x000E, "E710 Op timeout"),
                new ErrorCode(0x000F, "E710 Aggregate error (e.g. battery low, metal reflection)"),
                new ErrorCode(0x0010, "E710 hardware link error"),
                new ErrorCode(0x0011, "E710 event fail to send error"),
                new ErrorCode(0x0012, "E710 antenna error (e.g. metal reflection)"),
                new ErrorCode(0x00FF, "Other error (e.g. battery low)")
            };
        }

        public static string GetErrorDescription(int errorCode)
        {
            var error = ErrorCodes.Find(e => e.Code == errorCode);
            return error?.Description ?? "Other error";
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/Tools/ClassCRC16.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary.Tools
{
    #region BT CRC

    public static class Crc
    {
        static readonly ushort[] crc_lookup_table = new ushort[]{
                0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
                0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
                0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
                0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
                0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
                0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
                0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
                0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
                0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
                0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
                0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
                0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
                0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
                0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
                0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
                0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
                0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
                0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
                0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
                0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
                0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
                0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
                0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
                0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
                0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
                0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
                0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
                0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
                0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
                0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
                0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
                0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78};

        public static ushort ComputeChecksum(byte[] dataIn)
        {
            ushort checksum = 0;

            for (int i = 0; i < (dataIn[2] + 8); i++)
            {
                if (i != 6 && i != 7)
                {
                    int index = (checksum ^ ((byte)dataIn[i] & 0x0FF)) & 0x0FF;
                    checksum = (ushort)((checksum >> 8) ^ crc_lookup_table[index]);
                }
            }

            return checksum;
        }
    }

    #endregion

}
</file>

<file path="Library/CSLibrary/Source/Tools/ClassdBm2dBuV.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace CSLibrary.Tools
{
    public class dBConverion
    {
        // dBV=dBm+90+20log(Z0z0), z0 = 50
        // Tag RSSI(dBm) min -90 max -30, RSSI(dBuV) min 17 max 77

        public static float dBuV2dBm(float dBuV, int rounddec = -1)
        {
            return (float)dBuV2dBm((double)dBuV, rounddec);
        }

        public static float dBm2dBuV(float dBm, int rounddec = -1)
        {
            return (float)dBm2dBuV((double)dBm, rounddec);
        }

        public static double dBuV2dBm(double dBuV, int rounddec = -1)
        {
            double value = dBuV - 106.9897;
            if (rounddec < 0)
                return value;

            return Math.Round(value, rounddec);
        }

        public static double dBm2dBuV(double dBm, int rounddec = -1)
        {
            double value = dBm + 106.9897;
            if (rounddec < 0)
                return value;

            return Math.Round(value, rounddec);
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/Tools/ClassFIFIQueue.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSLibrary.Tools
{
    public class Queue
    {
        private int MAXBUFFERSIZE;
        private byte[] _dataStream;
        object _dataStreamLock = new object();
        private int _dataStreamStartPoint = 0;
        private int _dataStreamSize = 0;

        public Queue(int size = 1024)
        {
            MAXBUFFERSIZE = size;
            _dataStream = new byte[MAXBUFFERSIZE];
        }

        ~Queue()
        {
        }

        public int length
        {
            get { return _dataStreamSize; }
        }

        public void Clear()
        {
            lock (_dataStreamLock)
            {
                _dataStreamStartPoint = 0;
                _dataStreamSize = 0;
            }
        }

        /// <summary>
        /// all data will be clear
        /// </summary>
        /// <param name="size"></param>
        /// <returns></returns>
        public bool ReSize(int size)
        {
            lock (_dataStreamLock)
            {
                try
                {
                    _dataStream = new byte[size];
                    _dataStreamStartPoint = 0;
                    _dataStreamSize = 0;
                }
                catch (Exception ex)
                {
                    return false;
                }
            }

            return true;
        }

        public bool DataIn(byte[] data, int offset = 0, int size = -1)
        {
			if (size < 0)
				size = data.Length - offset;

			if (size == 0)
				return true;

			if (_dataStreamSize + size > MAXBUFFERSIZE)
				return false;

			lock (_dataStreamLock)
			{
				if (_dataStreamStartPoint + _dataStreamSize + size < MAXBUFFERSIZE)
				{
					Array.Copy(data, offset, _dataStream, _dataStreamStartPoint + _dataStreamSize, size);
				}
				else if ((_dataStreamStartPoint + _dataStreamSize) >= MAXBUFFERSIZE)
                {
                    Array.Copy(data, offset, _dataStream, ((_dataStreamStartPoint + _dataStreamSize) - MAXBUFFERSIZE), size);
                }
                else
                {
					int headerLength = MAXBUFFERSIZE - _dataStreamStartPoint - _dataStreamSize;
					int footerlength = size - headerLength;

					Array.Copy(data, 0, _dataStream, _dataStreamStartPoint + _dataStreamSize, headerLength);
					Array.Copy(data, headerLength, _dataStream, 0, footerlength);
				}

				_dataStreamSize += size;
			}

			return true;
        }

#if !oldcode
		public bool DataDel(int dataDelectLength)
		{
			lock (_dataStreamLock)
			{
				if (_dataStreamSize == 0)
					return true;

				if (dataDelectLength > _dataStreamSize)
					return false;

				_dataStreamSize -= dataDelectLength;
				if (_dataStreamSize == 0)
				{
					_dataStreamStartPoint = 0;
				}
				else if (_dataStreamStartPoint + dataDelectLength < MAXBUFFERSIZE)
				{
					_dataStreamStartPoint += dataDelectLength;
				}
				else
				{
					_dataStreamStartPoint = dataDelectLength - (MAXBUFFERSIZE - _dataStreamStartPoint);
				}

				return true;
			}
		}
#else
		public bool DataDel(int dataDelectLength)
        {
			lock (_dataStreamLock)
			{
				if (_dataStreamSize == 0)
                    return true;

				if (dataDelectLength > _dataStreamSize)
					return false;

				if (_dataStreamStartPoint + dataDelectLength < MAXBUFFERSIZE)
				{
					_dataStreamStartPoint += dataDelectLength;
				}
				else
				{
					int headerLength = MAXBUFFERSIZE - _dataStreamStartPoint;
					int footerlength = dataDelectLength - headerLength;

					_dataStreamStartPoint = footerlength;
				}

				_dataStreamSize -= dataDelectLength;
				if (_dataStreamSize == 0)
					_dataStreamStartPoint = 0;

				return true;
			}
		}
#endif

		public byte[] DataPreOut(int outDataLength = 1)
		{
			lock (_dataStreamLock)
			{
				byte[] outData;

				if (_dataStreamSize == 0)
					return new byte[0];

				if (outDataLength < _dataStreamSize)
				{
					outData = new byte[outDataLength];
				}
				else
				{
					outData = new byte[_dataStreamSize];
				}

				if (_dataStreamStartPoint + outData.Length < MAXBUFFERSIZE)
				{
					Array.Copy(_dataStream, _dataStreamStartPoint, outData, 0, outData.Length);
				}
				else
				{
					int headerLength = MAXBUFFERSIZE - _dataStreamStartPoint;
					int footerlength = outData.Length - headerLength;

					Array.Copy(_dataStream, _dataStreamStartPoint, outData, 0, headerLength);
					Array.Copy(_dataStream, 0, outData, headerLength, footerlength);
				}

				return outData;
			}
		}

#if !oldcode
		public byte[] DataOut(int outDataLength = 1)
		{
			byte[] outData = DataPreOut (outDataLength);

			if (outData.Length != 0)
				DataDel(outData.Length);

			return outData;
		}
#else
		public byte[] DataOut(int outDataLength)
        {
            lock (_dataStreamLock)
            {
                byte[] outData;

                if (_dataStreamSize == 0)
                    return new byte[0];

                if (outDataLength < _dataStreamSize)
                {
                    outData = new byte[outDataLength];
                }
                else
                {
                    outData = new byte[_dataStreamSize];
                }

                if (_dataStreamStartPoint + outData.Length < MAXBUFFERSIZE)
                {
                    Array.Copy(_dataStream, _dataStreamStartPoint, outData, 0, outData.Length);

                    _dataStreamStartPoint += outData.Length;
                }
                else
                {
                    int headerLength = MAXBUFFERSIZE - _dataStreamStartPoint;
                    int footerlength = outData.Length - headerLength;

                    Array.Copy(_dataStream, _dataStreamStartPoint, outData, 0, headerLength);
                    Array.Copy(_dataStream, 0, outData, headerLength, footerlength);

                    _dataStreamStartPoint = footerlength;
                }

                _dataStreamSize -= outData.Length;
                if (_dataStreamSize == 0)
                    _dataStreamStartPoint = 0;

                return outData;
            }
        }
#endif

        /*
		private void Defragment()
        {
            if (_dataStreamStartPoint != 0 && _dataStreamSize != 0)
            {
                byte[] newStream = new byte[_dataStream.Length];
                int headerLength = MAXBUFFERSIZE - _dataStreamStartPoint;
                int footerlength = _dataStreamSize - headerLength;

                Array.Copy(_dataStream, _dataStreamStartPoint, newStream, 0, headerLength);
                Array.Copy(_dataStream, 0, newStream, headerLength, footerlength);

                _dataStream = newStream;
                _dataStreamStartPoint = 0;
            }
        }
        */

        private void Defragment()
        {
            try
            {
                if (_dataStreamStartPoint != 0 && _dataStreamSize != 0)
                {
                    if ((_dataStreamStartPoint + _dataStreamSize) > _dataStream.Length)
                    {
                        byte[] newStream = new byte[_dataStream.Length];
                        int headerLength = MAXBUFFERSIZE - _dataStreamStartPoint;
                        int footerlength = _dataStreamSize - headerLength;

                        Array.Copy(_dataStream, _dataStreamStartPoint, newStream, 0, headerLength);
                        Array.Copy(_dataStream, 0, newStream, headerLength, footerlength);

                        _dataStream = newStream;
                        _dataStreamStartPoint = 0;
                    }
                    else
                    {
                        byte[] newStream = new byte[_dataStream.Length];

                        Array.Copy(_dataStream, _dataStreamStartPoint, newStream, 0, _dataStreamSize);

                        _dataStream = newStream;
                        _dataStreamStartPoint = 0;
                    }
                }
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("Defragment Error : " + ex.Message);
            }
        }


        /// <summary>
        /// find data in array
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public int IndexOf (byte [] data)
        {
            if (data.Length > _dataStreamSize)
                return -1;

            lock (_dataStreamLock)
            {
                if (_dataStreamStartPoint + _dataStreamSize >= MAXBUFFERSIZE)
                    Defragment();

                return Array.IndexOf(_dataStream, data, _dataStreamStartPoint, _dataStreamSize);
            }
        }

        /// <summary>
        /// find data in array
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public int IndexOf(byte data)
        {
            lock (_dataStreamLock)
            {
                if (_dataStreamSize == 0)
                return -1;

                Defragment();
                return Array.IndexOf(_dataStream, data, 0, _dataStreamSize);
            }
        }

        /// <summary>
        /// Special function for Inventory
        /// </summary>
        /// <returns></returns>
        public int IndexOfValidInventoryResponsePacket()
        {
            return -1;
        }

        /// <summary>
        /// Special function for Inventory
        /// </summary>
        /// <returns></returns>
        public int IndexOfTagResponsePacket(int offSet = 0)
        {
            const int PKTVER = 0x03;
            const int PKTTYP1 = 0x05;
            const int PKTTYP2 = 0x80;
            const int PKTREV1 = 0x00;
            const int PKTREV2 = 0x00;

            int headerIndex;

            lock (_dataStreamLock)
            {
                if (_dataStreamSize < 8)
                return -1;

                Defragment();
                headerIndex = Array.IndexOf(_dataStream, PKTVER, offSet, _dataStreamSize);

                if (headerIndex >= 0)
                {
                    if (_dataStream[headerIndex + 2] == PKTTYP1 &&
                        _dataStream[headerIndex + 3] == PKTTYP2 &&
                        _dataStream[headerIndex + 6] == PKTREV1 &&
                        _dataStream[headerIndex + 7] == PKTREV2)
                        return headerIndex;
                }
            }

            return -1;
        }

        public void Skip(int skipSize)
        {
            lock (_dataStreamLock)
            {
                if (skipSize >= _dataStreamSize)
                {
                    Clear ();
                    return;
                }

                if (_dataStreamStartPoint + skipSize < MAXBUFFERSIZE)
                {
                    _dataStreamStartPoint += skipSize;
                }
                else
                {
                    _dataStreamStartPoint = skipSize - (MAXBUFFERSIZE - _dataStreamStartPoint);
                }

                _dataStreamSize -= skipSize;
                return;
            }
        }

        public int TrimRFIDPacket (int mode)
        {
            // delete data
            lock (_dataStreamLock)
            {
                int index;

                Defragment();

                // find new pkt_ver
                for (index = 1; index < _dataStreamSize; index++)
                {
                    if (mode == 0)
                    {
                        if (_dataStream[index] == 0x00 || _dataStream[index] == 0x40 || _dataStream[index] == 0x70)
                            break;
                    }
                    else
                    {
                        if ((_dataStream[index] >= 0x01 && _dataStream[index] <= 0x04) || _dataStream[index] == 0x40)
                            break;
                    }
                }

                if (index == _dataStreamSize)
                {
                    _dataStreamSize = 0;
                }
                else
                {
                    _dataStreamStartPoint = index;
                    _dataStreamSize -= index;
                }
            }

            return -1;
        }
    }
}
</file>

<file path="Library/CSLibrary/Source/Tools/ClassTimer.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System; 
using System.Threading; 
using System.Threading.Tasks; 
 
namespace CSLibrary
{ 
    internal delegate void TimerCallback(object state); 
 
    internal sealed class Timer : CancellationTokenSource, IDisposable 
    { 
 	    public Timer(TimerCallback callback, object state, int dueTime, int period)
 	    { 
 		    Task.Delay(dueTime, Token).ContinueWith(async (t, s) => 
 		    {
                var tuple = (Tuple<TimerCallback, object>)s;

                while (true)
                {
                    if (IsCancellationRequested)
                            break;
                    Task.Run(() => tuple.Item1(tuple.Item2));
                    await Task.Delay(period);
                }
            }, Tuple.Create(callback, state), CancellationToken.None, 
 			    TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnRanToCompletion, 
 			    TaskScheduler.Default); 
 	    } 
 
 	    public new void Dispose() { base.Cancel(); } 
    } 
}
</file>

<file path="Library/CSLibrary/Source/Tools/HexEncoding.cs">
/*
Copyright (c) 2018 Convergence Systems Limited

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Text;
using System.Net;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace CSLibrary.Tools
{
    /// <summary>
    /// For Backward Compatibility
    /// </summary>
    public class Hex : HexEncoding
    {
    }

    /// <summary>
    /// Summary description for HexEncoding.
    /// </summary>
    public class HexEncoding
    {

        public static bool IsHexDigit(char c)
        {
            return ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'));
        }

        public static long HostToNetworkOrder(long host)
        {
#if BIGENDIAN
            return host; 
#else
            return (((long)HostToNetworkOrder((int)host) & 0xFFFFFFFF) << 32)
                    | ((long)HostToNetworkOrder((int)(host >> 32)) & 0xFFFFFFFF);
#endif
        }
        public static int HostToNetworkOrder(int host)
        {
#if BIGENDIAN
            return host;
#else 
            return (((int)HostToNetworkOrder((short)host) & 0xFFFF) << 16)
                    | ((int)HostToNetworkOrder((short)(host >> 16)) & 0xFFFF);
#endif
        }
        public static short HostToNetworkOrder(short host)
        {
#if BIGENDIAN
            return host;
#else
            return (short)((((int)host & 0xFF) << 8) | (int)((host >> 8) & 0xFF));
#endif
        }
        public static long NetworkToHostOrder(long network)
        {
            return HostToNetworkOrder(network);
        }
        public static int NetworkToHostOrder(int network)
        {
            return HostToNetworkOrder(network);
        }
        public static short NetworkToHostOrder(short network)
        {
            return HostToNetworkOrder(network);
        }


        /// <summary>
        /// Creates a byte array from the hexadecimal string. Each two characters are combined
        /// to create one byte. First two hexadecimal characters become first byte in returned array.
        /// Non-hexadecimal characters are ignored. 
        /// </summary>
        /// <param name="hexString">string to convert to byte array</param>
        /// <returns>byte array, in the same left-to-right order as the hexString</returns>
        public static byte[] ToBytes(string hexString)//, out int discarded)
        {
            //discarded = 0;
            if (hexString == null || hexString.Length == 0)
                return new byte[0];
            string newString = "";
            char c;
            // remove all none A-F, 0-9, characters
            for (int i = 0; i < hexString.Length; i++)
            {
                c = hexString[i];
                if (IsHexDigit(c))
                    newString += c;
            }

            int byteLength = newString.Length / 2 + newString.Length % 2;
            byte[] bytes = new byte[byteLength];
            string hex = "";
            for (int i = 0; i < byteLength; i++)
            {
                if (i * 2 + 1 < newString.Length)
                    hex = new String(new Char[] { newString[i * 2], newString[i * 2 + 1] });
                else
                    hex = new String(new Char[] { newString[i * 2], '0' });
                bytes[i] = HexToByte(hex);
            }
            return bytes;
        }

        /// <summary>
        /// Creates a byte array from the hexadecimal string. Each two characters are combined
        /// to create one byte. First two hexadecimal characters become first byte in returned array.
        /// Non-hexadecimal characters are ignored. 
        /// </summary>
        /// <param name="hexString">string to convert to byte array</param>
        /// <returns>byte array, in the same left-to-right order as the hexString</returns>
        public static byte[] GenSelectMask(string hexString)
        {
            int max_mask_size = 32;
            //discarded = 0;
            if (hexString == null || hexString.Length == 0)
                return new byte[max_mask_size];
            string newString = "";
            char c;
            // remove all none A-F, 0-9, characters
            for (int i = 0; i < hexString.Length; i++)
            {
                c = hexString[i];
                if (IsHexDigit(c))
                    newString += c;
            }

            int byteLength = newString.Length / 2 + newString.Length % 2;
            byte[] bytes = new byte[max_mask_size];
            string hex = "";
            for (int i = 0; i < byteLength; i++)
            {
                if (i * 2 + 1 < newString.Length)
                    hex = new String(new Char[] { newString[i * 2], newString[i * 2 + 1] });
                else
                    hex = new String(new Char[] { newString[i * 2], '0' });
                bytes[i] = HexToByte(hex);
            }
            for (int i = byteLength; i < max_mask_size; i++)
            {
                bytes[i] = 0x00;
            }
            return bytes;
        }
        /// <summary>
        /// Creates a byte array from the hexadecimal string. Each two characters are combined
        /// to create one byte. First two hexadecimal characters become first byte in returned array.
        /// Non-hexadecimal characters are ignored. 
        /// </summary>
        /// <param name="hexString">string to convert to byte array</param>
        /// <returns>byte array, in the same left-to-right order as the hexString</returns>
        public static byte[] GenPostMatchMask(string hexString)
        {
            int max_mask_size = 62;
            //discarded = 0;
            if (hexString == null || hexString.Length == 0)
                return new byte[max_mask_size];
            string newString = "";
            char c;
            // remove all none A-F, 0-9, characters
            for (int i = 0; i < hexString.Length; i++)
            {
                c = hexString[i];
                if (IsHexDigit(c))
                    newString += c;
            }

            int byteLength = newString.Length / 2 + newString.Length % 2;
            byte[] bytes = new byte[max_mask_size];
            string hex = "";
            for (int i = 0; i < byteLength; i++)
            {
                if (i * 2 + 1 < newString.Length)
                    hex = new String(new Char[] { newString[i * 2], newString[i * 2 + 1] });
                else
                    hex = new String(new Char[] { newString[i * 2], '0' });
                bytes[i] = HexToByte(hex);
            }
            for (int i = byteLength; i < max_mask_size; i++)
            {
                bytes[i] = 0x00;
            }
            return bytes;
        }
        /// <summary>
        /// Convent ushort array to byte array
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public static byte[] ToBytes(ushort[] data)
        {
            return ToBytes(data, data.Length);
        }
        /// <summary>
        /// Convent ushort array to byte array
        /// </summary>
        /// <param name="data"></param>
        /// <param name="count"></param>
        /// <returns></returns>
        public static byte[] ToBytes(ushort[] data, int count)
        {
            if (data == null || data.Length == 0 || count == 0)
                return new byte[0];
            int bytes = count << 1;

            byte[] reda = new byte[bytes];
            for (int i = 0; i < count; i++)
            {
                reda[i * 2] = (Byte)((data[i] >> 8) & 0xff);
                reda[i * 2 + 1] = (Byte)(data[i] & 0xff);
            }
            //byte[] reda = new byte[bytes];
            //Buffer.BlockCopy(data, 0, reda, 0, bytes);
            return reda;
        }
        /// <summary>
        /// return a byte from string
        /// </summary>
        /// <param name="hexString"></param>
        /// <returns></returns>
        public static byte ToByte(string hexString)//, out int discarded)
        {
            //discarded = 0;
            if (hexString == null || hexString.Length > 2 || hexString.Length == 0)
                return new byte();
            string newString = "";
            char c;
            // remove all none A-F, 0-9, characters
            for (int i = 0; i < hexString.Length; i++)
            {
                c = hexString[i];
                if (IsHexDigit(c))
                    newString += c;
            }

            string hex = "";
            if (newString.Length == 2)
                hex = new String(new Char[] { newString[0], newString[1] });
            else
                hex = new String(new Char[] { '0', newString[0] });
            return HexToByte(hex);
        }
        /// <summary>
        /// return ushort from byte string
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static ushort ToUshort(string str)
        {
            if (str == null || str.Length == 0)
                return 0x0;//throw new Reader.Exception.ReaderException("HexEncoding.GetUshort input null");
            return ushort.Parse(str, System.Globalization.NumberStyles.HexNumber);
        }
        /// <summary>
        /// return ushort array from byte array
        /// </summary>
        /// <param name="Input"></param>
        /// <returns></returns>
        public static ushort[] ToUshorts(byte[] Input)
        {
            if (Input == null)
                return null;//throw new Reader.Exception.ReaderException("HexEncoding.GetUshort input null");
            ushort[] Output = new ushort[Input.Length / 2 + Input.Length % 2];
            int j = 0;
            for (int i = 0; i < Output.Length; i++)
            {
                if (j + 1 < Input.Length)
                    Output[i] = (ushort)(Input[j] << 8 | Input[j + 1]);
                else
                    Output[i] = (ushort)(Input[j] << 8 | 0x0);
                j += 2;
            }
            return Output;
        }
        
		/// <summary>
        /// return short array from byte array
        /// </summary>
        /// <param name="Input"></param>
        /// <returns></returns>
        public static short[] ToShorts(byte[] Input)
        {
            if (Input == null)
                return null;//throw new Reader.Exception.ReaderException("HexEncoding.GetUshort input null");
            short[] Output = new short[Input.Length / 2 + Input.Length % 2];
            int j = 0;
            for (int i = 0; i < Output.Length; i++)
            {
                if (j + 1 < Input.Length)
                    Output[i] = (short)(Input[j] << 8 | Input[j + 1]);
                else
                    Output[i] = (short)(Input[j] << 8 | 0x0);
                j += 2;
            }
            return Output;
        }
        
		/// <summary>
        /// return ushort array from string input
        /// </summary>
        /// <param name="Input"></param>
        /// <returns></returns>
        public static ushort[] ToUshorts(string Input)
        {
            string newString = "";
            char c;
            // remove all none A-F, 0-9, characters
            for (int i = 0; i < Input.Length; i++)
            {
                c = Input[i];
                if (IsHexDigit(c))
                    newString += c;
            }
            int fullUshortLength = newString.Length / 4;
            int leftUshortLength = newString.Length % 4;
            ushort[] ushorts = new ushort[fullUshortLength + (leftUshortLength > 0 ? 1 : 0)];
            string hex = "";
            int j = 0;
            for (int i = 0; i < ushorts.Length; i++)
            {
                if (i < fullUshortLength)
                {
                    hex = new String(new Char[] { newString[j], newString[j + 1], newString[j + 2], newString[j + 3] });
                }
                else
                {
                    switch (leftUshortLength)
                    {
                        case 1:
                            hex = new String(new Char[] { newString[j], '0', '0', '0' });
                            break;
                        case 2: hex = new String(new Char[] { newString[j], newString[j + 1], '0', '0' });
                            break;
                        case 3: hex = new String(new Char[] { newString[j], newString[j + 1], newString[j + 2], '0' });
                            break;
                        default: break;
                    }

                }
                ushorts[i] = HexToUshort(hex);
                j = j + 4;
            }
            return ushorts;
        }

        /// <summary>
        /// return UInt32 array from string input
        /// </summary>
        /// <param name="Input"></param>
        /// <returns></returns>
        public static UInt32[] ToUInt32s(string Input)
        {
            string newString = "";
            char c;
            // remove all none A-F, 0-9, characters
            for (int i = 0; i < Input.Length; i++)
            {
                c = Input[i];
                if (IsHexDigit(c))
                    newString += c;
            }
            int fullUshortLength = newString.Length / 8;
            int leftUshortLength = newString.Length % 8;
            UInt32 [] UInt32s = new UInt32[fullUshortLength + (leftUshortLength > 0 ? 1 : 0)];
            string hex = "";
            int j = 0;
            for (int i = 0; i < UInt32s.Length; i++)
            {
                if (i < fullUshortLength)
                {
                    hex = new String(new Char[] { newString[j], newString[j + 1], newString[j + 2], newString[j + 3], newString[j + 4], newString[j + 5], newString[j + 6], newString[j + 7] });
                }
                else
                {
                    hex = "";
                    for (int cnt = 0; cnt < leftUshortLength; cnt++)
                        hex += newString[j + cnt];

                    for (int cnt = 0; cnt < 8 - leftUshortLength; cnt++)
                        hex += '0';
                }
                UInt32s[i] = HexToUInt32(hex);
                j = j + 8;
            }
            return UInt32s;
        }

        /// <summary>
        /// Byte to String Conversion
        /// </summary>
        /// <param name="bytes">Input Byte Array</param>
        /// <param name="offset">Start offset</param>
        /// <param name="count">Number of Count to converse</param>
        /// <returns>Return a String</returns>
        public static string ToString(byte[] bytes, int offset = 0, int count = -1)
        {
			if (bytes == null || bytes.Length == 0)
				return "";

			if (count == -1)
				count = bytes.Length;

			string hexString = "";
            for (int i = offset, j = 0; (i < bytes.Length && j < count); i++, j++)
            {
                hexString += bytes[i].ToString("X2");
            }
            return hexString;
        }

		/// <summary>
		/// ushort to String Conversion
		/// </summary>
		/// <param name="data">source data</param>
		/// <param name="offset">Start offset</param>
		/// <param name="count">Number of Count to converse</param>
		/// <returns></returns>
		public static string ToString(ushort[] data, int offset = 0, int count = -1)
        {
			if (data == null || count == 0)
				return "";

			if (count == -1)
				count = data.Length;

			string hexString = "";
            for (int i = offset, j = 0; (i < data.Length && j < count); i++, j++)
            {
                hexString += data[i].ToString("X4");
            }

			return hexString;
        }
        /// <summary>
        /// Determines if given string is in proper hexadecimal string format
        /// </summary>
        /// <param name="hexString"></param>
        /// <returns></returns>
        public static bool IsHexFormat(string hexString)
        {
            bool hexFormat = true;

            foreach (char digit in hexString)
            {
                if (!IsHexDigit(digit))
                {
                    hexFormat = false;
                    break;
                }
            }
            return hexFormat;
        }
        /*
        /// <summary>
        /// Returns true if c is a hexadecimal digit (A-F, a-f, 0-9)
        /// </summary>
        /// <param name="c">Character to test</param>
        /// <returns>true if hex digit, false if not</returns>
        public static bool Uri.IsHexDigit(Char c)
        {
            int numChar;
            int numA = 65;// Convert.ToInt32('A');
            int num1 = 48;// Convert.ToInt32('0');
            c = Char.ToUpper(c);
            numChar = Convert.ToInt32(c);
            if (numChar >= numA && numChar < (numA + 6))
                return true;
            if (numChar >= num1 && numChar < (num1 + 10))
                return true;
            return false;
        }*/
        /// <summary>
        /// Converts 1 or 2 character string into equivalant byte value
        /// </summary>
        /// <param name="hex">1 or 2 character string</param>
        /// <returns>byte</returns>
        private static byte HexToByte(string hex)
        {
            if (hex.Length > 2 || hex.Length <= 0)
                throw new ArgumentException("hex must be 1 or 2 characters in length");
            byte newByte = byte.Parse(hex, System.Globalization.NumberStyles.HexNumber);
            return newByte;
        }
        private static ushort HexToUshort(string hex)
        {
            if (hex.Length > 4 || hex.Length <= 0)
                throw new ArgumentException("hex must be 1 ~ 4 characters in length");
            ushort newByte = ushort.Parse(hex, System.Globalization.NumberStyles.HexNumber);
            return newByte;
        }
        private static UInt32 HexToUInt32(string hex)
        {
            if (hex.Length > 8 || hex.Length <= 0)
                throw new ArgumentException("hex must be 1 ~ 8 characters in length");
            UInt32 newByte = UInt32.Parse(hex, System.Globalization.NumberStyles.HexNumber);
            return newByte;
        }
        /// <summary>
        /// Compare Hex String, ie, source = "11ffaa", target = "11FFaa", it will return true
        /// </summary>
        /// <param name="source">Source Hex string</param>
        /// <param name="target">Target comparing Hex string</param>
        /// <returns></returns>
        public static bool Compare(string source, string target)
        {
            return ToBytes(source).Equals(ToBytes(target));
        }
        /// <summary>
        /// Compare Hex
        /// </summary>
        /// <param name="source">Source Hex</param>
        /// <param name="target">Target comparing Hex</param>
        /// <returns></returns>
        public static bool Compare(Byte[] source, Byte[] target)
        {
            return source.Equals(target);
        }
        /// <summary>
        /// Compare Hex
        /// </summary>
        /// <param name="source">Source Hex</param>
        /// <param name="target">Target comparing Hex</param>
        /// <param name="size">Size to compare</param>
        /// <returns></returns>
        public static bool Compare(Byte[] source, Byte[] target, int size)
        {
            if (size == 0)
                return true;

            if (source == null || target == null || size > Math.Min(source.Length, target.Length))
                return false;

            for (int cnt = 0; cnt < size; cnt++)
                if (source[cnt] != target[cnt])
                    return false;

            return true;
            
            
            /*
            if (source == null && target == null)
                return true;
            if (source == null)
                return false;
            if (target == null)
                return false;
            if (size > Math.Min(source.Length, target.Length) || target.Length != source.Length)
                return false;
            if (Win32.memcmp(source, target, source.Length) != 0)
            {
                return false;
            }
            return true;
*/
        }

        /// <summary>
        /// Convert 2 Bytes to one short
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="offset"></param>
        /// <returns></returns>
        public static Int16 ToInt16(byte[] buffer, int offset)
        {
            if (buffer == null || buffer.Length == 0)
                return 0;
            Int16 result = NetworkToHostOrder(BitConverter.ToInt16(buffer, offset));
            //offset += 2;
            return result;
        }

        /// <summary>
        /// Convert 2 Bytes to one short
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="offset"></param>
        /// <returns></returns>
        public static UInt16 ToUInt16(byte[] buffer, int offset)
        {
            if (buffer == null || buffer.Length == 0)
                return 0;
            return (UInt16)ToInt16(buffer, offset);
        }

        /*
        /// <summary>
        /// Convert 4 Bytes to one uint32
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="offset"></param>
        /// <returns></returns>
        public static UInt32 ToUInt32(byte[] buffer, int offset)
        {
            if (buffer == null || buffer.Length == 0)
                return 0;
            Int32 result = IPAddress.NetworkToHostOrder(BitConverter.ToInt32(buffer, offset));
            //offset += 4;
            return (UInt32)result;
        }
        */

        /// <summary>
        /// Convert string to one uint16
        /// </summary>
        /// <param name="hexString"></param>
        /// <returns></returns>
        public static UInt16 ToUInt16(string hexString)
        {
            if (hexString == null || hexString.Length == 0)
                return 0;
            return UInt16.Parse(hexString, System.Globalization.NumberStyles.HexNumber);
        }

        /// <summary>
        /// Convert string to one uint32
        /// </summary>
        /// <param name="hexString"></param>
        /// <returns></returns>
        public static UInt32 ToUInt32(string hexString)
        {
            if (hexString == null || hexString.Length == 0)
                return 0;
            return UInt32.Parse(hexString, System.Globalization.NumberStyles.HexNumber);
        }

        public static UInt16 LSBToUInt16(byte[] data, int index)
        {
            UInt16 value = (UInt16)(data[index] | data[index + 1] << 8);
            return value;
        }

        public static UInt16 MSBToUInt16(byte[] data, int index)
        {
            UInt16 value = (UInt16)(data[index] << 8 | data[index + 1]);
            return value;
        }

        public static UInt32 LSBToUInt32(byte[] data, int index)
        {
            uint value = (uint)(data[index] | data[index + 1] << 8 | data[index + 2] << 16 | data[index + 3] << 24);
            return value;
        }

        public static UInt32 MSBToUInt32(byte[] data, int index)
        {
            uint value = (uint)(data[index] << 24 | data[index + 1] << 16 | data[index + 2] << 8 | data[index + 3]);
            return value;
        }

        public static UInt64 LSBToUInt64(byte[] data, int index)
        {
            UInt64 value = (uint)(data[index] | data[index + 1] << 8 | data[index + 2] << 16 | data[index + 3] << 24 | data[index + 4] << 32 | data[index + 5] << 40 | data[index + 6] << 48 | data[index + 7] << 56);
            return value;
        }

        public static UInt64 MSBToUInt64(byte[] data, int index)
        {
            UInt64 value = (uint)(data[index] << 56 | data[index + 1] << 48 | data[index + 2] << 40 | data[index + 3] << 32 | data[index + 4] << 24 | data[index + 5] << 16 | data[index + 6] << 8 | data[index + 7]);
            return value;
        }

        public static UInt16 [] MSBToUInt16Array (byte[] data, int index, int size)
        {
            UInt16[] values = new UInt16[size];

            for (int cnt = 0; cnt < size; cnt++)
            {
                values[cnt] = MSBToUInt16(data, index);
                index += 2;
            }

            return values;
        }

        public static bool MSBArrayCopy(UInt32 src, byte [] dst, int dstIndex)
        {
            try
            {
                dst[dstIndex++] = (byte)(src >> 24);
                dst[dstIndex++] = (byte)(src >> 16);
                dst[dstIndex++] = (byte)(src >> 8);
                dst[dstIndex] = (byte)(src);
            }
            catch (Exception ex)
            {
                return false;
            }

            return true;
        }

        public static bool MSBArrayCopy(UInt16 src, byte[] dst, int dstIndex)
        {
            try
            {
                dst[dstIndex++] = (byte)(src >> 8);
                dst[dstIndex] = (byte)(src);
            }
            catch (Exception ex)
            {
                return false;
            }

            return true;
        }


        /*
        /// <summary>
        /// Convert 4 bytes to long
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="offset"></param>
        /// <returns></returns>
        public static UInt64 ToUInt64(byte[] buffer, int offset)
        {
            if (buffer == null || buffer.Length == 0)
                return 0;
            Int64 result = IPAddress.NetworkToHostOrder(BitConverter.ToInt64(buffer, offset));
            //offset += 8;
            return (UInt64)result;
        }
        */
        /// <summary>
        /// Copy One array to another array
        /// </summary>
        /// <param name="src"></param>
        /// <param name="dst"></param>
        /// <param name="count"></param>
        public static void Copy
                    (
                    Byte[] src,
                    Byte[] dst,
                    int count
                    )
        {
            Copy(src, 0, dst, 0, count);
        }
        /// <summary>
        /// Copy One array to another array
        /// </summary>
        /// <param name="src"></param>
        /// <param name="dst"></param>
        /// <param name="dstIndex"></param>
        /// <param name="count"></param>
        public static void Copy
                    (
                    Byte[] src,
                    Byte[] dst,
                    int dstIndex,
                    int count
                    )
        {
            Copy(src, 0, dst, dstIndex, count);
        }
        /// <summary>
        /// Copy One array to another array
        /// </summary>
        /// <param name="src"></param>
        /// <param name="srcIndex"></param>
        /// <param name="dst"></param>
        /// <param name="dstIndex"></param>
        /// <param name="count"></param>
        public static void Copy
            (
            Byte[] src,
            int srcIndex,
            Byte[] dst,
            int dstIndex,
            int count
            )
        {

            Copy(src, srcIndex, dst, dstIndex, count);
            
#if nouse
            const int block = 32;
            if (src == null || srcIndex < 0 ||
                dst == null || dstIndex < 0 || count < 0)
            {
                throw new ArgumentException();
            }
            int srcLen = src.Length;
            int dstLen = dst.Length;
            if (srcLen - srcIndex < count ||
                dstLen - dstIndex < count)
            {
                throw new ArgumentException();
            }


            // The following fixed statement pins the location of
            // the src and dst objects in memory so that they will
            // not be moved by garbage collection.          
            fixed (byte* pSrc = src, pDst = dst)
            {
                byte* ps = pSrc;
                byte* pd = pDst;

                // Loop over the count in blocks of 4 bytes, copying an
                // integer (4 bytes) at a time:
                for (int n = 0; n < count / block; n++)
                {
                    *((int*)pd) = *((int*)ps);
                    pd += block;
                    ps += block;
                }

                // Complete the copy by moving any bytes that weren't
                // moved in blocks of 4:
                for (int n = 0; n < count % block; n++)
                {
                    *pd = *ps;
                    pd++;
                    ps++;
                }
            }
#endif
        }

        /// <summary>
        /// Generic compare two array
        /// </summary>
        /// <typeparam name="T">Type of array</typeparam>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool Compare<T>(T[] a, T[] b)
        {
            if (a.Length != b.Length)
                return false;

            EqualityComparer<T> comparer = EqualityComparer<T>.Default;

            for (int i = 0; i < a.Length; i++)
            {
                if (!comparer.Equals(a[i], b[i]))
                    return false;
            }
            return true;

        }
        /// <summary>
        /// Get bit length from string
        /// </summary>
        /// <param name="hexString"></param>
        /// <returns></returns>
        public static UInt32 GetBitCount(string hexString)
        {
            if (hexString == null || hexString.Length == 0)
            {
                return 0;
            }

            string newString = String.Empty;
            char c;
            // remove all none A-F, 0-9, characters
            for (int i = 0; i < hexString.Length; i++)
            {
                c = hexString[i];
                if (IsHexDigit(c))
                    newString += c;
            }

            return (uint)(newString.Length * 4);
        }

        /// <summary>
        /// Get bit length from string
        /// </summary>
        /// <param name="bytes"></param>
        /// <returns></returns>
        public static UInt32 GetBitCount(Byte[] bytes)
        {
            if (bytes == null || bytes.Length == 0)
            {
                return 0;
            }
            return (uint)(bytes.Length * 8);
        }

        /// <summary>
        /// Get Word length from string
        /// </summary>
        /// <param name="hexString"></param>
        /// <returns></returns>
        public static ushort GetWordCount(string hexString)
        {
            if (hexString == null || hexString.Length == 0)
            {
                return 0;
            }
            string newString = String.Empty;
            char c;
            // remove all none A-F, 0-9, characters
            for (int i = 0; i < hexString.Length; i++)
            {
                c = hexString[i];
                if (IsHexDigit(c))
                    newString += c;
            }
            return (ushort)ToUshorts(newString).Length;
        }
        /// <summary>
        /// GetByteCount
        /// </summary>
        /// <param name="hexString">Input Hex String</param>
        /// <returns>Number of Byte Count</returns>
        public static int GetByteCount(string hexString)
        {
            int numHexChars = 0;
            char c;
            // remove all none A-F, 0-9, characters
            for (int i = 0; i < hexString.Length; i++)
            {
                c = hexString[i];
                if (IsHexDigit(c))
                    numHexChars++;
            }
            // if odd number of characters, discard last character
            if (numHexChars % 2 != 0)
            {
                numHexChars--;
            }
            return numHexChars / 2; // 2 characters per byte
        }
        /// <summary>
        /// Convert to binary format
        /// </summary>
        /// <param name="source"></param>
        /// <param name="offset"></param>
        /// <param name="length"></param>
        /// <returns></returns>
        public string ToBinary(byte[] source, uint offset, uint length)
        {
            BitArray bit = new BitArray(source);
            string bitString = bit.ToString();
            bitString = bitString.Remove(0, (int)offset);
            if (bitString.Length > length)
            {
                bitString = bitString.Remove((int)length, (int)(bitString.Length - length));
            }
            return bitString;
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client.Droid/BLE.Client.Droid.csproj">
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{7B0E4EFD-EEB8-4CE9-9C8D-7A4BF734E9A7}</ProjectGuid>
    <ProjectTypeGuids>{EFBA0AD7-5A72-4C68-AF49-83D382785DCF};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <TemplateGuid>{c9e5eea5-ca05-42a1-839b-61506e0a37df}</TemplateGuid>
    <OutputType>Library</OutputType>
    <RootNamespace>BLE.Client.Droid</RootNamespace>
    <AssemblyName>BLE.Client.Droid</AssemblyName>
    <AndroidApplication>True</AndroidApplication>
    <AndroidResgenFile>Resources\Resource.designer.cs</AndroidResgenFile>
    <AndroidResgenClass>Resource</AndroidResgenClass>
    <AndroidManifest>Properties\AndroidManifest.xml</AndroidManifest>
    <MonoAndroidResourcePrefix>Resources</MonoAndroidResourcePrefix>
    <MonoAndroidAssetsPrefix>Assets</MonoAndroidAssetsPrefix>
    <TargetFrameworkVersion>v13.0</TargetFrameworkVersion>
    <NuGetPackageImportStamp>
    </NuGetPackageImportStamp>
    <AndroidUseSharedRuntime>false</AndroidUseSharedRuntime>
    <AndroidSupportedAbis>armeabi-v7a;arm64-v8a</AndroidSupportedAbis>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug</OutputPath>
    <DefineConstants>DEBUG;</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>0</WarningLevel>
    <AndroidLinkMode>None</AndroidLinkMode>
    <EmbedAssembliesIntoApk>false</EmbedAssembliesIntoApk>
    <AotAssemblies>false</AotAssemblies>
    <EnableLLVM>false</EnableLLVM>
    <AndroidEnableProfiledAot>false</AndroidEnableProfiledAot>
    <BundleAssemblies>false</BundleAssemblies>
    <AndroidPackageFormat>apk</AndroidPackageFormat>
    <AndroidUseAapt2>true</AndroidUseAapt2>
    <AndroidCreatePackagePerAbi>false</AndroidCreatePackagePerAbi>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugSymbols>false</DebugSymbols>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release</OutputPath>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AndroidManagedSymbols>true</AndroidManagedSymbols>
    <AotAssemblies>false</AotAssemblies>
    <EnableLLVM>false</EnableLLVM>
    <AndroidEnableProfiledAot>false</AndroidEnableProfiledAot>
    <BundleAssemblies>false</BundleAssemblies>
    <AndroidPackageFormat>apk</AndroidPackageFormat>
    <AndroidUseAapt2>true</AndroidUseAapt2>
    <AndroidCreatePackagePerAbi>false</AndroidCreatePackagePerAbi>
    <EmbedAssembliesIntoApk>true</EmbedAssembliesIntoApk>
    <AndroidKeyStore>true</AndroidKeyStore>
    <AndroidSigningKeyStore>C:\Users\miles\Desktop\code\projects\Convergence\keystores\my-release.keystore</AndroidSigningKeyStore>
    <AndroidSigningStorePass>V9t!rQ2$zF7#nLpX</AndroidSigningStorePass>
    <AndroidSigningKeyAlias>cs710s</AndroidSigningKeyAlias>
    <AndroidSigningKeyPass>V9t!rQ2$zF7#nLpX</AndroidSigningKeyPass>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Mono.Android" />
    <Reference Include="Mono.Android.Export" />
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="ClassIBatteryOptimizationService.cs" />
    <Compile Include="ClassIExternalStorage.cs" />
    <Compile Include="LinkerPleaseInclude.cs" />
    <Compile Include="MainActivity.cs" />
    <Compile Include="MainApplication.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Setup.cs" />
    <Compile Include="SplashScreen.cs" />
    <Compile Include="ClassSystemSound.cs" />
    <Compile Include="ClassIAppVersion.cs" />
    <Compile Include="Resources\Resource.designer.cs" />
    <Compile Include="DebugTrace.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Properties\AndroidManifest.xml" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\values\colors.xml" />
    <AndroidResource Include="Resources\raw\beeplow.mp3">
      <SubType>
      </SubType>
      <Generator>
      </Generator>
    </AndroidResource>
    <AndroidResource Include="Resources\raw\beephigh.mp3">
      <SubType>
      </SubType>
      <Generator>
      </Generator>
    </AndroidResource>
    <AndroidResource Include="Resources\raw\beep3s1khz.mp3">
      <SubType>
      </SubType>
      <Generator>
      </Generator>
    </AndroidResource>
  </ItemGroup>
  <ItemGroup>
    <Folder Include="Assets\" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\values\style.xml" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\values\SplashStyle.xml" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\layout\SplashScreen.axml" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\layout\tabs.axml" />
    <AndroidResource Include="Resources\layout\toolbar.axml" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\drawable\icon.png" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\drawable-hdpi\icon.png" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\drawable-xhdpi\icon.png" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\drawable-xxhdpi\icon.png" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions">
      <Version>7.0.1</Version>
    </PackageReference>
    <PackageReference Include="MQTTnet">
      <Version>4.3.3.952</Version>
    </PackageReference>
    <PackageReference Include="MvvmCross">
      <Version>7.1.2</Version>
    </PackageReference>
    <PackageReference Include="MvvmCross.Forms">
      <Version>7.1.2</Version>
    </PackageReference>
    <PackageReference Include="MvvmCross.Plugin.BLE">
      <Version>2.2.0-pre5</Version>
    </PackageReference>
    <PackageReference Include="PCLStorage">
      <Version>1.0.2</Version>
    </PackageReference>
    <PackageReference Include="Xam.Plugins.Settings">
      <Version>4.1.0-beta</Version>
    </PackageReference>
    <PackageReference Include="Plugin.CurrentActivity">
      <Version>2.1.0.4</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.Preference">
      <Version>1.1.1.9</Version>
    </PackageReference>
    <PackageReference Include="Acr.UserDialogs">
      <Version>6.5.1</Version>
    </PackageReference>
    <PackageReference Include="Newtonsoft.Json">
      <Version>13.0.3</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.Core">
      <Version>1.6.0.1</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.Annotation">
      <Version>1.2.0.1</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.Legacy.Support.Core.Utils">
      <Version>1.0.0.8</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.Legacy.Support.Core.UI">
      <Version>1.0.0.9</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.Media">
      <Version>1.4.1</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.Fragment">
      <Version>1.3.6.1</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.Legacy.Support.V4">
      <Version>1.0.0.8</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.VectorDrawable">
      <Version>1.1.0.8</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.VectorDrawable.Animated">
      <Version>1.1.0.8</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.AppCompat">
      <Version>1.3.1.1</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.Transition">
      <Version>1.4.1.1</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.CardView">
      <Version>1.0.0.9</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.MediaRouter">
      <Version>1.2.4.1</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.Browser">
      <Version>1.3.0.6</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.Palette">
      <Version>1.0.0.8</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.RecyclerView">
      <Version>1.2.1.1</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.Forms">
      <Version>5.0.0.2578</Version>
    </PackageReference>
    <PackageReference Include="Splat">
      <Version>2.0.0</Version>
    </PackageReference>
    <PackageReference Include="Prism.Core">
      <Version>8.1.97</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.AndroidX.Migration" Version="1.0.8" />
    <PackageReference Include="Xamarin.Android.Support.Compat">
      <Version>28.0.0.3</Version>
    </PackageReference>
    <PackageReference Include="AndHUD">
      <Version>1.2.0</Version>
    </PackageReference>
    <PackageReference Include="Plugin.Share">
      <Version>7.1.1</Version>
    </PackageReference>
    <PackageReference Include="Xamarin.Essentials">
      <Version>1.7.5</Version>
    </PackageReference>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\BLE.Client\BLE.Client.csproj">
      <Project>{47E1BEC1-4717-46F5-9E71-6F4CCB7B0EAF}</Project>
      <Name>BLE.Client</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\drawable\csl.png" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\drawable\filter.png" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\drawable\function.png" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\drawable\inventory.png" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\drawable\main_logo.png" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\drawable\register.png" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\drawable\search.png" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\drawable\icon_bgfree.png" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\drawable\security.png" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\drawable\settings.png" />
  </ItemGroup>
  <ItemGroup>
    <AndroidResource Include="Resources\drawable\write.png" />
  </ItemGroup>
  <Import Project="$(MSBuildExtensionsPath)\Xamarin\Android\Xamarin.Android.CSharp.targets" />
</Project>
</file>

<file path="MobileMvxApp/BLE.Client.Droid/Bootstrap/BlePluginBootstrap.cs">
using MvvmCross.Platform.Plugins;

namespace BLE.Client.Droid.Bootstrap
{
    public class BlePluginBootstrap
        : MvxPluginBootstrapAction<MvvmCross.Plugins.BLE.PluginLoader>
    {
    }
}
</file>

<file path="MobileMvxApp/BLE.Client.Droid/ClassIAppVersion.cs">
using Android.App;

[assembly: Xamarin.Forms.Dependency(typeof(BLE.Client.Droid.Version_Android))]
namespace BLE.Client.Droid
{
    public class Version_Android : Activity, BLE.Client.IAppVersion
    {
        public string GetVersion()
        {
            var context = global::Android.App.Application.Context;

            Android.Content.PM.PackageManager manager = context.PackageManager;
            Android.Content.PM.PackageInfo info = manager.GetPackageInfo(context.PackageName, 0);

            return info.VersionName;
        }

        public int GetBuild()
        {
            var context = global::Android.App.Application.Context;

            Android.Content.PM.PackageManager manager = context.PackageManager;
            Android.Content.PM.PackageInfo info = manager.GetPackageInfo(context.PackageName, 0);

            return info.VersionCode;
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client.Droid/ClassIBatteryOptimizationService.cs">
using Android.OS;
using Android.Content;
using Android.Provider;
using Xamarin.Essentials;
using Xamarin.Forms;
using Android.Net;
using System.Threading.Tasks;

[assembly: Xamarin.Forms.Dependency(typeof(BLE.Client.Droid.BatteryOptimizationService))]

namespace BLE.Client.Droid
{
    public class BatteryOptimizationService : BLE.Client.IBatteryOptimizationService
    {
        public bool IsBatteryOptimizationDisabled()
        {
            // If Android 12 or older
            if (Build.VERSION.SdkInt < BuildVersionCodes.Tiramisu)
                return true;

            var powerManager = (PowerManager)Android.App.Application.Context.GetSystemService(Android.Content.Context.PowerService);
            var packageName = Android.App.Application.Context.PackageName;
            if (powerManager.IsIgnoringBatteryOptimizations(packageName))
                return true;

            return false;
        }

        public async Task OpenBatteryOptimizationsAsync()
        {
            if (!IsBatteryOptimizationDisabled())
            {
                var intent = new Intent(Android.Provider.Settings.ActionApplicationDetailsSettings);
                var uri = Uri.FromParts("package", Forms.Context.PackageName, null);
                intent.SetData(uri); 
                intent.AddFlags(ActivityFlags.NewTask);
                Forms.Context.StartActivity(intent);
            }

            return;
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client.Droid/ClassIExternalStorage.cs">
using Android.App;
using Android.Media;
using Java.IO;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using static System.Net.Mime.MediaTypeNames;
using System.IO;
using Android.Content;
using Java.IO;
using Android.Provider;
using Android.OS;
using MvvmCross.Platforms.Android;
using MvvmCross;

[assembly: Xamarin.Forms.Dependency(typeof(BLE.Client.Droid.AndroidImplementation))]
namespace BLE.Client.Droid
{

    public class AndroidImplementation : IExternalStorage
    {
        public string GetPath()
        {
            Android.Content.Context context = Android.App.Application.Context;
            var filePath = context.GetExternalFilesDir("");
            return filePath.Path;
        }

        public void SaveTextFileToDocuments(string fileName, string content, int fileType)
        {
            var topActivity = Mvx.IoCProvider.Resolve<IMvxAndroidCurrentTopActivity>().Activity;

            if (Build.VERSION.SdkInt >= BuildVersionCodes.Q)
            {
                var resolver = topActivity.ContentResolver;
                ContentValues values = new ContentValues();
                values.Put(MediaStore.IMediaColumns.DisplayName, fileName);
                switch (fileType)
                {
                    case 0:
                        values.Put(MediaStore.IMediaColumns.MimeType, "application/json");
                        break;
                    case 1:
                    case 2:
                        values.Put(MediaStore.IMediaColumns.MimeType, "text/csv");
                        break;
                    default:
                        values.Put(MediaStore.IMediaColumns.MimeType, "text/plain");
                        break;
                }
                values.Put(MediaStore.IMediaColumns.RelativePath, "Documents/");

                Android.Net.Uri collection = MediaStore.Files.GetContentUri("external");
                Android.Net.Uri fileUri = resolver.Insert(collection, values);

                using (var outputStream = resolver.OpenOutputStream(fileUri))
                using (var writer = new StreamWriter(outputStream))
                {
                    writer.Write(content);
                    writer.Flush();
                }
            }
            else
            {
                var documentsPath = Android.OS.Environment.GetExternalStoragePublicDirectory(Android.OS.Environment.DirectoryDocuments).AbsolutePath;
                var filePath = Path.Combine(documentsPath, fileName);

                if (!Directory.Exists(documentsPath))
                    Directory.CreateDirectory(documentsPath);

                System.IO.File.WriteAllText(filePath, content);
            }
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client.Droid/ClassSystemSound.cs">
using System;
using System.Diagnostics;
using System.IO;
using Xamarin.Forms;

using Android.Content;

using Android.App;
using Android.Media;

[assembly: Dependency(typeof(BLE.Clinet.Droid.SystemSound_Android))]
namespace BLE.Clinet.Droid
{
    public class SystemSound_Android : Activity, BLE.Client.ISystemSound
    {
        static Context _applicationContext;
        static MediaPlayer _player2;
        static MediaPlayer _player3;
        static MediaPlayer _player4;

        static public void Initialization(Context applicationContext)
        {
            _applicationContext = applicationContext;

            _player2 = MediaPlayer.Create(_applicationContext, BLE.Client.Droid.Resource.Raw.beeplow);
            _player3 = MediaPlayer.Create(_applicationContext, BLE.Client.Droid.Resource.Raw.beephigh);
            _player4 = MediaPlayer.Create(_applicationContext, BLE.Client.Droid.Resource.Raw.beep3s1khz);
        }

        //CSLibraryv4: updated
        static public void Initialization()
        {
            var context = global::Android.App.Application.Context;

            _player2 = MediaPlayer.Create(context, BLE.Client.Droid.Resource.Raw.beeplow);
            _player3 = MediaPlayer.Create(context, BLE.Client.Droid.Resource.Raw.beephigh);
            _player4 = MediaPlayer.Create(context, BLE.Client.Droid.Resource.Raw.beep3s1khz);

        }


        public void SystemSound(int id)
        {
            try
            {
                switch (id)
                {
                    case 2:
                        if (_player2.IsPlaying)
                            _player2.Pause();
                        if (_player3.IsPlaying)
                            _player3.Pause();
                        if (_player4.IsPlaying)
                            _player4.Pause();
                        _player2.Start();
                        break;

                    case 1:
                    case 3:
                        if (_player2.IsPlaying)
                            _player2.Pause();
                        if (_player3.IsPlaying)
                            _player3.Pause();
                        if (_player4.IsPlaying)
                            _player4.Pause();
                        _player3.Start();
                        break;

                    case 4:
                        if (_player2.IsPlaying)
                            _player2.Pause();
                        if (_player3.IsPlaying)
                            _player3.Pause();

                        if (!_player4.IsPlaying)
                            _player4.Start();
                        break;
                }
            }
            catch (Exception ex)
            {

            }
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client.Droid/DebugTrace.cs">
using System;
using MvvmCross.Logging;

//Default
namespace BLE.Client.Droid
{
    public class DebugTrace : IMvxLog
    {
        public bool IsLogLevelEnabled(MvxLogLevel logLevel)
        {
            //To be implemented
            return true;
        }

        public bool Log(MvxLogLevel logLevel, Func<string> messageFunc, Exception exception = null, params object[] formatParameters)
        {
            //To be implemented
            return true;
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client.Droid/LinkerPleaseInclude.cs">
using System.Collections.Specialized;
using System.Windows.Input;
using Android.App;
using Android.Views;
using Android.Widget;
using MvvmCross.Binding.BindingContext;

//Default
namespace BLE.Client.Droid
{
    // This class is never actually executed, but when Xamarin linking is enabled it does how to ensure types and properties
    // are preserved in the deployed app
    public class LinkerPleaseInclude
    {
        public void Include(Button button)
        {
            button.Click += (s,e) => button.Text = button.Text + "";
        }

        public void Include(CheckBox checkBox)
        {
            checkBox.CheckedChange += (sender, args) => checkBox.Checked = !checkBox.Checked;
        }
        
        public void Include(Switch @switch)
        {
            @switch.CheckedChange += (sender, args) => @switch.Checked = !@switch.Checked;
        }

        public void Include(View view)
        {
            view.Click += (s, e) => view.ContentDescription = view.ContentDescription + "";
        }

        public void Include(TextView text)
        {
            text.TextChanged += (sender, args) => text.Text = "" + text.Text;
            text.Hint = "" + text.Hint;
        }
        
        public void Include(CheckedTextView text)
        {
            text.TextChanged += (sender, args) => text.Text = "" + text.Text;
            text.Hint = "" + text.Hint;
        }

        public void Include(CompoundButton cb)
        {
            cb.CheckedChange += (sender, args) => cb.Checked = !cb.Checked;
        }

        public void Include(SeekBar sb)
        {
            sb.ProgressChanged += (sender, args) => sb.Progress = sb.Progress + 1;
        }

        public void Include(Activity act)
        {
            act.Title = act.Title + "";
        }

        public void Include(INotifyCollectionChanged changed)
        {
            changed.CollectionChanged += (s,e) => { var test = $"{e.Action}{e.NewItems}{e.NewStartingIndex}{e.OldItems}{e.OldStartingIndex}"; };
        }

        public void Include(ICommand command)
        {
            command.CanExecuteChanged += (s, e) => { if (command.CanExecute(null)) command.Execute(null); };
        }
        
        public void Include(MvvmCross.IoC.MvxPropertyInjector injector)
        {
            injector = new MvvmCross.IoC.MvxPropertyInjector ();
        } 

        public void Include(System.ComponentModel.INotifyPropertyChanged changed)
        {
            changed.PropertyChanged += (sender, e) =>  {
                var test = e.PropertyName;
            };
        }
        
        public void Include(MvxTaskBasedBindingContext context)
        {
            context.Dispose();
            var context2 = new MvxTaskBasedBindingContext();
            context2.Dispose();
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client.Droid/MainActivity.cs">
using Acr.UserDialogs;
using Android.App;
using Android.Bluetooth;
using Android.Content.PM;
using Android.OS;
using Android.Runtime;
using Android.Views;
using Android.Widget;
using MvvmCross;
using MvvmCross.Forms.Platforms.Android.Views;
using System;
using System.Collections.Generic;
using Xamarin.Forms;
using System.Linq;

namespace BLE.Client.Droid
{
    [Activity(ScreenOrientation = ScreenOrientation.User
        ,ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation,
        LaunchMode = LaunchMode.SingleTask)]
    public class MainActivity 
        : MvxFormsAppCompatActivity

    //		: MvxFormsAppCompatActivity
    {
        protected override async void OnCreate(Bundle bundle)
        {
            ToolbarResource = Resource.Layout.toolbar;
            TabLayoutResource = Resource.Layout.tabs;

            System.Net.ServicePointManager.ServerCertificateValidationCallback = delegate
            {
                return true;
            };

            base.OnCreate(bundle);

            Xamarin.Essentials.Platform.Init(this, bundle); // add this line to your code, it may also be called: bundle

            if (Device.Idiom == TargetIdiom.Phone)
                this.RequestedOrientation = ScreenOrientation.Portrait;
            else
                this.RequestedOrientation = ScreenOrientation.Landscape;

            //await Permissions.RequestAsync<BLEPermission>();
            //Xamarin.Essentials.Permissions.RequestAsync<BLEPermission>();
            //CheckConnectedDevice();

            var status = await Xamarin.Essentials.Permissions.RequestAsync<BLEPermission>();
            //if (status == Xamarin.Essentials.PermissionStatus.Granted)
            {
                CheckConnectedDevice();
            }
        }

        public override void OnRequestPermissionsResult(int requestCode, string[] permissions, Android.Content.PM.Permission[] grantResults)
        {
            Xamarin.Essentials.Platform.OnRequestPermissionsResult(requestCode, permissions, grantResults);

            base.OnRequestPermissionsResult(requestCode, permissions, grantResults);
        }

        public class BLEPermission : Xamarin.Essentials.Permissions.BasePlatformPermission
        {
            public override (string androidPermission, bool isRuntime)[] RequiredPermissions => new List<(string androidPermission, bool isRuntime)>
            {
                (Android.Manifest.Permission.BluetoothScan, true),
                (Android.Manifest.Permission.BluetoothConnect, true),
                (Android.Manifest.Permission.Internet, true),
                (Android.Manifest.Permission.AccessNetworkState, true),
                (Android.Manifest.Permission.ReadExternalStorage, true),
                (Android.Manifest.Permission.WriteExternalStorage, true)
            }.ToArray();
        }

        void CheckConnectedDevice()
        {
            BluetoothAdapter adapter = BluetoothAdapter.DefaultAdapter;
            if (adapter == null || !adapter.IsEnabled)
                return;

            foreach (var device in adapter.BondedDevices)
                if (device.Type == BluetoothDeviceType.Le || device.Type == BluetoothDeviceType.Dual)
                    device.ConnectGatt(this, false, new ServiceCheckGattCallback(device));
        }

        class ServiceCheckGattCallback : BluetoothGattCallback
        {
            BluetoothDevice _device;
            public ServiceCheckGattCallback(BluetoothDevice device)
            {
                _device = device;
            }

            public override void OnConnectionStateChange(BluetoothGatt gatt, GattStatus status, ProfileState newState)
            {
                base.OnConnectionStateChange(gatt, status, newState);
                if (newState == ProfileState.Connected)
                {
                    gatt.DiscoverServices();
                }
                else if (newState == ProfileState.Disconnected)
                {
                    gatt.Close();
                }
            }

            public override void OnServicesDiscovered(BluetoothGatt gatt, GattStatus status)
            {
                base.OnServicesDiscovered(gatt, status);
                var targetService = gatt.Services.FirstOrDefault(
                    s => s.Uuid.ToString().ToLower() == "00009802-0000-1000-8000-00805f9b34fb"
                );
                if (targetService != null)
                {
                    try
                    {
                        var m = _device.Class.GetMethod("removeBond");
                        m.Invoke(_device, null);
                    }
                    catch (Exception ex)
                    {
                        System.Diagnostics.Debug.WriteLine("removeBond failed: " + ex.Message);
                    }
                }
                gatt.Close();
            }
        }

    }
}
</file>

<file path="MobileMvxApp/BLE.Client.Droid/MainApplication.cs">
using Android.App;
using Android.Bluetooth;
using Android.OS;
using Android.Runtime;
using Plugin.CurrentActivity;
using System;
using System.Linq;

namespace BLE.Client.Droid
{
	//You can specify additional application information in this attribute
    [Application]
    public class MainApplication : Application, Application.IActivityLifecycleCallbacks
    {
        public MainApplication(IntPtr handle, JniHandleOwnership transer)
          :base(handle, transer)
        {
        }

        public override void OnCreate()
        {
            base.OnCreate();
            RegisterActivityLifecycleCallbacks(this);
            //A great place to initialize Xamarin.Insights and Dependency Services!

            BLE.Clinet.Droid.SystemSound_Android.Initialization();
        }

        public override void OnTerminate()
        {
            base.OnTerminate();
            UnregisterActivityLifecycleCallbacks(this);
        }

        public void OnActivityCreated(Activity activity, Bundle savedInstanceState)
        {
            CrossCurrentActivity.Current.Activity = activity;
        }

        public void OnActivityDestroyed(Activity activity)
        {
        }

        public void OnActivityPaused(Activity activity)
        {
        }

        public void OnActivityResumed(Activity activity)
        {
            CrossCurrentActivity.Current.Activity = activity;
        }

        public void OnActivitySaveInstanceState(Activity activity, Bundle outState)
        {
        }

        public void OnActivityStarted(Activity activity)
        {
            CrossCurrentActivity.Current.Activity = activity;
        }

        public void OnActivityStopped(Activity activity)
        {
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client.Droid/Properties/AndroidManifest.xml">
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="csl.CS710Sfulldemo.demo" android:installLocation="preferExternal" android:versionName="0.1.17.6" android:versionCode="138">
	<uses-sdk android:minSdkVersion="21" android:targetSdkVersion="33" />
	<application android:label="CS710S C# Mini" android:icon="@drawable/icon" android:theme="@style/MyTheme"></application>
	<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
	<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
	<uses-permission android:name="android.permission.BLUETOOTH" />
	<uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
	<uses-permission android:name="android.permission.ACCESS_LOCATION_EXTRA_COMMANDS" />
	<uses-permission android:name="android.permission.CONTROL_LOCATION_UPDATES" />
	<uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
	<uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
	<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
	<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
	<uses-permission android:name="android.permission.INTERNET" />
	<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
	<uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
	<uses-permission android:name="android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS" />
</manifest>
</file>

<file path="MobileMvxApp/BLE.Client.Droid/Properties/AssemblyInfo.cs">
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Android.App;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("BLE.Client.Droid")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("BLE.Client.Droid")]
[assembly: AssemblyCopyright("Copyright   2014")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: ComVisible(false)]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("2.0.0")]
[assembly: AssemblyVersion("2.0.0")]
[assembly: AssemblyFileVersion("2.0.0")]

// Add some common permissions, these can be removed if not needed
[assembly: UsesPermission(Android.Manifest.Permission.Internet)]
[assembly: UsesPermission(Android.Manifest.Permission.WriteExternalStorage)]
[assembly: UsesPermission(Android.Manifest.Permission.AccessCoarseLocation)]
[assembly: UsesPermission(Android.Manifest.Permission.AccessFineLocation)]
[assembly: UsesPermission(Android.Manifest.Permission.AccessBackgroundLocation)]
[assembly: UsesFeature("android.hardware.location", Required = false)]
[assembly: UsesFeature("android.hardware.location.gps", Required = false)]
[assembly: UsesFeature("android.hardware.location.network", Required = false)]
</file>

<file path="MobileMvxApp/BLE.Client.Droid/Resources/layout/SplashScreen.axml">
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:background="#DFE0E0">
    <ImageView
        android:layout_width="wrap_content"
        android:src="@drawable/csl"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:contentDescription="@string/Hello" />
</RelativeLayout>
</file>

<file path="MobileMvxApp/BLE.Client.Droid/Resources/layout/tabs.axml">
<?xml version="1.0" encoding="utf-8"?>
<com.google.android.material.tabs.TabLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/sliding_tabs"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="?attr/colorPrimary"
    android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
    app:tabIndicatorColor="@android:color/white"
    app:tabGravity="fill"
    app:tabMode="fixed" />
</file>

<file path="MobileMvxApp/BLE.Client.Droid/Resources/layout/toolbar.axml">
<?xml version="1.0" encoding="utf-8"?>
<androidx.appcompat.widget.Toolbar xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/toolbar"
    android:layout_width="match_parent"
    android:layout_height="?attr/actionBarSize"
    android:minHeight="?attr/actionBarSize"
    android:background="?attr/colorPrimary"
    android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
    app:popupTheme="@style/ThemeOverlay.AppCompat.Light"
    app:layout_scrollFlags="scroll|enterAlways" />
</file>

<file path="MobileMvxApp/BLE.Client.Droid/Resources/values/colors.xml">
<?xml version="1.0" encoding="utf-8" ?>
<resources>
	<color name="primary">#4B77BE</color>
	<color name="primaryDark">#171717</color>
	<color name="accent">#203864</color>
  <color name="window_background">#F5F5F5</color>
</resources>
</file>

<file path="MobileMvxApp/BLE.Client.Droid/Resources/values/SplashStyle.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <style name="Theme.Splash" parent="Theme.AppCompat.Light.NoActionBar">
    <item name="android:windowNoTitle">true</item>
  </style>
</resources>
</file>

<file path="MobileMvxApp/BLE.Client.Droid/Resources/values/style.xml">
<?xml version="1.0" encoding="utf-8" ?>
<resources>
  <style name="MyTheme" parent="MyTheme.Base">
  </style>
  <style name="MyTheme.Base" parent="Theme.AppCompat.Light.NoActionBar">
    <item name="colorPrimary">@color/primary</item>
    <item name="colorPrimaryDark">@color/primaryDark</item>
    <item name="colorAccent">@color/accent</item>
    <item name="android:windowBackground">@color/window_background</item>
    <item name="windowActionModeOverlay">true</item>
    <item name="android:textAllCaps">false</item>
  </style>
</resources>
</file>

<file path="MobileMvxApp/BLE.Client.Droid/Setup.cs">
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Acr.UserDialogs;
using Android.Content;
using MvvmCross;
using MvvmCross.Forms.Platforms.Android.Core;
using MvvmCross.IoC;
using Plugin.Settings;

namespace BLE.Client.Droid
{
    public class Setup : MvxFormsAndroidSetup<BleMvxApplication, BleMvxFormsApp>
    {

        public override IEnumerable<Assembly> GetViewAssemblies()
        {
            return new List<Assembly>(base.GetViewAssemblies().Union(new[] { typeof(BleMvxFormsApp).GetTypeInfo().Assembly }));
        }

        protected override IMvxIoCProvider InitializeIoC()
        {
            var result = base.InitializeIoC();

            Mvx.IoCProvider.RegisterSingleton(() => UserDialogs.Instance);
            Mvx.IoCProvider.RegisterSingleton(() => CrossSettings.Current);

            return result;
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client.Droid/SplashScreen.cs">
using Acr.UserDialogs;
using Android.App;
using Android.Content.PM;
using Android.OS;
using MvvmCross.Core;
using Xamarin.Forms;
using MvvmCross.Forms.Platforms.Android.Views;
using MvvmCross.Platforms.Android.Views;
using System.Threading.Tasks;
using System;

namespace BLE.Client.Droid
{
    [Activity(MainLauncher = true
        , Theme = "@style/Theme.Splash"
        , NoHistory = true
        , ScreenOrientation = ScreenOrientation.Portrait)]
    public class SplashScreen
        : MvxFormsSplashScreenActivity<Setup, BleMvxApplication, BleMvxFormsApp>
    {
        public SplashScreen()
            : base(Resource.Layout.SplashScreen)
        {
            this.RegisterSetupType<Setup>();
        }

        protected override void OnCreate(Bundle bundle)
        {
            base.OnCreate(bundle);
            UserDialogs.Init(this);
        }

        protected override Task RunAppStartAsync(Bundle bundle)
        {
            StartActivity(typeof(MainActivity));
            return Task.CompletedTask;
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/BLE.Client.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netstandard2.1</TargetFramework>
    <UserSecretsId>dc141870-cb13-42a9-a9a3-392a54f09990</UserSecretsId>
  </PropertyGroup>

  <ItemGroup>
    <Compile Remove="PagesViewModelsSet\NewFolder1\**" />
    <Compile Remove="PagesViewModelsSet\NewFolder2\**" />
    <EmbeddedResource Remove="PagesViewModelsSet\NewFolder1\**" />
    <EmbeddedResource Remove="PagesViewModelsSet\NewFolder2\**" />
    <None Remove="PagesViewModelsSet\NewFolder1\**" />
    <None Remove="PagesViewModelsSet\NewFolder2\**" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="PagesViewModelsSet\SecurityKill\" />
    <Folder Include="PagesViewModelsSet\SpecialFuction\MagnusS2orS3\" />
    <Folder Include="Properties\" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="MQTTnet" Version="4.3.3.952" />
    <PackageReference Include="MvvmCross" Version="7.1.2" />
    <PackageReference Include="MvvmCross.Forms" Version="7.1.2" />
    <PackageReference Include="TagDataTranslation" Version="1.1.5" />
    <PackageReference Include="Xam.Plugins.Settings" Version="4.1.0-beta" />
    <PackageReference Include="Acr.UserDialogs" Version="6.5.1" />
    <PackageReference Include="PCLStorage" Version="1.0.2" />
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
    <PackageReference Include="Plugin.Share" Version="7.1.1" />
    <PackageReference Include="Prism.Core" Version="8.1.97" />
    <PackageReference Include="Splat" Version="2.0.0" />
    <PackageReference Include="Xamarin.Essentials" Version="1.7.5" />
  </ItemGroup>

  <ItemGroup>
    <None Update="BleMvxFormsApp.xaml">
      <Generator>MSBuild:Compile</Generator>
    </None>
  </ItemGroup>

  <ItemGroup>
    <Compile Remove="ViewModels\ServiceListViewModel.cs" />
    <Compile Remove="ViewModels\CharacteristicDetailViewModel.cs" />
    <Compile Remove="ViewModels\CharacteristicListViewModel.cs" />
    <Compile Remove="ViewModels\DescriptorDetailViewModel.cs" />
    <Compile Remove="ViewModels\DescriptorListViewModel.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\..\Library\CSLibrary\CSLibrary2024-NETStandard.csproj" />
  </ItemGroup>
  <ItemGroup>
    <Compile Update="PagesViewModelsSet\DeviceUnpair\DeviceUnpairPage.xaml.cs">
      <DependentUpon>DeviceUnpairPage.xaml</DependentUpon>
    </Compile>
    <Compile Update="PagesViewModelsSet\SpecialFuction\ASYGN\PageAsygnInventory.xaml.cs">
      <DependentUpon>PageAsygnInventory.xaml</DependentUpon>
    </Compile>
    <Compile Update="PagesViewModelsSet\SpecialFuction\ImpinjSpecialFeatures\PageImpinjSpecialFeaturesProtectedMode.xaml.cs">
      <DependentUpon>PageImpinjSpecialFeaturesProtectedMode.xaml</DependentUpon>
    </Compile>
    <Compile Update="PagesViewModelsSet\SpecialFuction\ImpinjSpecialFeatures\PageImpinjSpecialFeaturesInventory.xaml.cs">
      <SubType>Code</SubType>
      <DependentUpon>PageImpinjSpecialFeaturesInventory.xaml</DependentUpon>
    </Compile>
    <Compile Update="PagesViewModelsSet\SpecialFuction\ImpinjSpecialFeatures\PageImpinjSpecialFeaturesConfig.xaml.cs">
      <SubType>Code</SubType>
      <DependentUpon>PageImpinjSpecialFeaturesConfig.xaml</DependentUpon>
    </Compile>
    <Compile Update="PagesViewModelsSet\SpecialFuction\InventorytoWedgeForwarder\PageInventorytoWedgeForwarderSetting.xaml.cs">
      <DependentUpon>PageInventorytoWedgeForwarderSetting.xaml</DependentUpon>
    </Compile>
    <Compile Update="PagesViewModelsSet\SpecialFuction\InventorytoWedgeForwarder\PageInventorytoWedgeForwarder.xaml.cs">
      <DependentUpon>PageInventorytoWedgeForwarder.xaml</DependentUpon>
    </Compile>
    <Compile Update="PagesViewModelsSet\SpecialFuction\LEDTag\LEDTag.xaml.cs">
      <DependentUpon>LEDTag.xaml</DependentUpon>
    </Compile>
    <Compile Update="PagesViewModelsSet\SpecialFuction\LEDTag\PageLEDTagWithGeiger.xaml.cs">
      <DependentUpon>PageLEDTagWithGeiger.xaml</DependentUpon>
    </Compile>
    <Compile Update="PagesViewModelsSet\SpecialFuction\LEDTag\PageLEDTagWithInventory.xaml.cs">
      <SubType>Code</SubType>
      <DependentUpon>PageLEDTagWithInventory.xaml</DependentUpon>
    </Compile>
    <Compile Update="PagesViewModelsSet\SpecialFuction\MQTT\PageMQTTInventory.xaml.cs">
      <DependentUpon>PageMQTTInventory.xaml</DependentUpon>
    </Compile>
    <Compile Update="PagesViewModelsSet\SpecialFuction\UCODE8\PageUCODE8Inventory.xaml.cs">
      <DependentUpon>PageUCODE8Inventory.xaml</DependentUpon>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Update="PagesViewModelsSet\SpecialFuction\ImpinjSpecialFeatures\PageImpinjSpecialFeaturesInventory.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:UpdateDesignTimeXaml</Generator>
    </EmbeddedResource>
    <EmbeddedResource Update="PagesViewModelsSet\SpecialFuction\ImpinjSpecialFeatures\PageImpinjSpecialFeaturesConfig.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:UpdateDesignTimeXaml</Generator>
    </EmbeddedResource>
    <EmbeddedResource Update="PagesViewModelsSet\SpecialFuction\LEDTag\PageLEDTagWithInventory.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:UpdateDesignTimeXaml</Generator>
    </EmbeddedResource>
  </ItemGroup>
</Project>
</file>

<file path="MobileMvxApp/BLE.Client/BleMvxApplication.cs">
using System;
using System.ComponentModel.Design;
using System.Threading.Tasks;
using BLE.Client.ViewModels;
using CSLibrary;
using MvvmCross;
using MvvmCross.Forms.Core;
using MvvmCross.IoC;
using MvvmCross.Localization;
using MvvmCross.ViewModels;
using Newtonsoft.Json;
using PCLStorage;
using Plugin.BLE.Abstractions.Contracts;
using Xamarin.Forms;
using static CSLibrary.RFIDDEVICE;

namespace BLE.Client

{
    using static FrequencyBand;

    public class CONFIG
    {
        public class MAINMENUSHORTCUT
        {
            public enum FUNCTION
            {
                NONE,
                INVENTORY,
                BARCODE,
            }

            public FUNCTION Function = FUNCTION.NONE;
            public uint DurationMin = 0;
            public uint DurationMax = 0;
        }

        public string readerID = ""; // device GUID
        public MODEL readerModel = MODEL.UNKNOWN;
        public int country = 0;

        public int BatteryLevelIndicatorFormat = 1; // 0 = voltage, other = percentage 

        //public int RFID_Power;
        public uint RFID_Profile;
        public int RFID_CompactInventoryDelayTime; // for CS108 only
        public int RFID_IntraPacketDelayTime;   // for CS710S only
        public CSLibrary.Constants.RadioOperationMode RFID_OperationMode;
        public bool RFID_ToggleTarget = true;
        public CSLibrary.Structures.TagGroup RFID_TagGroup;
        public CSLibrary.Constants.SingulationAlgorithm RFID_Algorithm;
        public CSLibrary.Structures.DynamicQParms RFID_DynamicQParms;
        public CSLibrary.Structures.FixedQParms RFID_FixedQParms;

        public string RFID_Region = "";
        public int RFID_FrequenceSwitch = 0; // 0 = hopping, 1 = fixed, 2 = agile
        public int RFID_FixedChannel = 0;

        // Multi Bank Inventory Setting
        public bool RFID_MBI_MultiBank1Enable;
        public CSLibrary.Constants.MemoryBank RFID_MBI_MultiBank1;
        public UInt16 RFID_MBI_MultiBank1Offset;
        public UInt16 RFID_MBI_MultiBank1Count;
        public bool RFID_MBI_MultiBank2Enable;
        public CSLibrary.Constants.MemoryBank RFID_MBI_MultiBank2;
        public UInt16 RFID_MBI_MultiBank2Offset;
        public UInt16 RFID_MBI_MultiBank2Count;

        // Main Menu Shortcut
        public MAINMENUSHORTCUT[] RFID_Shortcut = new MAINMENUSHORTCUT[6];

        public bool RFID_InventoryAlertSound = true;
        public bool RFID_DBm = true;

        public bool RFID_QOverride = false;
        public uint RFID_TagPopulation = 60;

        // Backend Server
        public bool RFID_SavetoFile = false;
        public bool RFID_SavetoCloud = true;
        public int RFID_CloudProtocol = 0;
        public string RFID_IPAddress;

        public bool RFID_Vibration = false;
        //public bool RFID_VibrationTag = false;      // false = New, true = All // only for CS108
        public uint RFID_VibrationWindow = 2;      // 2 seconds
        public uint RFID_VibrationTime = 300;       // 300 ms

        public bool[] RFID_AntennaEnable = new bool[16] { true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false };
        public uint[] RFID_Antenna_Power = new uint[16] { 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300 };
        public uint[] RFID_Antenna_Dwell = new uint[16] { 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000 };

        public int RFID_PowerSequencing_NumberofPower = 0;
        public uint[] RFID_PowerSequencing_Level = new uint[16] { 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300 };
        public uint[] RFID_PowerSequencing_DWell = new uint[16] { 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000 };

        public bool RFID_NewTagLocation = false;
        public int RFID_ShareFormat = 0;  // 0 = JSON, 1 = CSV, 2 = Excel CSV
        public bool RFID_Focus = false;
        public bool RFID_FastId = false;

        public uint RFID_BatteryPollingTime = 300;

        public string Impinj_AuthenticateServerURL;
        public string Impinj_AuthenticateEmail;
        public string Impinj_AuthenticatePassword;

        public bool _keepScreenOn = false;

        // LNA setting
        //public int RFID_RxAttenuation = 0;
        //public float RFID_MixerGain = 17.2F;
        //public int RFID_PGA1Gain = 12;
        //public int RFID_PGA2Gain = 18;
        //public int RFID_PGA3Gain = 18;

        public byte RFID_DuplicateEliminationRollingWindow = 0;

        public CONFIG(MODEL model)
        {
            int port = 16;

            RFID_TagPopulation = 60;

            RFID_CompactInventoryDelayTime = 0; // for CS108 only
            RFID_IntraPacketDelayTime = 4; // for CS710S only

            RFID_AntennaEnable = new bool[port];
            RFID_Antenna_Power = new uint[port];
            RFID_Antenna_Dwell = new uint[port];
            for (uint cnt = 0; cnt < port; cnt++)
            {
                RFID_Antenna_Power[cnt] = 300;

                if (cnt == 0)
                {
                    RFID_AntennaEnable[0] = true;
                    if (port == 1)
                        RFID_Antenna_Dwell[0] = 0;
                    else
                        RFID_Antenna_Dwell[0] = 2000;
                }
                else
                {
                    RFID_AntennaEnable[cnt] = false;
                    RFID_Antenna_Dwell[cnt] = 2000;
                }
            }

            RFID_OperationMode = CSLibrary.Constants.RadioOperationMode.CONTINUOUS;
            RFID_TagGroup = new CSLibrary.Structures.TagGroup(CSLibrary.Constants.Selected.ALL, CSLibrary.Constants.Session.S0, CSLibrary.Constants.SessionTarget.A);
            RFID_Algorithm = CSLibrary.Constants.SingulationAlgorithm.DYNAMICQ;
            switch (model)
            {
                case MODEL.CS710S:
                    //                  Set profile to 241 if CS710S-1 in application
                    //                    if (country == 1)
                    //                        RFID_Profile = 241;
                    //                    else
                    RFID_Profile = 343;
                    break;

                default:
                    RFID_Profile = 1;
                    break;
            }

            RFID_DynamicQParms = new CSLibrary.Structures.DynamicQParms();
            RFID_DynamicQParms.minQValue = 0;
            RFID_DynamicQParms.startQValue = 7;
            RFID_DynamicQParms.maxQValue = 15;
            RFID_DynamicQParms.toggleTarget = 1;
            RFID_DynamicQParms.MinQCycles = 3;
            RFID_DynamicQParms.QIncreaseUseQuery = true;
            RFID_DynamicQParms.QDecreaseUseQuery = true;
            RFID_DynamicQParms.NoEPCMaxQ = 8;

            RFID_FixedQParms = new CSLibrary.Structures.FixedQParms();
            RFID_FixedQParms.qValue = 7;
            RFID_FixedQParms.toggleTarget = 1;

            RFID_MBI_MultiBank1Enable = false;
            RFID_MBI_MultiBank2Enable = false;
            RFID_MBI_MultiBank1 = CSLibrary.Constants.MemoryBank.TID;
            RFID_MBI_MultiBank1Offset = 0;
            RFID_MBI_MultiBank1Count = 2;
            RFID_MBI_MultiBank2 = CSLibrary.Constants.MemoryBank.USER;
            RFID_MBI_MultiBank2Offset = 0;
            RFID_MBI_MultiBank2Count = 2;

            RFID_InventoryAlertSound = true;
            RFID_QOverride = false;
            RFID_DBm = true;
            RFID_Focus = false;
            RFID_FastId = false;
            RFID_SavetoFile = false;
            RFID_SavetoCloud = true;
            RFID_CloudProtocol = 0;
            RFID_IPAddress = "";

            RFID_Vibration = false;
            //RFID_VibrationTag = false;      // false = New, true = All
            RFID_VibrationWindow = 2;      // 2 seconds
            RFID_VibrationTime = 300;       // 500 ms

            RFID_BatteryPollingTime = 300;  // 300s

            RFID_DuplicateEliminationRollingWindow = 0;

            Impinj_AuthenticateServerURL = "https://democloud.convergence.com.hk/ias";
            Impinj_AuthenticateEmail = "";
            Impinj_AuthenticatePassword = "";

        _keepScreenOn = false;

            for (int cnt = 0; cnt < RFID_Shortcut.Length; cnt++)
            {
                MAINMENUSHORTCUT item = new MAINMENUSHORTCUT();

                switch (cnt)
                {
                    case 0:
                        item.Function = MAINMENUSHORTCUT.FUNCTION.INVENTORY;
                        item.DurationMin = 0;
                        item.DurationMax = 500;
                        break;
                    case 1:
                        item.Function = MAINMENUSHORTCUT.FUNCTION.BARCODE;
                        item.DurationMin = 500;
                        item.DurationMax = 10000;
                        break;
                }

                RFID_Shortcut[cnt] = item;
            }
        }
    }

    public class BleMvxApplication : MvxApplication
    {
        static public HighLevelInterface _reader = new HighLevelInterface();
        public static CONFIG _config;

        // System
        public static IDevice _deviceinfo;

        // for Geiger and Read/Write
        public static string _SELECT_EPC = "";
        public static string _SELECT_TID = "";
        public static UInt16 _SELECT_PC = 0x0000;

        // for PreFilter
        public static string _PREFILTER_MASK_EPC = "";
        public static uint _PREFILTER_MASK_Offset = 0;
        public static int _PREFILTER_MASK_Truncate = 0;
        public static int _PREFILTER_Bank = 1;
        public static bool _PREFILTER_Enable = false;

        // for Post Filter
        public static string _POSTFILTER_MASK_EPC = "";
        public static uint _POSTFILTER_MASK_Offset = 0;
        public static bool _POSTFILTER_MASK_MatchNot = false;
        public static bool _POSTFILTER_MASK_Enable = false;

        // for RSSI Filter
        public static CSLibrary.Constants.RSSIFILTERTYPE _RSSIFILTER_Type = CSLibrary.Constants.RSSIFILTERTYPE.DISABLE;
        public static CSLibrary.Constants.RSSIFILTEROPTION _RSSIFILTER_Option = CSLibrary.Constants.RSSIFILTEROPTION.GREATEROREQUAL;
        public static double _RSSIFILTER_Threshold_dBm = 0;

        public static int _inventoryEntryPoint = 0;
        public static bool _settingPage1TagPopulationChanged = false;
        public static bool _settingPage3QvalueChanged = false;
        public static bool _settingPage4QvalueChanged = false;

        // for Cloud server
        public static UInt16 _sequenceNumber = 0;

        // for battery level display
        public static bool _batteryLow = false;

        // for RFMicro
        public static int _rfMicro_TagType; // 0 = S2, 1 = S3, 2 = Axzon
        public static int _rfMicro_Power; // 0 ~ 4
        public static int _rfMicro_Target; // 0 = A, 1 = B, 2 = Toggle
        public static int _rfMicro_SensorType; // 0=Sensor code, 1=Temperature
        public static int _rfMicro_SensorUnit; // 0 = Average value, 1 = RAW, 2 = Temperature F, 3 = Temperature C, 4 = Dry/Wet
        public static int _rfMicro_minOCRSSI;
        public static int _rfMicro_maxOCRSSI;
        public static int _rfMicro_thresholdComparison; // 0 ~ 1
        public static int _rfMicro_thresholdValue;
        public static string _rfMicro_thresholdColor;
        public static int _rfMicro_WetDryThresholdValue;

        //for ColdChain
        public static int _coldChain_TempOffset;
        public static int _coldChain_Temp1THUnder;
        public static int _coldChain_Temp1THOver;
        public static int _coldChain_Temp1THCount;
        public static int _coldChain_Temp2THUnder;
        public static int _coldChain_Temp2THOver;
        public static int _coldChain_Temp2THCount;
        public static int _coldChain_LogInterval;

        // for Xerxes Tag
        //public static int _xerxes_Power;
        //public static int _xerxes_Target;
        public static int _xerxes_delay;

        // for Focus and Fast ID
        public static Boolean _focus = false;
        public static Boolean _fastID = false;

        // for Geiger Demo 
        public static int _geiger_Bank = 1;

        // for Large Content
        public static string _LargeContent = "";

        // LED Tag
        public static bool _LEDTag_Selected = false;

        // Wedge Forwarder
        public static string _WedgeIP = "127.0.0.1";
        public static int _WedgePort = 9394;
        public static int _WedgeDuplicateFilter = 0;
        public static int _WedgeRollingWindows = 1;

        public override void Initialize()
        {
            CreatableTypes()
                .EndingWith("Service")
                .AsInterfaces()
                .RegisterAsLazySingleton();

            RegisterAppStart<ViewModelMainMenu>();
        }

        //static async public void LoadConfig(string readerID)
        static public async Task<bool> LoadConfig(string readerID, MODEL model)
        {
            try
            {
                IFolder rootFolder = FileSystem.Current.LocalStorage;
                IFolder sourceFolder = await FileSystem.Current.LocalStorage.CreateFolderAsync("CSLReader", CreationCollisionOption.OpenIfExists);
                IFile sourceFile = await sourceFolder.CreateFileAsync(readerID + ".cfg", CreationCollisionOption.OpenIfExists);

                var contentJSON = await sourceFile.ReadAllTextAsync();
                var setting = JsonConvert.DeserializeObject<CONFIG>(contentJSON);

                _RSSIFILTER_Type = CSLibrary.Constants.RSSIFILTERTYPE.DISABLE;
                _PREFILTER_Enable = false;
                _POSTFILTER_MASK_Enable = false;

                if (setting != null)
                {
                    _config = setting;
                    return true;
                }
                else
                {
                    _config = new CONFIG(model);
                }
            }
            catch (Exception ex)
            {
            }
            return false;
        }

        static async public void SaveConfig()
        {
            IFolder rootFolder = FileSystem.Current.LocalStorage;
            IFolder sourceFolder = await FileSystem.Current.LocalStorage.CreateFolderAsync("CSLReader", CreationCollisionOption.OpenIfExists);
            IFile sourceFile = await sourceFolder.CreateFileAsync(_config.readerID + ".cfg", CreationCollisionOption.ReplaceExisting);

            string contentJSON = JsonConvert.SerializeObject(_config);
            await sourceFile.WriteAllTextAsync(contentJSON);
        }

        static public void ResetConfig(uint port = 1)
        {
            var readerID = _config.readerID;
            var readerModel = _config.readerModel;
            var country = _config.country;
            _config = new CONFIG(_config.readerModel);
            _config.readerID = readerID;
            _config.readerModel = readerModel;
            _config.country = country;
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/BleMvxFormsApp.xaml.cs">
using MvvmCross;
using MvvmCross.Forms.Core;
using Plugin.BLE.Abstractions;

namespace BLE.Client
{
    public partial class BleMvxFormsApp : MvxFormsApplication
    {
        public BleMvxFormsApp()
        {
            InitializeComponent();
        }

        protected override void OnStart()
        {
            base.OnStart();
            Trace.Message("App Start");
        }

        protected override void OnResume()
        {
            base.OnResume();
            Trace.Message("App Resume");
        }

        protected override void OnSleep()
        {
            base.OnSleep();
            Trace.Message("App Sleep");
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/ClassBattery.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BLE.Client
{
    public static class ClassBattery
    {
        public enum BATTERYMODE
        {
            INVENTORY = 1,
            IDLE = 2,
        }

        public enum BATTERYLEVELSTATUS
        {
            NORMAL = 0,
            LOW = 1,
        }



        // for inventory mode
        readonly static double[] voltageTable1 = new double[] { 4.106, 4.017, 3.98, 3.937, 3.895, 3.853, 3.816, 3.779, 3.742, 3.711, 3.679, 3.658, 3.637, 3.626, 3.61, 3.584, 3.547, 3.515, 3.484, 3.457, 3.431, 3.399, 3.362, 3.32, 3.251, 3.135 };
        readonly static double[] capacityTable1 = new double[] {  100,    96,   92,    88,    84,    80,    76,    72,    67,    63,    59,    55,    51,    47,   43,    39,    35,    31,    27,    23,    19,    15,    11,    7,     2,     0 };
        //readonly static double[] voltageTable1 = new double[] { 3.921, 3.890, 3.863, 3.826, 3.795, 3.768, 3.742, 3.721, 3.700, 3.679, 3.652, 3.642, 3.621, 3.605, 3.589, 3.573, 3.563, 3.557, 3.552, 3.536, 3.526, 3.520, 3.499, 3.478, 3.457, 3.415, 3.241, 2.612 };
        //readonly static double[] capacityTable1 = new double[] { 100, 99, 98, 97, 96, 94, 92, 89, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 24, 20, 16, 13, 9, 6, 2, 0 };
        readonly static double[] voltageSlope1 = new double[voltageTable1.Length - 1];

        // for non-inventory mode
        readonly static double[] voltageTable2 = new double[] { 4.212, 4.175, 4.154, 4.133, 4.112, 4.085, 4.069, 4.054, 4.032, 4.011, 3.99, 3.969, 3.953, 3.937, 3.922, 3.901, 3.885, 3.869, 3.853, 3.837, 3.821, 3.806, 3.79, 3.774, 3.769, 3.763, 3.758, 3.753, 3.747, 3.742, 3.732, 3.721, 3.705, 3.684, 3.668, 3.652, 3.642, 3.626, 3.615, 3.605, 3.594, 3.584, 3.568, 3.557, 3.542, 3.531, 3.510, 3.494, 3.473, 3.457, 3.436, 3.41, 3.362, 3.235, 2.987, 2.982 };
        readonly static double[] capacityTable2 = new double[] {  100,    98,    96,    95,    93,    91,    89,    87,    85,    84,   82,    80,    78,    76,    75,    73,    71,    69,    67,    65,    64,    62,   60,    58,    56,    55,    53,    51,    49,    47,    45,    44,    42,    40,    38,    36,    35,    33,    31,    29,    27,    25,    24,    22,    20,    18,    16,    15,    13,    11,     9,    7,     5,     4,     2,     0 };
        //readonly static double[] voltageTable2 = new double[] { 4.048, 4.032, 4.011, 3.995, 3.974, 3.964, 3.948, 3.932, 3.911, 3.895, 3.879, 3.863, 3.853, 3.842, 3.826, 3.811, 3.800, 3.784, 3.774, 3.758, 3.747, 3.737, 3.726, 3.721, 3.710, 3.705, 3.695, 3.689, 3.684, 3.679, 3.673, 3.668, 3.663, 3.658, 3.658, 3.652, 3.647, 3.642, 3.636, 3.631, 3.626, 3.615, 3.605, 3.594, 3.578, 3.573, 3.563, 3.552, 3.504, 3.394, 3.124, 2.517 };
        //readonly static double[] capacityTable2 = new double[] { 100, 99, 98, 97, 95, 93, 90, 87, 84, 81, 78, 75, 73, 71, 69, 68, 66, 64, 62, 60, 58, 56, 54, 52, 50, 48, 47, 45, 43, 41, 39, 37, 35, 33, 31, 29, 27, 26, 24, 22, 20, 18, 16, 14, 12, 10, 8, 6, 5, 3, 1, 0 };
        readonly static double[] voltageSlope2 = new double[voltageTable2.Length - 1];

        static double[] voltageTable;
        static double[] capacityTable;
        static double[] voltageSlope;

        static BATTERYMODE _currentInventoryMode;

        static ClassBattery()
        {
            int cnt;

            for (cnt = 0; cnt < voltageTable1.Length - 2; cnt++)
                voltageSlope1[cnt] = (capacityTable1[cnt] - capacityTable1[cnt + 1]) / (voltageTable1[cnt] - voltageTable1[cnt + 1]);

            for (cnt = 0; cnt < voltageTable2.Length - 2; cnt++)
                voltageSlope2[cnt] = (capacityTable2[cnt] - capacityTable2[cnt + 1]) / (voltageTable2[cnt] - voltageTable2[cnt + 1]);

            SetBatteryMode(BATTERYMODE.IDLE);
        }

        public static void SetBatteryMode(BATTERYMODE bm)
        {
            _currentInventoryMode = bm;

            if (bm == BATTERYMODE.INVENTORY)
            {
                voltageTable = voltageTable1;
                capacityTable = capacityTable1;
                voltageSlope = voltageSlope1;
            }
            else
            {
                voltageTable = voltageTable2;
                capacityTable = capacityTable2;
                voltageSlope = voltageSlope2;
            }
        }

        public static BATTERYLEVELSTATUS BatteryLow(double voltage)
        {
            if (Voltage2Percent(voltage) <= 20.0)
                return BATTERYLEVELSTATUS.LOW;

#if old
            if (_currentInventoryMode == BATTERYMODE.INVENTORY)
            {
                if (voltage <= 3.515)
                {
                    return BATTERYLEVELSTATUS.LOW;
                }
            }
            else
            {
                if (voltage <= 3.652)
                {
                    return BATTERYLEVELSTATUS.LOW;
                }
            }
#endif

            return BATTERYLEVELSTATUS.NORMAL;
        }

        public static double Voltage2Percent(double voltage)
        {
            int cnt;

            if (voltage > voltageTable[0])
                return 100;

            if (voltage <= voltageTable[voltageTable.Length - 1])
                return 0;

            for (cnt = voltageTable.Length - 2; cnt >= 0; cnt--)
            {
                if (voltage > voltageTable[cnt])
                    continue;

                if (voltage == voltageTable[cnt])
                    return capacityTable[cnt];

                double percent = 0;

                percent = (voltage - voltageTable[cnt + 1]) * voltageSlope[cnt] + capacityTable[cnt + 1];

                return percent;
            }

            return 0;
        }
    }






    /* for old formula    

    #if oldMode
        14% Battery Life Left, Please Recharge RFID Reader or Replace with Freshly Charged Battery
    #else


        public static class ClassBattery
        {
            public enum BATTERYMODE
            {
                INVENTORY = 1,
                IDLE = 2,
            }

            public enum BATTERYLEVELSTATUS
            {
                NORMAL = 0,
                LOW = 1,
                LOW_17 = 2
            }

            // battery table for PCB version below of 1.7
            readonly static double voltageFirstOffset0 = 100.0 / 90 * 5;
            readonly static double[] voltageTable0 = new double[] { 3.4, 3.457, 3.468, 3.489, 3.494, 3.515, 3.541, 3.566, 3.578, 3.610, 3.615, 3.668, 3.7, 3.731, 3.753, 3.790, 3.842, 3.879, 4.0 };
            readonly static double[] voltageSlope0 = new double[voltageTable0.Length - 1];
            readonly static double voltagestep0 = (100.0 - voltageFirstOffset0) / (voltageTable0.Length - 2);

            // battery table for PCB version of 1.7 or above and inventory mode
            readonly static double voltageFirstOffset1 = 100.0 / 134 * 4;
            readonly static double[] voltageTable1 = new double[] { 2.789, 3.304, 3.452, 3.489, 3.515, 3.534, 3.554, 3.563, 3.578, 3.584, 3.594, 3.61, 3.625, 3.652, 3.652, 3.673, 3.7, 3.725, 3.747, 3.769, 3.8, 3.826, 3.858, 3.89, 3.972, 3.964, 4.001, 4.069 };
            readonly static double[] voltageSlope1 = new double[voltageTable1.Length - 1];
            readonly static double voltagestep1 = (100.0 - voltageFirstOffset1) / (voltageTable1.Length - 2);

            // battery table for PCB version of 1.7 or above and idle mode
            readonly static double voltageFirstOffset2 = 100.0 / 534 * 4;
            readonly static double[] voltageTable2 = new double[] { 2.322, 3.156, 3.452, 3.563, 3.605, 3.626, 3.631, 3.642, 3.652, 3.668, 3.679, 3.689, 3.700, 3.705, 3.710, 3.716, 3.721, 3.724, 3.726, 3.731, 3.737, 3.742, 3.747, 3.753, 3.758, 3.763, 3.774, 3.779, 3.784, 3.798, 3.805, 3.816, 3.826, 3.842, 3.853, 3.863, 3.879, 3.895, 3.906, 3.921, 3.937, 3.948, 3.964, 3.980, 4.001, 4.018, 4.032, 4.048, 4.064, 4.085, 4.097, 4.117, 4.138, 4.185, 4.190 };
            readonly static double[] voltageSlope2 = new double[voltageTable2.Length - 1];
            readonly static double voltagestep2 = (100.0 - voltageFirstOffset2) / (voltageTable2.Length - 2);

            static double voltageFirstOffset;
            static double[] voltageTable;
            static double[] voltageSlope;
            static double voltagestep;

            static BATTERYMODE _currentInventoryMode;

            static ClassBattery()
            {
                int cnt;

                for (cnt = 0; cnt < voltageTable0.Length - 1; cnt++)
                    voltageSlope0[cnt] = voltagestep0 / (voltageTable0[cnt + 1] - voltageTable0[cnt]);

                for (cnt = 0; cnt < voltageTable1.Length - 1; cnt++)
                    voltageSlope1[cnt] = voltagestep1 / (voltageTable1[cnt + 1] - voltageTable1[cnt]);

                for (cnt = 0; cnt < voltageTable2.Length - 1; cnt++)
                    voltageSlope2[cnt] = voltagestep2 / (voltageTable2[cnt + 1] - voltageTable2[cnt]);

                SetBatteryMode(BATTERYMODE.IDLE);
            }

            public static void SetBatteryMode(BATTERYMODE bm)
            {
                _currentInventoryMode = bm;

                if (string.Compare (BleMvxApplication._reader.siliconlabIC.GetPCBVersion(), "180") < 0 )
                {
                    voltageFirstOffset = voltageFirstOffset0;
                    voltageTable = voltageTable0;
                    voltageSlope = voltageSlope0;
                    voltagestep = voltagestep0;
                }
                else
                {
                    if (bm == BATTERYMODE.INVENTORY)
                    {
                        voltageFirstOffset = voltageFirstOffset1;
                        voltageTable = voltageTable1;
                        voltageSlope = voltageSlope1;
                        voltagestep = voltagestep1;
                    }
                    else
                    {
                        voltageFirstOffset = voltageFirstOffset2;
                        voltageTable = voltageTable2;
                        voltageSlope = voltageSlope2;
                        voltagestep = voltagestep2;
                    }
                }
            }

            public static BATTERYLEVELSTATUS BatteryLow (double voltage)
            {
                return BATTERYLEVELSTATUS.NORMAL;

                if (string.Compare(BleMvxApplication._reader.siliconlabIC.GetPCBVersion(), "180") < 0)
                {
                    if (_currentInventoryMode == BATTERYMODE.INVENTORY)
                    {
                        if (voltage <= 3.45)
                        {
                            return BATTERYLEVELSTATUS.LOW_17;
                        }
                    }
                    else
                    {
                        if (voltage <= 3.6)
                        {
                            return BATTERYLEVELSTATUS.LOW_17;
                        }
                    }
                }
                else
                {
                    if (_currentInventoryMode == BATTERYMODE.INVENTORY)
                    {
                        if (voltage <= 3.515)
                        {
                            return BATTERYLEVELSTATUS.LOW;
                        }
                    }
                    else
                    {
                        if (voltage <= 3.652)
                        {
                            return BATTERYLEVELSTATUS.LOW;
                        }
                    }
                }

                return BATTERYLEVELSTATUS.NORMAL;
            }

            public static double Voltage2Percent(double voltage)
            {
                int cnt;

                if (voltage > voltageTable[0])
                {
                    if (voltage > voltageTable[1])
                    {
                        for (cnt = voltageTable.Length - 1; cnt >= 0; cnt--)
                        {
                            if (voltage > voltageTable[cnt])
                            {
                                if (cnt == voltageTable.Length - 1)
                                    return 100;

                                double percent = 0;

                                percent = (voltagestep * (cnt - 1) + voltageFirstOffset) + ((voltage - voltageTable[cnt]) * voltageSlope[cnt]);

                                return percent;
                            }
                        }
                    }
                    else
                    {
                        double percent = ((voltage - voltageTable[0]) * voltageSlope[0]);
                        return percent;
                    }
                }

                return 0;
            }
        }
    #endif

    */
}
</file>

<file path="MobileMvxApp/BLE.Client/Converters/InverseBooleanValueConverter.cs">
using System;
using System.Globalization;
using MvvmCross.Converters;
using Xamarin.Forms;

namespace BLE.Client.Converters
{
    public class InverseBooleanValueConverter : MvxValueConverter<bool, bool>, IValueConverter
    {
        protected override bool Convert(bool value, Type targetType, object parameter, CultureInfo culture)
        {
            return !value;
        }

        protected override bool ConvertBack(bool value, Type targetType, object parameter, CultureInfo culture)
        {
            return !value;
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/Extensions/IUserDialogsExtensions.cs">
using System;
using System.Drawing;
using Acr.UserDialogs;

namespace BLE.Client.Extensions
{
    public static class IUserDialogsExtensions
    {
        public static IDisposable ErrorToast(this IUserDialogs dialogs, string title, string message, TimeSpan duration)
        {
            //return dialogs.Toast(new ToastConfig(message) { BackgroundColor =  System.Drawing.Color.Red, Duration = duration });
            return dialogs.Toast(new ToastConfig(message) { Duration = duration });
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/Helpers/Settings.cs">
// Helpers/Settings.cs
using Plugin.Settings;
using Plugin.Settings.Abstractions;

namespace BLE.Client.Helpers
{
	/// <summary>
	/// This is the Settings static class that can be used in your Core solution or in any
	/// of your client applications. All settings are laid out the same exact way with getters
	/// and setters. 
	/// </summary>
	public static class Settings
	{
		private static ISettings AppSettings
		{
			get
			{
				return CrossSettings.Current;
			}
		}

		#region Setting Constants

		private const string SettingsKey = "settings_key";
		private static readonly string SettingsDefault = string.Empty;

		#endregion


		public static string GeneralSettings
		{
			get
			{
				return AppSettings.GetValueOrDefault(SettingsKey, SettingsDefault);
			}
			set
			{
				AppSettings.AddOrUpdateValue(SettingsKey, value);
			}
		}

	}
}
</file>

<file path="MobileMvxApp/BLE.Client/InterfaceIAppVersion.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BLE.Client
{
    public interface IAppVersion
    {
        string GetVersion();
        int GetBuild();
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/InterfaceIBatteryOptimizationService.cs">
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;

namespace BLE.Client
{
    public interface IBatteryOptimizationService
    {
        bool IsBatteryOptimizationDisabled();
        Task OpenBatteryOptimizationsAsync();
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/InterIExternalStorage.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BLE.Client
{
    public interface IExternalStorage
    {
        string GetPath();

        public void SaveTextFileToDocuments(string fileName, string content, int fileType);
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/InterISystemSound.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BLE.Client
{
    public interface ISystemSound
    {
        void SystemSound(int id);
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/Pages/DeviceListPage.xaml.cs">
using BLE.Client.ViewModels;
using MvvmCross.Forms.Presenters.Attributes;
using MvvmCross.Forms.Views;
using System;

namespace BLE.Client.Pages
{
    [MvxContentPagePresentation(WrapInNavigationPage = true, NoHistory = false, Animated = true)]
    public partial class DeviceListPage : MvxTabbedPage<DeviceListViewModel>
    {
        public DeviceListPage()
        {
            InitializeComponent();
        }

        public async void buttonWarningMessageClicked(object sender, EventArgs e)
        {
            await DisplayAlert(null, "Cannot find your reader?" + Environment.NewLine+ Environment.NewLine +
                "1) Please check if it is still in OS Bluetooth device list. If yes, please \"forget\" it" + Environment.NewLine +
                "2) Please make sure reader is in normal mode (Bluetooth LED slow flashing)" + Environment.NewLine +
                "3) Turn off and turn on Bluetooth on your phone",
                "OK");
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/Pages/PageViewPage.xaml.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using BLE.Client.ViewModels;
using MvvmCross.Forms.Views;

namespace BLE.Client.Pages
{
    public partial class PageViewPage : MvxContentPage<ViewModelViewPage>
    {
        string[] _DisplayModeOptions = { "Text Mode", "Line Mode" };

        public PageViewPage()
        {
            InitializeComponent();

            labelViewCharLength.Text = "Totel Characters : " + BleMvxApplication._LargeContent.Length.ToString();
            labelViewBitLength.Text = "Number of bits : " + (BleMvxApplication._LargeContent.Length * 4).ToString();
            labelViewByteLength.Text = "Number of bytes : " + BleMvxApplication._LargeContent.Length.ToString();
            labelViewWordLength.Text = "Number of words : " + (BleMvxApplication._LargeContent.Length / 4).ToString();

            buttonDisplayMode.Text = _DisplayModeOptions[1];
            //editorContent.Text = BleMvxApplication._LargeContent;
        }

        public async void buttonDisplayModeClicked(object sender, EventArgs args)
        {
            var answer = await DisplayActionSheet("Display Mode", "Cancel", null, _DisplayModeOptions);

            if (answer != null && answer != "Cancel")
            {
                buttonDisplayMode.Text = answer;
            }
        }

        public async void buttonDisplayModePropertyChanged(object sender, EventArgs args)
        {
            if (buttonDisplayMode != null)
            {
                switch (Array.IndexOf(_DisplayModeOptions, buttonDisplayMode.Text))
                {
                    case 0:
                        editorContent.Text = BleMvxApplication._LargeContent;
                        break;

                    case 1:
                        editorContent.Text = "";

                        if (BleMvxApplication._LargeContent.Length > 0)
                        {
                            int lineLength = 20;

                            for (int cnt = 0; cnt < BleMvxApplication._LargeContent.Length; cnt += lineLength)
                            {
                                if (cnt + lineLength <= BleMvxApplication._LargeContent.Length)
                                    editorContent.Text += cnt.ToString() + " : "+ BleMvxApplication._LargeContent.Substring(cnt, lineLength);
                                else
                                    editorContent.Text += cnt.ToString() + " : " + BleMvxApplication._LargeContent.Substring(cnt, BleMvxApplication._LargeContent.Length - cnt);

                                editorContent.Text += Environment.NewLine;
                            }
                        }
                        break;
				}
			}
        }

    }
}
</file>

<file path="MobileMvxApp/BLE.Client/PagesViewModelsSet/GeigerSearch/PageGeiger.xaml.cs">
using System;
using BLE.Client.ViewModels;
using MvvmCross.Forms.Views;

namespace BLE.Client.Pages
{
    public partial class PageGeiger : MvxContentPage<ViewModelGeiger>
    {
        static string[] _bankSelectionItems = new string[] { "Security (Bank 0)", "EPC (Bank 1)", "TID (Bank 2)", "User (Bank 3)" };
        static uint _rssi;

        public PageGeiger()
        {
            InitializeComponent();

            if (BleMvxApplication._config.RFID_DBm)
            {
                labelThreshold.Text = "Threshold dBm";
                sliderThreshold.Minimum = -90;
                sliderThreshold.Maximum = -10;
                sliderThreshold.Value = -47;
            }
            else
            {
                labelThreshold.Text = "Threshold dBuV";
                sliderThreshold.Minimum = 17;
                sliderThreshold.Maximum = 97;
                sliderThreshold.Value = 60;
            }

            BleMvxApplication._geiger_Bank = 1;
            buttonBank.Text = _bankSelectionItems[1];
        }

        public async void buttonBankClicked(object sender, EventArgs e)
        {
            var answer = await DisplayActionSheet("", "Cancel", null, _bankSelectionItems);

            if (answer != null && answer != "Cancel")
            {
                if (buttonBank.Text != answer)
                {
                    buttonBank.Text = answer;
                    BleMvxApplication._geiger_Bank = int.Parse(buttonBank.Text.Substring(buttonBank.Text.Length - 2, 1));
                    switch (BleMvxApplication._geiger_Bank)
                    {
                        case 1: // EPC
                            entryMask.Text = BleMvxApplication._SELECT_EPC;
                            break;

                        case 2: // TID
                            if (BleMvxApplication._SELECT_TID.Length != 0)
                                entryMask.Text = BleMvxApplication._SELECT_TID;
                            break;
                    }
                }
            }
        }

        public async void entryPowerCompleted(object sender, EventArgs e)
        {
            uint value;

            try
            {
                value = uint.Parse(entryPower.Text);
                if (value < 0 || value > 300)
                    throw new System.ArgumentException("Value not valid", "tagPopulation");
                entryPower.Text = value.ToString();
            }
            catch (Exception ex)
            {
                await DisplayAlert("", "Value not valid!!!", "OK");
                entryPower.Text = "300";
            }
        }

        void sliderThresholdValueChanged(object sender, EventArgs e)
        {
            labelThresholdValue.Text = ((int)(sliderThreshold.Value)).ToString();
        }

        void RssiPropertyChanged(object sender, EventArgs e)
        {
            try
            {
                progressbarRSSI.Progress = (double.Parse(Rssi.Text) - sliderThreshold.Minimum) / (sliderThreshold.Maximum - sliderThreshold.Minimum);
                //progressbarRSSI.Progress = 0.5;
            }
            catch (Exception ex) { }
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/PagesViewModelsSet/GeigerSearch/ViewModelGeiger.cs">
using System;
using Acr.UserDialogs;
using Plugin.BLE.Abstractions.Contracts;

using System.Windows.Input;
using Xamarin.Forms;
using MvvmCross.ViewModels;
using BLE.Client.ViewModels;

namespace BLE.Client.ViewModels
{
    public class ViewModelGeiger : BaseViewModel
    {
        private readonly IUserDialogs _userDialogs;

        public ICommand OnStartGeigerButtonCommand { protected set; get; }

        private int _rssidBuV = 0;
        private string _rssiString = "RSSI";
        public string rssiStart { get { return _rssiString; } }

        double _progressbarRSSIValue = 0;
        public double progressbarRSSIValue { get { return _progressbarRSSIValue; } }

        private string _startGeigerButtonText = "Start";
        public string startGeigerButtonText { get { return _startGeigerButtonText; } }

        private int _buttonBank = 1;
        public int buttonBank { get { return _buttonBank; } set { _buttonBank = value; } }

        private string _entryEPC;
        public string entryEPC { get { return _entryEPC; } set { _entryEPC = value; } }

        private uint _power = 300;
        public uint power { get { return _power; } set { _power = value; } }

        private int _Threshold = 0;
        public string labelThresholdValueText { get { return _Threshold.ToString(); } set { try { _Threshold = int.Parse(value); } catch (Exception ex) { } } }


        // end for test

        bool _startInventory = false;
        public bool _KeyDown = false;
        int _beepSoundCount = 0;
        int _noTagCount = 0;

        public ViewModelGeiger(IAdapter adapter, IUserDialogs userDialogs) : base(adapter)
        {
            _userDialogs = userDialogs;

            _entryEPC = BleMvxApplication._SELECT_EPC;

            OnStartGeigerButtonCommand = new Command(StartGeigerButtonClick);

            RaisePropertyChanged(() => entryEPC);
            _Threshold = BleMvxApplication._config.RFID_DBm ? -47 : 60;

            InventorySetting();
        }

        ~ViewModelGeiger()
        {
        }

        private void SetEvent(bool enable)
        {
            // Cancel RFID event handler
            BleMvxApplication._reader.rfid.ClearEventHandler();

            // Key Button event handler
            BleMvxApplication._reader.notification.ClearEventHandler();

            if (enable)
            {
                BleMvxApplication._reader.rfid.OnAsyncCallback += new EventHandler<CSLibrary.Events.OnAsyncCallbackEventArgs>(TagSearchOneEvent);

                // Key Button event handler
                BleMvxApplication._reader.notification.OnKeyEvent += new EventHandler<CSLibrary.Notification.HotKeyEventArgs>(HotKeys_OnKeyEvent);
            }
        }

        public override void ViewAppearing()
        {
            base.ViewAppearing();
            SetEvent(true);
        }

        public override void ViewDisappearing()
        {
            // don't turn off event handler is you need program work in sleep mode.
            StopGeiger();
            SetEvent(false);
            base.ViewDisappearing();
        }

        protected override void InitFromBundle(IMvxBundle parameters)
        {
            base.InitFromBundle(parameters);
        }

        void InventorySetting()
        {
            // Cancel old setting
            BleMvxApplication._reader.rfid.CancelAllSelectCriteria();
            BleMvxApplication._reader.rfid.SetPowerSequencing(0);

            // Set Geiger parameters
            BleMvxApplication._reader.rfid.SetInventoryDuration(BleMvxApplication._config.RFID_Antenna_Dwell);
            BleMvxApplication._reader.rfid.SetTagDelayTime((uint)BleMvxApplication._config.RFID_CompactInventoryDelayTime); // for CS108 only
            BleMvxApplication._reader.rfid.SetIntraPacketDelayTime((uint)BleMvxApplication._config.RFID_IntraPacketDelayTime); // for CS710S only
            BleMvxApplication._reader.rfid.SetDuplicateEliminationRollingWindow(0);
            BleMvxApplication._config.RFID_FixedQParms.qValue = 1;
            BleMvxApplication._config.RFID_FixedQParms.toggleTarget = 1;
            BleMvxApplication._reader.rfid.SetFixedQParms(BleMvxApplication._config.RFID_FixedQParms);
            BleMvxApplication._reader.rfid.SetCurrentSingulationAlgorithm(CSLibrary.Constants.SingulationAlgorithm.FIXEDQ);
            BleMvxApplication._reader.rfid.SetRSSIFilter(CSLibrary.Constants.RSSIFILTERTYPE.DISABLE);

            // Multi bank inventory
            BleMvxApplication._reader.rfid.Options.TagRanging.flags = CSLibrary.Constants.SelectFlags.SELECT;
            BleMvxApplication._reader.rfid.Options.TagRanging.multibanks = 0;
            BleMvxApplication._reader.rfid.Options.TagRanging.compactmode = true;
            BleMvxApplication._reader.rfid.Options.TagRanging.focus = BleMvxApplication._config.RFID_Focus;
        }


        void StartGeiger()
        {
            if (_startInventory)
                return;

            _startGeigerButtonText = "Stop";
            _startInventory = true;

            RaisePropertyChanged(() => entryEPC);
            RaisePropertyChanged(() => power);

            BleMvxApplication._reader.rfid.SetPowerLevel(_power);

            BleMvxApplication._reader.rfid.Options.TagSelected.flags = CSLibrary.Constants.SelectMaskFlags.ENABLE_TOGGLE;
            if (BleMvxApplication._geiger_Bank == 1) // if EPC
            {
                BleMvxApplication._reader.rfid.Options.TagSelected.bank = CSLibrary.Constants.MemoryBank.EPC;
                BleMvxApplication._reader.rfid.Options.TagSelected.epcMask = new CSLibrary.Structures.S_MASK(_entryEPC);
                BleMvxApplication._reader.rfid.Options.TagSelected.epcMaskOffset = 0;
                BleMvxApplication._reader.rfid.Options.TagSelected.epcMaskLength = (uint)_entryEPC.Length * 4;
            }
            else
            {
                BleMvxApplication._reader.rfid.Options.TagSelected.bank = (CSLibrary.Constants.MemoryBank)BleMvxApplication._geiger_Bank;
                BleMvxApplication._reader.rfid.Options.TagSelected.Mask = CSLibrary.Tools.HexEncoding.ToBytes(_entryEPC);
                BleMvxApplication._reader.rfid.Options.TagSelected.MaskOffset = 0;
                BleMvxApplication._reader.rfid.Options.TagSelected.MaskLength = (uint)_entryEPC.Length * 4;
            }
            BleMvxApplication._reader.rfid.StartOperation(CSLibrary.Constants.Operation.TAG_SELECTED);

            BleMvxApplication._reader.rfid.StartOperation(CSLibrary.Constants.Operation.TAG_RANGING);

            RaisePropertyChanged(() => startGeigerButtonText);

            // Create a beep sound timer.
            _beepSoundCount = 0;
            Device.StartTimer(TimeSpan.FromMilliseconds(50), () =>
            {
                if (_rssidBuV == 0)
                {
                    _noTagCount++;

                    if (_noTagCount > 2)
                        DependencyService.Get<ISystemSound>().SystemSound(-1);
                }
                else
                {
                    if (_beepSoundCount == 0 && _rssidBuV >= 20 && _rssidBuV < 60)
                        //if (_beepSoundCount == 0)
                        DependencyService.Get<ISystemSound>().SystemSound(3);

                    _beepSoundCount++;

                    if ((BleMvxApplication._config.RFID_DBm && CSLibrary.Tools.dBConverion.dBuV2dBm(_rssidBuV) >= _Threshold) ||
                        (!BleMvxApplication._config.RFID_DBm && _rssidBuV >= _Threshold))
                    {
                        DependencyService.Get<ISystemSound>().SystemSound(4);
                        _beepSoundCount = 1;
                        _rssidBuV = 0;
                    }
                    else if (_rssidBuV >= 50)
                    {
                        if (_beepSoundCount >= 5)
                        {
                            _beepSoundCount = 0;
                            _rssidBuV = 0;
                        }
                    }
                    else if (_rssidBuV >= 40)
                    {
                        if (_beepSoundCount >= 10)
                        {
                            _beepSoundCount = 0;
                            _rssidBuV = 0;
                        }
                    }
                    else if (_rssidBuV >= 30)
                    {
                        if (_beepSoundCount >= 20)
                        {
                            _beepSoundCount = 0;
                            _rssidBuV = 0;
                        }
                    }
                    else if (_rssidBuV >= 20)
                    {
                        if (_beepSoundCount >= 40)
                        {
                            _beepSoundCount = 0;
                            _rssidBuV = 0;
                        }
                    }
                }

                if (_startInventory)
                    return true;

                // Stop all sound
                DependencyService.Get<ISystemSound>().SystemSound(-1);
                return false;
            });
        }

        void StopGeiger()
        {
            _startInventory = false;
            _startGeigerButtonText = "Start";
            BleMvxApplication._reader.rfid.StopOperation();
            RaisePropertyChanged(() => startGeigerButtonText);
        }

        void StartGeigerButtonClick()
        {
            if (!_startInventory)
            {
                StartGeiger();
            }
            else
            {
                StopGeiger();
            }
        }

        public void TagSearchOneEvent(object sender, CSLibrary.Events.OnAsyncCallbackEventArgs e)
        {
            switch (e.type)
            {
                //case CSLibrary.Constants.CallbackType.TAG_SEARCHING:
                case CSLibrary.Constants.CallbackType.TAG_RANGING:

                    _rssidBuV = (int)Math.Round(e.info.rssi);
                    _noTagCount = 0;

                    if (BleMvxApplication._config.RFID_DBm)
                    {
                        // 0~1
                        _progressbarRSSIValue = e.info.rssidBm;
                    }
                    else
                    {
                        // 0~1
                        _progressbarRSSIValue = e.info.rssi;
                    }
                    _rssiString = ((int)Math.Round(_progressbarRSSIValue)).ToString();

                    RaisePropertyChanged(() => rssiStart);
                    RaisePropertyChanged(() => progressbarRSSIValue);
                    break;
            }
        }

        void StateChangedEvent(object sender, CSLibrary.Events.OnStateChangedEventArgs e)
        {
            switch (e.state)
            {
                case CSLibrary.Constants.RFState.IDLE:
                    break;
            }
        }

        bool CheckPageActive()
        {
            try
            {
                if (Application.Current.MainPage.Navigation.NavigationStack.Count > 0)
                {
                    var currPage = Application.Current.MainPage.Navigation.NavigationStack[Application.Current.MainPage.Navigation.NavigationStack.Count - 1];

                    if (currPage.Title == "Geiger")
                        return true;
                }
            }
            catch (Exception ex)
            {
            }

            return false;
        }


        void HotKeys_OnKeyEvent(object sender, CSLibrary.Notification.HotKeyEventArgs e)
        {
            Page currentPage;

            if (!CheckPageActive())
                return;

            if (e.KeyCode == CSLibrary.Notification.Key.BUTTON)
            {
                if (e.KeyDown)
                {
                    if (!_KeyDown)
                        StartGeiger();
                    _KeyDown = true;
                }
                else
                {
                    if (_KeyDown == true)
                        StopGeiger();
                    _KeyDown = false;
                }
            }
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/PagesViewModelsSet/Inventory/PageBarcodeScan.xaml.cs">
using BLE.Client.ViewModels;
using MvvmCross.Forms.Presenters.Attributes;
using MvvmCross.Forms.Views;
using Xamarin.Forms;

namespace BLE.Client.Pages
{
    [MvxContentPagePresentation(WrapInNavigationPage = true, NoHistory = false, Animated = true)]
    public partial class PageBarcodeScan : MvxContentPage
    {
        public PageBarcodeScan()
        {
            InitializeComponent();

            if (Device.RuntimePlatform == Device.iOS)
            {
                this.Icon = new FileImageSource();
                this.Icon.File = "find-barcode-icon-90058-30x30.png";
            }
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/PagesViewModelsSet/Inventory/PageInventory.xaml.cs">
using BLE.Client.ViewModels;
using MvvmCross.Forms.Presenters.Attributes;
using MvvmCross.Forms.Views;
using Xamarin.Forms;

namespace BLE.Client.Pages
{
    public partial class PageInventory : MvxContentPage
    {
        static public string[] _displatFormtOptions = {"0. Hex",
                                 "1. UPC",
                                 "2. SGTIN-96",
        };

/* support
ADI-var
CPI-96, CPI-var
GTDI-96, GDTI-174
GIAI-96, GIAI-202
GID-96
GRAI-96, GRAI-170
GSRN-96
GSRNP-96
ITIP-110, ITIP-212
SGCN-96
SGLN-96, SGLN-195
SGTIN-96, SGTIN-198
SSCC-96
USDOD-96
*/

        public PageInventory()
		{
			InitializeComponent();

            if (Device.RuntimePlatform == Device.iOS)
            {
                this.Icon = new FileImageSource();
                this.Icon.File = "icons8-RFID Tag-104-30x30.png";
            }
        }

        public async void OnItemSelected(object sender, SelectedItemChangedEventArgs e)
		{
            var answer = await DisplayAlert("Select Tag", "Selected Tag for Read/Write and Geiger search", "OK", "Cancel");

            if (answer)
            {
				//BLE.Client.ViewModels.ViewModelInventorynScan.TagInfo Items = (BLE.Client.ViewModels.ViewModelInventorynScan.TagInfo)e.SelectedItem;
				BLE.Client.ViewModels.TagInfoViewModel Items = (BLE.Client.ViewModels.TagInfoViewModel)e.SelectedItem;

				BleMvxApplication._SELECT_EPC = Items.EPC_ORG;
                BleMvxApplication._SELECT_PC = Items.PC;
            }
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/PagesViewModelsSet/Inventory/PageInventorynScan.xaml.cs">
using BLE.Client.ViewModels;
using MvvmCross.Forms.Presenters.Attributes;
using MvvmCross.Forms.Views;

namespace BLE.Client.Pages
{
    [MvxContentPagePresentation(WrapInNavigationPage = true, NoHistory = false, Animated = true)]
    public partial class PageInventorynScan : MvxTabbedPage<ViewModelInventorynScan>
    {
        public PageInventorynScan()
        {
            InitializeComponent();

            if (BleMvxApplication._inventoryEntryPoint != 0)
            {
                var pages = Children.GetEnumerator();
                pages.MoveNext(); // First page
                pages.MoveNext(); // Second page
                CurrentPage = pages.Current;
            }
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/PagesViewModelsSet/Inventory/ViewModelInventorynScan.cs">
using System;
using System.Collections.ObjectModel;
using System.Collections.Generic;
using Acr.UserDialogs;
using System.Windows.Input;
using Xamarin.Forms;
using Xamarin.Essentials;
using System.Net;

using System.Net.Http;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;

using Plugin.BLE.Abstractions.Contracts;

using Plugin.BLE.Abstractions;
using Prism.Mvvm;

using System.Net.Http;
using System.Net.Http.Headers;

using Plugin.Share;
using Plugin.Share.Abstractions;
using MvvmCross.ViewModels;
//using Plugin.Permissions.Abstractions;
using TagDataTranslation;
using CSLibrary.Barcode.Constants;
using System.Text.RegularExpressions;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;

// GTIN Convert


namespace BLE.Client.ViewModels
{
    //public class ViewModelInventorynScan : BaseViewModel

    public class TagInfoViewModel : BindableBase
    {
        private string _EPC;
        public string EPC { get { return this._EPC; } set { this.SetProperty(ref this._EPC, value); } }
        private string _EPC_ORG;
        public string EPC_ORG { get { return this._EPC_ORG; } set { this.SetProperty(ref this._EPC_ORG, value); } }
        private string _Bank1Data;
        public string Bank1Data { get { return this._Bank1Data; } set { this.SetProperty(ref this._Bank1Data, value); } }
        private string _Bank2Data;
        public string Bank2Data { get { return this._Bank2Data; } set { this.SetProperty(ref this._Bank2Data, value); } }
        private float _RSSI;
        public float RSSI
        {
            get
            {
                if (displayFormat == 1)
                    return this._RSSI;

                if (BleMvxApplication._config.RFID_DBm)
                    return (float)Math.Round(this._RSSI);
                else
                    return (float)(CSLibrary.Tools.dBConverion.dBm2dBuV(this._RSSI, 0));
            }
            set
            {
                this.SetProperty(ref this._RSSI, value);
            }
        }
        private Int16 _Phase;
        public Int16 Phase { get { return this._Phase; } set { this.SetProperty(ref this._Phase, value); } }
        private string _Channel;
        public string Channel { get { return this._Channel; } set { this.SetProperty(ref this._Channel, value); } }
        private UInt16 _PC;
        public UInt16 PC { get { return this._PC; } set { this.SetProperty(ref this._PC, value); } }

        // Additional for Backend Server
        public DateTime timeOfRead;
        public string locationOfRead;
        public string eCompass;
        public int displayFormat = 0;

        public TagInfoViewModel()
        {
        }
    }

    public class RESTfulSDetail
    {
        public string accessPassword;
        public string killPassword;
        public string pc;
        public string epc;
        public string tidBank;
        public string userBank;
        public string timeOfRead;
        public string timeZone;
        public string locationOfRead;
        public string eCompass;
        public string antennaPort;
    }

    public class RESTfulHeader
    {
        public UInt16 sequenceNumber;
        public UInt16 numberOfTags;
        public List<RESTfulSDetail> tags = new List<RESTfulSDetail>();
        public string userDescription;
        public string rfidReaderName;
        public string rfidReaderSerialNumber;
        public string rfidReaderInternalSerialNumber;
        public string smartPhoneName;
        public string smartPhoneSerialNumber;
        public string smartPhoneBluetoothMACAddress;
        public string smartPhoneWiFiMACAddress;
        public string smartPhoneUUID;
        public string pcName;
        public string pcEthernetMACAddress;
        public string pcWiFiMACAddress;
        public string operatorId;
        public string operatorSiteId;
    }

    public class RESTFULCLASSREADERSTATUS
    {
        public UInt16 sequenceNumber;
        public string rfidReaderName;
        public string rfidReaderModel;
        public string rfidReaderSerialNumber;
        public string rfidReaderInternalSerialNumber;
        public string antennaPortEnabled;
        public string timeOfStatusUpload;
        public string timeZone;
        public string locationOfRead;
        public string Compass;
        public string readerBatteryLevelPercentage;
        public string userDescription;
        public string smartPhoneName;
        public string smartPhoneSerialNumber;
        public string smartPhoneBluetoothMACAddress;
        public string smartPhoneWiFiMACAddress;
        public string smartPhoneUUID;
        public string pcName;
        public string pcEthernetMACAddress;
        public string pcWiFiMACAddress;
        public string readerEthernetMACAddress;
        public string readerWiFiMACAddress;
        public string readerBluetoothMACAddress;
        public string readerActiveAPI;
        public string readerActiveEventID;
        public string readerUpTime;
        public string readerHealth;
        public string operatorId;
        public string operatorSiteId;
        public string operatorSiteDescription;
    }



    public class ViewModelInventorynScan : BaseViewModel
    {
        private readonly IUserDialogs _userDialogs;
        //readonly IPermissions _permissions;

        #region -------------- RFID inventory -----------------

        public ICommand OnStartInventoryButtonCommand { protected set; get; }
        public ICommand OnClearButtonCommand { protected set; get; }
        public ICommand OnSendDataCommand { protected set; get; }
        public ICommand OnShareDataCommand { protected set; get; }
        public ICommand OnSaveDataCommand { protected set; get; }
        public ICommand OnHEXButtonCommand { protected set; get; }
        public ICommand OnUPCButtonommand { protected set; get; }
        public ICommand OnSGTINButtonCommand { protected set; get; }

        private ObservableCollection<TagInfoViewModel> _TagInfoList = new ObservableCollection<TagInfoViewModel>();
        public ObservableCollection<TagInfoViewModel> TagInfoList { get { return _TagInfoList; } set { SetProperty(ref _TagInfoList, value); } }

        private System.Collections.Generic.SortedDictionary<string, (int index, string URI)> TagInfoListSpeedup = new SortedDictionary<string, (int, string)>();
        private System.Collections.Generic.SortedDictionary<string, int> TagInfoListSpeedup1 = new SortedDictionary<string, int>();

        public bool _InventoryScanning = false;
        public bool _KeyDown = false;

        public string FilterIndicator { get { return (BleMvxApplication._PREFILTER_Enable | BleMvxApplication._POSTFILTER_MASK_Enable | BleMvxApplication._RSSIFILTER_Type != CSLibrary.Constants.RSSIFILTERTYPE.DISABLE) ? "Filter On" : ""; } }

        private string _startInventoryButtonText = "Start Inventory";
        public string startInventoryButtonText { get { return _startInventoryButtonText; } }

        bool _tagCount = false;

        private string _tagPerSecondText = "Rate/New: 0/0     ";
        public string tagPerSecondText { get { return _tagPerSecondText; } }
        private string _numberOfTagsText = "     Total: 0     ";
        public string numberOfTagsText { get { return _numberOfTagsText; } }
        private string _labelVoltage = "";
        public string labelVoltage { get { return _labelVoltage; } }
        public string labelVoltageTextColor { get { return BleMvxApplication._batteryLow ? "Red" : "Black"; } }

        private int _ListViewRowHeight = -1;
        public int ListViewRowHeight { get { return _ListViewRowHeight; } }

        DateTime InventoryStartTime;
        private double _InventoryTime = 0;
        public string InventoryTime { get { return ((uint)_InventoryTime).ToString() + "s"; } }

        public string _DebugMessage = "";
        public string DebugMessage { get { return _DebugMessage; } }

        string _EPCHeaderText;
        public string EPCHeaderText { get { return _EPCHeaderText; } }
        string _RSSIHeaderText;
        public string RSSIHeaderText { get { return _RSSIHeaderText; } }

        bool _cancelVoltageValue = false;

        //bool _waitingRFIDIdle = false;

        // Tag Counter for Inventory Alert
        uint _tagCount4Display = 0;
        uint _tagCount4BeepSound = 0;
        uint _newtagCount4BeepSound = 0;
        uint _newtagCount4Vibration = 0;
        bool _Vibrating = false;
        uint _noNewTag = 0;
        uint _newTagPerSecond = 0;

        int _displayFormat = 0; // Display format, 0=HEX, 1=UPC, 2=GTIN

        #endregion

        public ViewModelInventorynScan(IAdapter adapter, IUserDialogs userDialogs/* , IPermissions permissions */) : base(adapter)
        {
            _userDialogs = userDialogs;
            //_permissions = permissions;

            OnStartInventoryButtonCommand = new Command(StartInventoryClick);
            OnClearButtonCommand = new Command(ClearClick);
            OnStartBarcodeScanButtonCommand = new Command(StartBarcodeScanButtonClick);
            OnClearBarcodeDataButtonCommand = new Command(ClearBarcodeDataButtonClick);
            OnSendDataCommand = new Command(SendDataButtonClick);
            OnShareDataCommand = new Command(ShareDataButtonClick);
            OnSaveDataCommand = new Command(SaveDataButtonClick);
            OnHEXButtonCommand = new Command(HEXButtonClick);
            OnUPCButtonommand = new Command(UPCButtonClick);
            OnSGTINButtonCommand = new Command(SGTINButtonClick);
            OnBarCodeSendDataCommand = new Command(BarCodeSendDataButtonClick);
            OnBarCodeShareDataCommand = new Command(BarCodeShareDataButtonClick);
            OnBarCodeSaveDataCommand = new Command(BarCodeSaveDataButtonClick);

            _EPCHeaderText = "EPC";
            _RSSIHeaderText = "RSSI";

            //SetEvent(true);

            InventorySetting();
        }

        ~ViewModelInventorynScan()
        {
            //BleMvxApplication._reader.barcode.Stop();
            //_barcodeScanning = false;
            //SetEvent(false);
        }

        private void SetEvent(bool enable)
        {
            // Cancel RFID event handler
            BleMvxApplication._reader.rfid.ClearEventHandler();

            // Cancel Barcode event handler
            BleMvxApplication._reader.barcode.ClearEventHandler();

            // Key Button event handler
            BleMvxApplication._reader.notification.ClearEventHandler();

            if (enable)
            {
                // RFID event handler
                BleMvxApplication._reader.rfid.OnAsyncCallback += new EventHandler<CSLibrary.Events.OnAsyncCallbackEventArgs>(TagInventoryEvent);
                BleMvxApplication._reader.rfid.OnStateChanged += new EventHandler<CSLibrary.Events.OnStateChangedEventArgs>(StateChangedEvent);
                BleMvxApplication._reader.rfid.OnInventoryTagRateCallback += new EventHandler<CSLibrary.Events.OnInventoryTagRateCallbackEventArgs>(InventoryTagRateCallback);

                // Barcode event handler
                BleMvxApplication._reader.barcode.OnCapturedNotify += new EventHandler<CSLibrary.Barcode.BarcodeEventArgs>(Linkage_CaptureCompleted);

                // Key Button event handler
                BleMvxApplication._reader.notification.OnKeyEvent += new EventHandler<CSLibrary.Notification.HotKeyEventArgs>(HotKeys_OnKeyEvent);
                BleMvxApplication._reader.notification.OnVoltageEvent += new EventHandler<CSLibrary.Notification.VoltageEventArgs>(VoltageEvent);
            }
        }

        public override void ViewAppearing()
        {
            base.ViewAppearing();
            SetEvent(true);

            if (CheckCurrentPage() == 1)
            {
                BleMvxApplication._reader.barcode.FastBarcodeMode(true);
            }
            else
            {
                BleMvxApplication._reader.barcode.FastBarcodeMode(false);
            }
        }

        public override void ViewDisappearing()
        {
            _barcodeScanning = false;
            _InventoryScanning = false;
            StopInventory();
            ClassBattery.SetBatteryMode(ClassBattery.BATTERYMODE.IDLE);
            if (BleMvxApplication._config.RFID_Vibration)
                BleMvxApplication._reader.barcode.VibratorOff();

            BleMvxApplication._reader.barcode.FastBarcodeMode(false);

            // don't turn off event handler is you need program work in sleep mode.
            //SetEvent(false);
            base.ViewDisappearing();
        }

        protected override void InitFromBundle(IMvxBundle parameters)
        {
            base.InitFromBundle(parameters);
        }

        private int CheckCurrentPage()
        {
            try
            { 
                var tp = (TabbedPage)(Application.Current.MainPage.Navigation.NavigationStack[Application.Current.MainPage.Navigation.NavigationStack.Count - 1]);
                var currentPage1 = tp.CurrentPage;
                int index = tp.Children.IndexOf(currentPage1);

                return index;
            }
            catch (Exception ex1)
            {
                string msg = "";

                for (int i = Application.Current.MainPage.Navigation.NavigationStack.Count - 1; i >= 0; i--)
                {
                    msg += "[" + i.ToString() + "]" + ((Application.Current.MainPage.Navigation.NavigationStack[i] is TabbedPage tabbedPage) ? "Y" : "N");

                    _userDialogs.Alert(msg + " : " + ex1.Message);
                }
            }




            /*
            try
            {
                string msg = "";

                msg += "[Total : " + Application.Current.MainPage.Navigation.NavigationStack.Count.ToString() + "]";

                _userDialogs.Alert(msg);

                for (int i = Application.Current.MainPage.Navigation.NavigationStack.Count - 1; i >= 0; i--)
                {
                    msg += "[" + i.ToString() + "]" + ((Application.Current.MainPage.Navigation.NavigationStack[i] is TabbedPage) ? "Y" : "N");
                }

                _userDialogs.Alert(msg );
            }
            catch (Exception ex)
            {
                _userDialogs.Alert("Error : " + ex.Message);
            }
            */

            /*
                        try
                        {
                            var tabbedPage = (TabbedPage)Application.Current.MainPage.Navigation.NavigationStack[1];
                            var currentPage = tabbedPage.CurrentPage;
                            int index = tabbedPage.Children.IndexOf(currentPage);

                            return index;
                        }
                        catch (Exception ex)
                        {
                            try
                            {
                                for (int i = Application.Current.MainPage.Navigation.NavigationStack.Count - 1; i >= 0; i--)
                                {
                                    if (Application.Current.MainPage.Navigation.NavigationStack[i] is TabbedPage tp)
                                    {
                                        var currentPage1 = tp.CurrentPage;
                                        int index = tp.Children.IndexOf(currentPage1);

                                        return index;
                                    }
                                }
                            }
                            catch (Exception ex1)
                            {
                                string msg = "";

                                for (int i = Application.Current.MainPage.Navigation.NavigationStack.Count - 1; i >= 0; i--)
                                {
                                    msg += "[" + i.ToString() + "]" + ((Application.Current.MainPage.Navigation.NavigationStack[i] is TabbedPage tabbedPage) ? "Y" : "N");

                                    _userDialogs.Alert(msg + " : " + ex1.Message);
                                }
                            }
                        }
            */
            return -1;
        }

        private void ClearClick()
        {
            InvokeOnMainThread(() =>
            {
                lock (TagInfoList)
                {
                    ClearClickImmediately();
                }
            });
        }

        private void ClearClickImmediately()
        {
            _InventoryTime = 0;
            RaisePropertyChanged(() => InventoryTime);

            _DebugMessage = "";
            RaisePropertyChanged(() => DebugMessage);

            TagInfoList.Clear();
            TagInfoListSpeedup.Clear();
            TagInfoListSpeedup1.Clear();
            _numberOfTagsText = "     Total: 0";
            RaisePropertyChanged(() => numberOfTagsText);

            _tagCount4Display = 0;
            _tagPerSecondText = "Rate/New: 0/0";
            //_tagPerSecondText = "0/" + _newTagPerSecond.ToString() + "/" + _tagCount4Display.ToString() + " internal/new/tags/s     ";

            RaisePropertyChanged(() => tagPerSecondText);
        }

        void SetConfigPower()
        {
            if (BleMvxApplication._reader.rfid.GetAntennaPort() == 1)
            {
                if (BleMvxApplication._config.RFID_PowerSequencing_NumberofPower == 0)
                {
                    BleMvxApplication._reader.rfid.SetPowerSequencing(0);
                    BleMvxApplication._reader.rfid.SetPowerLevel(BleMvxApplication._config.RFID_Antenna_Power[0]);
                }
                else
                    BleMvxApplication._reader.rfid.SetPowerSequencing(BleMvxApplication._config.RFID_PowerSequencing_NumberofPower, BleMvxApplication._config.RFID_PowerSequencing_Level, BleMvxApplication._config.RFID_PowerSequencing_DWell);
            }
            else
            {
                uint port = BleMvxApplication._reader.rfid.GetAntennaPort();

                for (uint cnt = 0; cnt < port; cnt++)
                {
                    BleMvxApplication._reader.rfid.SetPowerLevel(BleMvxApplication._config.RFID_Antenna_Power[cnt], cnt);
                }
            }
        }

        void InventorySetting()
        {
            BleMvxApplication._reader.rfid.CancelAllSelectCriteria();
            BleMvxApplication._reader.rfid.Options.TagRanging.flags = CSLibrary.Constants.SelectFlags.ZERO;

            BleMvxApplication._reader.rfid.SetInventoryDuration(BleMvxApplication._config.RFID_Antenna_Dwell);
            BleMvxApplication._reader.rfid.SetTagDelayTime((uint)BleMvxApplication._config.RFID_CompactInventoryDelayTime); // for CS108 only
            BleMvxApplication._reader.rfid.SetIntraPacketDelayTime((uint)BleMvxApplication._config.RFID_IntraPacketDelayTime); // for CS710S only
            BleMvxApplication._reader.rfid.SetDuplicateEliminationRollingWindow(BleMvxApplication._config.RFID_DuplicateEliminationRollingWindow); // for CS710S only
            BleMvxApplication._reader.rfid.SetCurrentLinkProfile(BleMvxApplication._config.RFID_Profile);
            BleMvxApplication._reader.rfid.SetTagGroup(BleMvxApplication._config.RFID_TagGroup);

            if (BleMvxApplication._config.RFID_Algorithm == CSLibrary.Constants.SingulationAlgorithm.DYNAMICQ)
            {
                BleMvxApplication._config.RFID_DynamicQParms.toggleTarget = BleMvxApplication._config.RFID_ToggleTarget ? 1U : 0;
                BleMvxApplication._reader.rfid.SetDynamicQParms(BleMvxApplication._config.RFID_DynamicQParms);
            }
            else
            {
                BleMvxApplication._config.RFID_FixedQParms.toggleTarget = BleMvxApplication._config.RFID_ToggleTarget ? 1U : 0;
                BleMvxApplication._reader.rfid.SetFixedQParms(BleMvxApplication._config.RFID_FixedQParms);
            }

            // Select Criteria filter
            if (BleMvxApplication._PREFILTER_Enable)
            {
                BleMvxApplication._reader.rfid.Options.TagRanging.flags |= CSLibrary.Constants.SelectFlags.SELECT;
                BleMvxApplication._reader.rfid.Options.TagSelected.flags = CSLibrary.Constants.SelectMaskFlags.ENABLE_TOGGLE;
                if (BleMvxApplication._PREFILTER_Bank == 1)
                {
                    BleMvxApplication._reader.rfid.Options.TagSelected.bank = CSLibrary.Constants.MemoryBank.EPC;
                    BleMvxApplication._reader.rfid.Options.TagSelected.epcMask = new CSLibrary.Structures.S_MASK(BleMvxApplication._PREFILTER_MASK_EPC);
                    BleMvxApplication._reader.rfid.Options.TagSelected.epcMaskOffset = BleMvxApplication._PREFILTER_MASK_Offset;
                    BleMvxApplication._reader.rfid.Options.TagSelected.epcMaskLength = (uint)(BleMvxApplication._PREFILTER_MASK_EPC.Length) * 4;
                }
                else
                {
                    BleMvxApplication._reader.rfid.Options.TagSelected.bank = (CSLibrary.Constants.MemoryBank)(BleMvxApplication._PREFILTER_Bank);
                    BleMvxApplication._reader.rfid.Options.TagSelected.Mask = CSLibrary.Tools.Hex.ToBytes(BleMvxApplication._PREFILTER_MASK_EPC);
                    BleMvxApplication._reader.rfid.Options.TagSelected.MaskOffset = BleMvxApplication._PREFILTER_MASK_Offset;
                    BleMvxApplication._reader.rfid.Options.TagSelected.MaskLength = (uint)(BleMvxApplication._PREFILTER_MASK_EPC.Length) * 4;
                }
                BleMvxApplication._reader.rfid.StartOperation(CSLibrary.Constants.Operation.TAG_PREFILTER);
                BleMvxApplication._reader.rfid.Options.TagRanging.flags |= CSLibrary.Constants.SelectFlags.SELECT;
            }

            BleMvxApplication._reader.rfid.SetRSSIdBmFilter(BleMvxApplication._RSSIFILTER_Type, BleMvxApplication._RSSIFILTER_Option, BleMvxApplication._RSSIFILTER_Threshold_dBm);

            BleMvxApplication._reader.rfid.Options.TagRanging.multibanks = 0;
            BleMvxApplication._reader.rfid.Options.TagRanging.compactmode = true;
            BleMvxApplication._reader.rfid.Options.TagRanging.focus = BleMvxApplication._config.RFID_Focus;
            BleMvxApplication._reader.rfid.Options.TagRanging.fastid = BleMvxApplication._config.RFID_FastId;

            BleMvxApplication._reader.rfid.StartOperation(CSLibrary.Constants.Operation.TAG_PRERANGING);

            // Set Power setting and clone antenna 0 setting to other antennas
            // the command MUST in last inventory setting if use power sequencing
            SetConfigPower();
        }

        void StartInventory()
        {
            if (_InventoryScanning)
            {
                _userDialogs.ShowSuccess("Configuring Reader, Please Wait", 1000);
                return;
            }

            StartTagCount();
            _InventoryScanning = true;
            _startInventoryButtonText = "Stop Inventory";

            _ListViewRowHeight = 40 + (int)(BleMvxApplication._reader.rfid.Options.TagRanging.multibanks * 10);
            RaisePropertyChanged(() => ListViewRowHeight);

            InventoryStartTime = DateTime.Now;

            _Vibrating = false;
            _noNewTag = 0;
            if (BleMvxApplication._config.RFID_Vibration)
                BleMvxApplication._reader.barcode.VibratorOn(CSLibrary.BarcodeReader.VIBRATORMODE.INVENTORYON, BleMvxApplication._config.RFID_VibrationTime);

            BleMvxApplication._reader.rfid.StartOperation(CSLibrary.Constants.Operation.TAG_RANGING);
            ClassBattery.SetBatteryMode(ClassBattery.BATTERYMODE.INVENTORY);
            _cancelVoltageValue = true;

            RaisePropertyChanged(() => startInventoryButtonText);
        }

        async void InventoryStopped()
        {
            if (!_InventoryScanning)
                return;

            if (BleMvxApplication._config.RFID_Vibration)
                BleMvxApplication._reader.barcode.VibratorOff();
            //_waitingRFIDIdle = true;
            _InventoryScanning = false;
            _tagCount = false;
            _startInventoryButtonText = "Start Inventory";
            RaisePropertyChanged(() => startInventoryButtonText);
        }

        async void StopInventory ()
        {
            if (!_InventoryScanning)
                return;

            BleMvxApplication._reader.rfid.StopOperation();
            if (BleMvxApplication._config.RFID_Vibration)
                BleMvxApplication._reader.barcode.VibratorOff();
            //_waitingRFIDIdle = true;
            _InventoryScanning = false;
            _tagCount = false;
            _startInventoryButtonText = "Start Inventory";
            RaisePropertyChanged(() => startInventoryButtonText);
        }

        void StartInventoryClick()
        {
            if (!_InventoryScanning)
            {
                StartInventory();
            }
            else
            {
                StopInventory();
            }
        }

        void StartTagCount()
        {
            _tagCount = true;

            _tagCount4Display = 0;
            _tagCount4BeepSound = 0;
            _newtagCount4BeepSound = 0;
            //_tagCount4Vibration = 0;
            _newtagCount4Vibration = 0;

            // Create a timer that waits one second, then invokes every second.
            Xamarin.Forms.Device.StartTimer(TimeSpan.FromMilliseconds(1000), () =>
            {
/*                if (BleMvxApplication._config.RFID_Vibration && !BleMvxApplication._config.RFID_VibrationTag)
                {
                    if (_newtagCount4Vibration > 0)
                    {
                        _newtagCount4Vibration = 0;
                        _noNewTag = 0;
                        if (!_Vibrating)
                        {
                            _Vibrating = true;
                            BleMvxApplication._reader.barcode.VibratorOn(CSLibrary.BarcodeReader.VIBRATORMODE.INVENTORYON, BleMvxApplication._config.RFID_VibrationTime);
                        }
                    }
                    else
                    {
                        if (_Vibrating)
                        {
                            _noNewTag++;

                            if (_noNewTag > BleMvxApplication._config.RFID_VibrationWindow)
                            { 
                                _Vibrating = false;
                                BleMvxApplication._reader.barcode.VibratorOff();
                            }
                        }
                    }
                }*/

                _InventoryTime = (DateTime.Now - InventoryStartTime).TotalSeconds;
                RaisePropertyChanged(() => InventoryTime);

                _DebugMessage =  CSLibrary.InventoryDebug._inventoryPacketCount.ToString () + " OK, " + CSLibrary.InventoryDebug._inventorySkipPacketCount.ToString() + " Fail";
                RaisePropertyChanged(() => DebugMessage);

                _tagCount4BeepSound = 0;

                _numberOfTagsText = "     Total: " + _TagInfoList.Count.ToString();
                RaisePropertyChanged(() => numberOfTagsText);

                switch (BleMvxApplication._reader.rfid.GetModelName())
                {
                    case "CS108":
                        _tagPerSecondText = "Rate/New: " + _tagCount4Display.ToString() + "/" + _newTagPerSecond.ToString() + "     ";
                        break;

                    case "CS710S":
                        _tagPerSecondText = "Rate/New: " + _readerInventoryTagRate.ToString() + "/" + _newTagPerSecond.ToString() + "     ";
                        break;
                }

                RaisePropertyChanged(() => tagPerSecondText);
                _tagCount4Display = 0;
                _newTagPerSecond = 0;

                if (_tagCount)
                    return true;

                return false;
            });
        }

        void StopInventoryClick()
        {
            BleMvxApplication._reader.rfid.StopOperation();
            _Vibrating = false;
            //_waitingRFIDIdle = true;
        }

        void TagInventoryEvent(object sender, CSLibrary.Events.OnAsyncCallbackEventArgs e)
        {
            if (e.type != CSLibrary.Constants.CallbackType.TAG_RANGING)
                return;

            //if (_waitingRFIDIdle) // ignore display tags
            //    return;

            //InvokeOnMainThread(() =>
            //{
                _tagCount4Display++;
                _tagCount4BeepSound++;

                if (_tagCount4BeepSound == 1)
                {
                    if (BleMvxApplication._config.RFID_InventoryAlertSound)
                    {
                        InvokeOnMainThread(() =>
                        {
                        if (_newtagCount4BeepSound > 0)
                                Xamarin.Forms.DependencyService.Get<ISystemSound>().SystemSound(3);
                            else
                                Xamarin.Forms.DependencyService.Get<ISystemSound>().SystemSound(2);
                        });
                        _newtagCount4BeepSound = 0;
                    }
                }
                else if (_tagCount4BeepSound >= 40) // from 5
                    _tagCount4BeepSound = 0;


                switch (_displayFormat)
                {
                    case 1:
                        AddOrUpdateTagDataUPC(e.info);
                        break;

                    case 2:
                        AddOrUpdateTagDataGTIN(e.info);
                        break;

                    default:
                        AddOrUpdateTagData(e.info);
                        break;
                }
            //});
        }

        void StateChangedEvent(object sender, CSLibrary.Events.OnStateChangedEventArgs e)
        {
            InvokeOnMainThread(() =>
            {
                switch (e.state)
                {
                    case CSLibrary.Constants.RFState.IDLE:
                        ClassBattery.SetBatteryMode(ClassBattery.BATTERYMODE.IDLE);
                        _cancelVoltageValue = true;
                        //_waitingRFIDIdle = false;

                        if (BleMvxApplication._reader.rfid.GetModelName() == "CS710S")
                        {
                            switch (BleMvxApplication._reader.rfid.LastMacErrorCode)
                            {
                                case 0x00:  // normal end
                                    break;

                                default:
                                    _userDialogs.Alert("Last error : 0x" + BleMvxApplication._reader.rfid.LastMacErrorCode.ToString("X4") + System.Environment.NewLine + CSLibrary.CS710SErrorCodes.GetErrorDescription((int)BleMvxApplication._reader.rfid.LastMacErrorCode));
                                    break;
                            }
                        }
                        else
                        {
                            switch (BleMvxApplication._reader.rfid.LastMacErrorCode)
                            {
                                case 0x00:  // normal end
                                    break;

                                case 0x0309:    // 
                                    _userDialogs.Alert("Too near to metal, please move CS108 away from metal and start inventory again.");
                                    break;

                                default:
                                    _userDialogs.Alert("Mac error : 0x" + BleMvxApplication._reader.rfid.LastMacErrorCode.ToString("X4"));
                                    break;
                            }
                        }

                        InventoryStopped();
                        break;
                }
            });
        }

        uint _readerInventoryTagRate = 0;
        void InventoryTagRateCallback(object sender, CSLibrary.Events.OnInventoryTagRateCallbackEventArgs e)
        {
            _readerInventoryTagRate = e.inventoryTagRate;
        }

        private void AddOrUpdateTagData(CSLibrary.Structures.TagCallbackInfo info)
        {
            InvokeOnMainThread(() =>
            {
                lock (TagInfoList)
                {
                    if (_displayFormat != 0)
                        return;

#if not_binarysearch
                    for (cnt = 0; cnt < TagInfoList.Count; cnt++)
                    {
                        if (TagInfoList[cnt].EPC == info.epc.ToString())
                        {
                            TagInfoList[cnt].Bank1Data = CSLibrary.Tools.Hex.ToString(info.Bank1Data);
                            TagInfoList[cnt].Bank2Data = CSLibrary.Tools.Hex.ToString(info.Bank2Data);
                            TagInfoList[cnt].RSSI = info.rssi;
                            //TagInfoList[cnt].Phase = info.phase;
                            //TagInfoList[cnt].Channel = (byte)info.freqChannel;

                            found = true;
                            break;
                        }
                    }

                    if (!found)
                    {
                        TagInfoViewModel item = new TagInfoViewModel();

                        item.timeOfRead = DateTime.Now;
                        item.EPC = info.epc.ToString();
                        item.Bank1Data = CSLibrary.Tools.Hex.ToString(info.Bank1Data);
                        item.Bank2Data = CSLibrary.Tools.Hex.ToString(info.Bank2Data);
                        item.RSSI = info.rssi;
                        //item.Phase = info.phase;
                        //item.Channel = (byte)info.freqChannel;
                        item.PC = info.pc.ToUshorts()[0];

                        //TagInfoList.Add(item);
                        TagInfoList.Insert(0, item);

                        _newTagFound = true;

                        Trace.Message("EPC Data = {0}", item.EPC);

                        _newTag = true;
                    }
#else
                    string epcstr = info.epc.ToString();

                    try
                    {
                        TagInfoListSpeedup.Add(epcstr, (TagInfoList.Count, null));

                        TagInfoViewModel item = new TagInfoViewModel();

                        item.timeOfRead = DateTime.Now;
                        item.EPC = info.epc.ToString();
                        item.EPC_ORG = item.EPC;
//                        if (BleMvxApplication._reader.rfid.Options.TagRanging.fastid)
//                        {
//                            item.Bank1Data = CSLibrary.Tools.Hex.ToString(info.FastTid);
//                        }
//                        else
//                        {
                            item.Bank1Data = CSLibrary.Tools.Hex.ToString(info.Bank1Data);
                            item.Bank2Data = CSLibrary.Tools.Hex.ToString(info.Bank2Data);
//                        }
                        item.RSSI = info.rssidBm;
                        //item.Phase = info.phase;
                        //item.Channel = (byte)info.freqChannel;
                        item.PC = info.pc.ToUshorts()[0];

                        //TagInfoList.Add(item);
                        if (BleMvxApplication._config.RFID_NewTagLocation)
                            TagInfoList.Insert(0, item);
                        else
                            TagInfoList.Add(item);

                        _newtagCount4BeepSound++;
                        _newtagCount4Vibration++;
                        _newTagPerSecond++;

                        Trace.Message("EPC Data = {0}", item.EPC);

                        //_newTag = true;
                    }
                    catch (Exception ex)
                    {
                        if (TagInfoListSpeedup.TryGetValue(epcstr, out var values))
                        {
                            if (BleMvxApplication._config.RFID_NewTagLocation)
                            {
                                values.index = TagInfoList.Count - values.index;
                                values.index--;
                            }

//                            if (BleMvxApplication._reader.rfid.Options.TagRanging.fastid)
//                            {
//                                TagInfoList[values.index].Bank1Data = CSLibrary.Tools.Hex.ToString(info.FastTid);
//                            }
//                            else
//                            {
                                TagInfoList[values.index].Bank1Data = CSLibrary.Tools.Hex.ToString(info.Bank1Data);
                                TagInfoList[values.index].Bank2Data = CSLibrary.Tools.Hex.ToString(info.Bank2Data);
//                            }

                            TagInfoList[values.index].RSSI = info.rssidBm;
                        }
                        else
                        {
                            // error found epc
                        }

                    }
#endif
                }
            });
        }

        private void AddOrUpdateTagDataUPC(CSLibrary.Structures.TagCallbackInfo info)
        {
            string epcstr = info.epc.ToString();

            if (epcstr.Substring(0, 2) != "30")
                return;

            InvokeOnMainThread(() =>
            {
                if (_displayFormat != 1)
                    return;

                lock (TagInfoList)
                {
                    try
                    {
                        string URI = null;
                        string PureURI;
                        string[] PureURIItems;
                        string UPC;
                        string Serial;

                        if (TagInfoListSpeedup.TryGetValue(epcstr, out var values))
                        {
                            return;
                        }
                        else
                        {
                            try
                            {
                                TDTEngine engine = new TDTEngine();
                                string epcIdentifier = engine.HexToBinary(epcstr);
                                string parameterList = @"tagLength=96";
                                URI = engine.Translate(epcIdentifier, parameterList, @"PURE_IDENTITY");
                                PureURI = URI.Split(':')[4];
                                PureURIItems = PureURI.Split('.');
                                UPC = PureURIItems[0] + PureURIItems[1];
                                Serial = PureURIItems[2];
                            }
                            catch (Exception ex)
                            {
                                TagInfoListSpeedup.Add(epcstr, (TagInfoList.Count, null));
                                return;
                            }

                            TagInfoListSpeedup.Add(epcstr, (TagInfoList.Count, URI));
                        }

                        if (TagInfoListSpeedup1.TryGetValue(UPC, out int index))
                        {
                            if (BleMvxApplication._config.RFID_NewTagLocation)
                            {
                                index = TagInfoList.Count - index;
                                index--;
                            }

//                            if (BleMvxApplication._reader.rfid.Options.TagRanging.fastid)
//                                TagInfoList[index].Bank1Data = CSLibrary.Tools.Hex.ToString(info.FastTid);

                            if (BleMvxApplication._reader.rfid.Options.TagRanging.multibanks > 0)
                                TagInfoList[index].Bank1Data = CSLibrary.Tools.Hex.ToString(info.Bank1Data);

                            if (BleMvxApplication._reader.rfid.Options.TagRanging.multibanks > 1)
                                TagInfoList[index].Bank2Data = CSLibrary.Tools.Hex.ToString(info.Bank2Data);

                            TagInfoList[index].RSSI++;
                        }
                        else
                        {
                            TagInfoListSpeedup1.Add(UPC, TagInfoList.Count);

                            TagInfoViewModel item = new TagInfoViewModel();

                            item.timeOfRead = DateTime.Now;
                            item.EPC = UPC;
                            item.EPC_ORG = epcstr;

//                            if (BleMvxApplication._reader.rfid.Options.TagRanging.fastid)
//                                item.Bank1Data = CSLibrary.Tools.Hex.ToString(info.FastTid);

                            if (BleMvxApplication._reader.rfid.Options.TagRanging.multibanks > 0)
                                item.Bank1Data = CSLibrary.Tools.Hex.ToString(info.Bank1Data);

                            if (BleMvxApplication._reader.rfid.Options.TagRanging.multibanks > 1)
                                item.Bank2Data = CSLibrary.Tools.Hex.ToString(info.Bank2Data);

                            item.displayFormat = 1;
                            item.RSSI = 1;
                            item.PC = info.pc.ToUshorts()[0];

                            if (BleMvxApplication._config.RFID_NewTagLocation)
                                TagInfoList.Insert(0, item);
                            else
                                TagInfoList.Add(item);

                            _newtagCount4BeepSound++;
                            _newtagCount4Vibration++;
                            _newTagPerSecond++;

                            Trace.Message("EPC Data = {0}", item.EPC);
                        }
                    }
                    catch (Exception ex)
                    {
                    }
                }
            });
        }

        private void AddOrUpdateTagDataGTIN(CSLibrary.Structures.TagCallbackInfo info)
        {
            string epcstr = info.epc.ToString();

            if (epcstr.Substring(0, 2) != "30")
                return;

            // EPC display convertion

            InvokeOnMainThread(() =>
            {
                if (_displayFormat != 2)
                    return;

                lock (TagInfoList)
                {
                    try
                    {
                        string URI = null;
                        string TagURI = "";
                        if (TagInfoListSpeedup.TryGetValue(epcstr, out var values))
                        {
                            if (values.URI == null)
                                return;

                            URI = values.URI;
                            TagURI = URI.Split(':')[4];
                        }
                        else
                        {
                            try
                            {
                                TDTEngine engine = new TDTEngine();
                                string epcIdentifier = engine.HexToBinary(epcstr);
                                string parameterList = @"tagLength=96";
                                URI = engine.Translate(epcIdentifier, parameterList, @"TAG_ENCODING");
                                TagURI = URI.Split(':')[4];
                            }
                            catch (Exception ex)
                            {
                                TagInfoListSpeedup.Add(epcstr, (TagInfoList.Count, null));
                                return;
                            }

                            TagInfoListSpeedup.Add(epcstr, (TagInfoList.Count, URI));
                        }

                        if (TagInfoListSpeedup1.TryGetValue(TagURI, out int index))
                        {
                            if (BleMvxApplication._config.RFID_NewTagLocation)
                            {
                                index = TagInfoList.Count - index;
                                index--;
                            }

//                            if (BleMvxApplication._reader.rfid.Options.TagRanging.fastid)
//                                TagInfoList[index].Bank1Data = CSLibrary.Tools.Hex.ToString(info.FastTid);

                            if (BleMvxApplication._reader.rfid.Options.TagRanging.multibanks > 0)
                                TagInfoList[index].Bank1Data = CSLibrary.Tools.Hex.ToString(info.Bank1Data);

                            if (BleMvxApplication._reader.rfid.Options.TagRanging.multibanks > 1)
                                TagInfoList[index].Bank2Data = CSLibrary.Tools.Hex.ToString(info.Bank2Data);

                            TagInfoList[index].RSSI = info.rssidBm;
                        }
                        else
                        {
                            TagInfoListSpeedup1.Add(TagURI, TagInfoList.Count);

                            TagInfoViewModel item = new TagInfoViewModel();

                            item.timeOfRead = DateTime.Now;
                            item.EPC = TagURI;
                            item.EPC_ORG = epcstr;

//                            if (BleMvxApplication._reader.rfid.Options.TagRanging.fastid)
//                                item.Bank1Data = CSLibrary.Tools.Hex.ToString(info.FastTid);

                            if (BleMvxApplication._reader.rfid.Options.TagRanging.multibanks > 0)
                                item.Bank1Data = CSLibrary.Tools.Hex.ToString(info.Bank1Data);

                            if (BleMvxApplication._reader.rfid.Options.TagRanging.multibanks > 1)
                                item.Bank2Data = CSLibrary.Tools.Hex.ToString(info.Bank2Data);

                            item.RSSI = info.rssidBm;
                            item.PC = info.pc.ToUshorts()[0];

                            if (BleMvxApplication._config.RFID_NewTagLocation)
                                TagInfoList.Insert(0, item);
                            else
                                TagInfoList.Add(item);

                            _newtagCount4BeepSound++;
                            _newtagCount4Vibration++;
                            _newTagPerSecond++;

                            Trace.Message("EPC Data = {0}", item.EPC);
                        }
                    }
                    catch (Exception ex)
                    {
                    }
                }
            });
        }

        void VoltageEvent(object sender, CSLibrary.Notification.VoltageEventArgs e)
		{
            InvokeOnMainThread(() =>
            {
                if (e.Voltage == 0xffff)
                {
                    _labelVoltage = "Battery ERROR";
                }
                else
                {
                    // to fix CS108 voltage bug
                    if (_cancelVoltageValue)
                    {
                        _cancelVoltageValue = false;
                        return;
                    }

                    double voltage = (double)e.Voltage / 1000;

                    {
                        var batlow = ClassBattery.BatteryLow(voltage);

                        if (BleMvxApplication._batteryLow && batlow == ClassBattery.BATTERYLEVELSTATUS.NORMAL)
                        {
                            BleMvxApplication._batteryLow = false;
                            RaisePropertyChanged(() => labelVoltageTextColor);
                        }
                        else
                        if (!BleMvxApplication._batteryLow && batlow != ClassBattery.BATTERYLEVELSTATUS.NORMAL)
                        {
                            BleMvxApplication._batteryLow = true;

                            if (batlow == ClassBattery.BATTERYLEVELSTATUS.LOW)
                                _userDialogs.AlertAsync("20% Battery Life Left, Please Recharge RFID Reader or Replace Freshly Charged Battery");
                            //else if (batlow == ClassBattery.BATTERYLEVELSTATUS.LOW_17)
                            //    _userDialogs.AlertAsync("8% Battery Life Left, Please Recharge RFID Reader or Replace with Freshly Charged Battery");

                            RaisePropertyChanged(() => labelVoltageTextColor);
                        }
                    }

                    switch (BleMvxApplication._config.BatteryLevelIndicatorFormat)
                    {
                        case 0:
                            _labelVoltage = voltage.ToString("0.000") + "v"; //			v
                            break;

                        default:
                            _labelVoltage = voltage.ToString("0.000") + "v " + ClassBattery.Voltage2Percent(voltage).ToString("0") + "%"; //			%
                                                                                                                       //_labelVoltage = ClassBattery.Voltage2Percent((double)e.Voltage / 1000).ToString("0") + "% " + ((double)e.Voltage / 1000).ToString("0.000") + "v"; //			%
                            break;
                    }
                }


#if nouse
                {
                        double p = ClassBattery.Voltage2Percent((double)e.Voltage / 1000);
                        string a;

                        a = "Bat. " + p.ToString("0.0") + "%  " + ((double)e.Voltage / 1000).ToString("0.000") + "v"; //			3.98v

                        if (p == 100)
                            a += "  over 90min";
                        else if (p == 0)
                            a += "  under 1min";
                        else
                            a += "  " + (0.9 * p).ToString ("0.0") + "min"; 

                        _labelVoltage = a;
                    }
                    else
                        _labelVoltage = "Bat. " + ((double)e.Voltage / 1000).ToString("0.000") + "v"; //			3.98v
#endif

                RaisePropertyChanged(() => labelVoltage);
            });
		}

#region -------------------- Barcode Scan -------------------

		public ICommand OnStartBarcodeScanButtonCommand { protected set; get; }
        public ICommand OnClearBarcodeDataButtonCommand { protected set; get; }
        public ICommand OnBarCodeSendDataCommand { protected set; get; }
        public ICommand OnBarCodeShareDataCommand { protected set; get; }
        public ICommand OnBarCodeSaveDataCommand { protected set; get; }

        private string _startBarcodeScanButtonText = "Start Scan";
        public string startBarcodeScanButtonText { get { return _startBarcodeScanButtonText; } }

        public class BARCODEInfoViewModel : BindableBase
        {
            private string _code;
            public string code { get { return this._code; } set { this.SetProperty(ref this._code, value); } }
            private uint _count;
            public uint count { get { return this._count; } set { this.SetProperty(ref this._count, value); } }
            public DateTime timeOfRead;
        }

        public ObservableCollection<BARCODEInfoViewModel> barcodeData { get; set; } = new ObservableCollection<BARCODEInfoViewModel>();

        bool _barcodeScanning = false;

        void StartBarcodeScanButtonClick()
        {
            if (_barcodeScanning)
            {
                BarcodeStop();
            }
            else
            {
                if (BleMvxApplication._reader.BLEBusy)
                {
                    _userDialogs.ShowSuccess("Configuring Reader, Please Wait", 1000);
                }
                else
                {
                    BarcodeStart();
                }
            }
        }

        private void ClearBarcodeDataButtonClick()
        {
            barcodeData.Clear();
        }

        private void SendDataButtonClick ()
        {
            var result = BackupData();

            CSLibrary.Debug.WriteLine("BackupData : {0}", result.ToString());
        }

        private void ShareDataButtonClick()
        {
            var result = ShareData();
            CSLibrary.Debug.WriteLine("Share Data : {0}", result.ToString());
        }
        private void SaveDataButtonClick()
        {
            var result = SaveData();
            CSLibrary.Debug.WriteLine("Save Data : {0}", result.ToString());
        }

        private void BarCodeSendDataButtonClick()
        {
            var result = BackupBarCodeData();

            CSLibrary.Debug.WriteLine("BackupData : {0}", result.ToString());
        }

        private void BarCodeShareDataButtonClick()
        {
            var result = ShareBarcodeData();
            CSLibrary.Debug.WriteLine("Share Data : {0}", result.ToString());
        }

        private void BarCodeSaveDataButtonClick()
        {
            var result = SaveBarCodeData();
            CSLibrary.Debug.WriteLine("Save Data : {0}", result.ToString());
        }

        private void HEXButtonClick()
        {
            _displayFormat = 0;
            _EPCHeaderText = "EPC";
            _RSSIHeaderText = "RSSI";
            RaisePropertyChanged(() => EPCHeaderText);
            RaisePropertyChanged(() => RSSIHeaderText);
            ClearClick();
        }

        private void UPCButtonClick()
        {
            _displayFormat = 1;
            _EPCHeaderText = "UPC";
            _RSSIHeaderText = "Unit Count";
            RaisePropertyChanged(() => EPCHeaderText);
            RaisePropertyChanged(() => RSSIHeaderText);
            ClearClick();
        }

        private void SGTINButtonClick()
        {
            _displayFormat = 2;
            _EPCHeaderText = "SGTIN";
            _RSSIHeaderText = "RSSI";
            RaisePropertyChanged(() => EPCHeaderText);
            RaisePropertyChanged(() => RSSIHeaderText);
            ClearClick();
        }

        void BarcodeStart ()
        {
            if (BleMvxApplication._reader.barcode.state == CSLibrary.BarcodeReader.STATE.NOTVALID)
            {
                _userDialogs.ShowError ("Barcode module not exists");
                return;
            }

            _barcodeScanning = true;
            if (BleMvxApplication._config.RFID_Vibration)
                BleMvxApplication._reader.barcode.VibratorOn(CSLibrary.BarcodeReader.VIBRATORMODE.BAROCDEGOODREAD, BleMvxApplication._config.RFID_VibrationTime);
            BleMvxApplication._reader.barcode.Start();
            _startBarcodeScanButtonText = "Stop Scan";
            RaisePropertyChanged(() => startBarcodeScanButtonText);
        }

        void BarcodeStop ()
        {
            _barcodeScanning = false;
            BleMvxApplication._reader.barcode.Stop();
            if (BleMvxApplication._config.RFID_Vibration)
                BleMvxApplication._reader.barcode.VibratorOff();
            //Vibrator(false);
            _startBarcodeScanButtonText = "Start Scan";
            RaisePropertyChanged(() => startBarcodeScanButtonText);
        }

        void Linkage_CaptureCompleted(object sender, CSLibrary.Barcode.BarcodeEventArgs e)
        {
            InvokeOnMainThread(() =>
            {
                switch (e.MessageType)
                {
                    case CSLibrary.Barcode.Constants.MessageType.DEC_MSG:
                        AddOrUpdateBarcodeData((CSLibrary.Barcode.Structures.DecodeMessage)e.Message);
                        Xamarin.Forms.DependencyService.Get<ISystemSound>().SystemSound(1);
                        break;

                    case CSLibrary.Barcode.Constants.MessageType.ERR_MSG:
                        break;
                }
            });
        }

        private void AddOrUpdateBarcodeData(CSLibrary.Barcode.Structures.DecodeMessage decodeInfo)
        {
            if (decodeInfo != null)
            {
                int cnt = 0;
                bool found = false;

                for (; cnt < barcodeData.Count; cnt++)
                {
                    if (barcodeData[cnt].code == decodeInfo.pchMessage)
                    {
                        barcodeData[cnt].count++;
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    BARCODEInfoViewModel item = new BARCODEInfoViewModel();

                    item.code = decodeInfo.pchMessage;
                    item.count = 1;
                    item.timeOfRead = DateTime.Now;

                    barcodeData.Insert(0, item);
                }
            }
        }

#endregion


#region Key_event

        void HotKeys_OnKeyEvent(object sender, CSLibrary.Notification.HotKeyEventArgs e)
        {
            InvokeOnMainThread(() =>
            {
                if (CheckCurrentPage() == 0)
                {
                    if (e.KeyCode == CSLibrary.Notification.Key.BUTTON)
                    {
                        if (e.KeyDown)
                        {
                            if (!_KeyDown)
                                StartInventory();
                            _KeyDown = true;
                        }
                        else
                        {
                            if (_KeyDown == true)
                                StopInventory();
                            _KeyDown = false;
                        }
                    }
                }
            });
        }
#endregion

        async void ShowDialog(string Msg)
        {
            var config = new ProgressDialogConfig()
            {
                Title = Msg,
                IsDeterministic = true,
                MaskType = MaskType.Gradient,
            };

            using (var progress = _userDialogs.Progress(config))
            {
                progress.Show();
                await System.Threading.Tasks.Task.Delay(1000);
            }
        }

        string GetJsonData ()
        {
            try
            {
                RESTfulHeader data = new RESTfulHeader();

                data.sequenceNumber = BleMvxApplication._sequenceNumber++;
                data.rfidReaderName = BleMvxApplication._reader.ReaderName;

                switch (BleMvxApplication._reader.rfid.GetModelName())
                {
                    case "CS108":
                        data.rfidReaderSerialNumber = BleMvxApplication._reader.siliconlabIC.GetSerialNumberSync().Substring(0, 13);
                        break;

                    case "CS710S":
                        data.rfidReaderSerialNumber = BleMvxApplication._reader.siliconlabIC.GetSerialNumberSync().Substring(0, 16);
                        break;
                }
                if (data.rfidReaderSerialNumber == null)
                    _userDialogs.Alert("No Serial Number");

                data.rfidReaderInternalSerialNumber = BleMvxApplication._reader.rfid.GetPCBAssemblyCode().Substring(0, 13);
                data.numberOfTags = (UInt16)_TagInfoList.Count;

                foreach (var tagitem in _TagInfoList)
                {
                    RESTfulSDetail item = new RESTfulSDetail();
                    item.pc = tagitem.PC.ToString("X4");
                    item.epc = tagitem.EPC.ToString();
                    item.timeOfRead = tagitem.timeOfRead.ToString("yyyy/MM/dd HH:mm:ss.fff");
                    item.timeZone = tagitem.timeOfRead.ToString("zzz");
                    data.tags.Add(item);
                }

                string JSONdata = Newtonsoft.Json.JsonConvert.SerializeObject(data);
                return JSONdata;
            }
            catch (Exception)
            {
                return null;
            }
        }

        string GetCSVData()
        {
            try
            {
                string CSVdata = "";

                foreach (var tagitem in _TagInfoList)
                {
                    CSVdata += tagitem.PC.ToString("X4") + ",";
                    CSVdata += tagitem.EPC.ToString() + ",";
                    CSVdata += tagitem.timeOfRead.ToString("yyyy/MM/dd HH:mm:ss.fff") + ",";
                    CSVdata += tagitem.timeOfRead.ToString("zzz");
                    CSVdata += System.Environment.NewLine;
                }

                return CSVdata;
            }
            catch (Exception)
            {
                return null;
            }
        }

        string GetExcelCSVData()
        {
            try
            {
                string CSVdata = "";

                foreach (var tagitem in _TagInfoList)
                {
                    CSVdata += "=\"" + tagitem.PC.ToString("X4") + "\",";
                    CSVdata += "=\"" + tagitem.EPC.ToString() + "\",";
                    CSVdata += tagitem.timeOfRead.ToString("yyyy/MM/dd HH:mm:ss") + ",";
                    CSVdata += tagitem.timeOfRead.ToString("zzz");
                    CSVdata += System.Environment.NewLine;
                }

                return CSVdata;
            }
            catch (Exception)
            {
                return null;
            }
        }

        string GetBarcodeJsonData()
        {
            try
            {
                RESTfulHeader data = new RESTfulHeader();

                data.sequenceNumber = BleMvxApplication._sequenceNumber++;
                data.rfidReaderName = BleMvxApplication._reader.ReaderName;

                switch (BleMvxApplication._reader.rfid.GetModelName())
                {
                    case "CS108":
                        data.rfidReaderSerialNumber = BleMvxApplication._reader.siliconlabIC.GetSerialNumberSync().Substring(0, 13);
                        break;

                    case "CS710S":
                        data.rfidReaderSerialNumber = BleMvxApplication._reader.siliconlabIC.GetSerialNumberSync().Substring(0, 16);
                        break;
                }
                if (data.rfidReaderSerialNumber == null)
                    _userDialogs.Alert("No Serial Number");

                data.rfidReaderInternalSerialNumber = BleMvxApplication._reader.rfid.GetPCBAssemblyCode().Substring(0, 13);
                data.numberOfTags = (UInt16)barcodeData.Count;

                foreach (var tagitem in barcodeData)
                {
                    RESTfulSDetail item = new RESTfulSDetail();
                    item.pc = "";
                    item.epc = tagitem.code.ToString();
                    item.timeOfRead = tagitem.timeOfRead.ToString("yyyy/MM/dd HH:mm:ss.fff");
                    item.timeZone = tagitem.timeOfRead.ToString("zzz");
                    data.tags.Add(item);
                }

                string JSONdata = Newtonsoft.Json.JsonConvert.SerializeObject(data);
                return JSONdata;
            }
            catch (Exception)
            {
                return null;
            }
        }

        string GetBarcodeCSVData()
        {
            try
            {
                string CSVdata = "";

                foreach (var tagitem in barcodeData)
                {
                    CSVdata += tagitem.code.ToString() + ",";
                    CSVdata += tagitem.code.ToString();
                    CSVdata += tagitem.timeOfRead.ToString("yyyy/MM/dd HH:mm:ss.fff") + ",";
                    CSVdata += tagitem.timeOfRead.ToString("zzz");
                    CSVdata += System.Environment.NewLine;
                }

                return CSVdata;
            }
            catch (Exception)
            {
                return null;
            }
        }

        string GetBarcodeExcelCSVData()
        {
            try
            {
                string CSVdata = "";

                foreach (var tagitem in barcodeData)
                {
                    CSVdata += tagitem.code.ToString() + ",";
                    CSVdata += tagitem.code.ToString();
                    CSVdata += tagitem.timeOfRead.ToString("yyyy/MM/dd HH:mm:ss.fff") + ",";
                    CSVdata += tagitem.timeOfRead.ToString("zzz");
                    CSVdata += System.Environment.NewLine;
                }

                return CSVdata;
            }
            catch (Exception)
            {
                return null;
            }
        }

        async System.Threading.Tasks.Task<bool> ShareData()
        {
            bool r = false;

            switch (BleMvxApplication._config.RFID_ShareFormat)
            {
                case 0: // JSON
                    r = await CrossShare.Current.Share(new Plugin.Share.Abstractions.ShareMessage
                    {
                        Text = GetJsonData(),
                        Title = "tags list"
                    });
                    break;

                case 1:
                    r = await CrossShare.Current.Share(new Plugin.Share.Abstractions.ShareMessage
                    {
                        Text = GetCSVData(),
                        Title = "tags list.csv"
                    });
                    break;

                case 2:
                    r = await CrossShare.Current.Share(new Plugin.Share.Abstractions.ShareMessage
                    {
                        Text = GetExcelCSVData(),
                        Title = "tags list.csv"
                    });
                    break;
            }

            return r;
        }

        async System.Threading.Tasks.Task<bool> ShareBarcodeData()
        {
            bool r = false;

            switch (BleMvxApplication._config.RFID_ShareFormat)
            {
                case 0: // JSON
                    r = await CrossShare.Current.Share(new Plugin.Share.Abstractions.ShareMessage
                    {
                        Text = GetBarcodeJsonData(),
                        Title = "CS108 barcode list"
                    });
                    break;

                case 1:
                    r = await CrossShare.Current.Share(new Plugin.Share.Abstractions.ShareMessage
                    {
                        Text = GetBarcodeCSVData(),
                        Title = "CS108 barcode list.csv"
                    });
                    break;

                case 2:
                    r = await CrossShare.Current.Share(new Plugin.Share.Abstractions.ShareMessage
                    {
                        Text = GetBarcodeExcelCSVData(),
                        Title = "CS108 barcode list.csv"
                    });
                    break;
            }

            return r;
        }

        async System.Threading.Tasks.Task<bool> SaveData()
        {
            string fileExtName = "";
            string Text = "";

            switch (BleMvxApplication._config.RFID_ShareFormat)
            {
                case 0: // JSON
                    fileExtName = "json";
                    Text = GetJsonData();
                    break;

                case 1:
                    fileExtName = "csv";
                    Text = GetCSVData();
                    break;

                case 2:
                    fileExtName = "csv";
                    Text = GetExcelCSVData();
                    break;

                default:
                    fileExtName = "txt";
                    break;
            }

            switch (Xamarin.Forms.Device.RuntimePlatform)
            {
                case Xamarin.Forms.Device.Android:
                    {

                        /*                        while (await _permissions.CheckPermissionStatusAsync<Plugin.Permissions.StoragePermission>() != Plugin.Permissions.Abstractions.PermissionStatus.Granted)
                                                {
                                                    await _permissions.RequestPermissionAsync<Plugin.Permissions.StoragePermission>();
                                                }
                        */

                        var status = await Permissions.CheckStatusAsync<Permissions.StorageRead>();
                        if (status != PermissionStatus.Granted)
                        {
                            status = await Permissions.RequestAsync<Permissions.StorageRead>();
                        }
                        
                        //string documents = @"/storage/emulated/0/Download/";
                        //string filename = documents + "InventoryData-" + System.DateTime.Now.ToString("yyyyMMddHHmmss") + "." + fileExtName;
                        //var documents = DependencyService.Get<IExternalStorage>().GetPath();

                        var documents = DependencyService.Get<IExternalStorage>().GetPath();
                        var filename = System.IO.Path.Combine(documents, "InventoryData-" + System.DateTime.Now.ToString("yyyyMMddHHmmss") + "." + fileExtName);
                        //System.IO.File.WriteAllText(filename, Text);
                        using (var writer = System.IO.File.CreateText(filename))
                        {
                            await writer.WriteLineAsync(Text);
                        }
                    }
                    break;

                default:
                    {
                        var documents = System.Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
                        var filename = System.IO.Path.Combine(documents, "InventoryData-" + System.DateTime.Now.ToString("yyyyMMddHHmmss") + "." + fileExtName);
                        System.IO.File.WriteAllText(filename, Text);
                    }
                    break;
            }

            _userDialogs.AlertAsync("File saved, please check file in public folder");

            return true;
        }
        async System.Threading.Tasks.Task<bool> SaveBarCodeData()
        {
            string fileExtName = "";
            string Text = "";

            switch (BleMvxApplication._config.RFID_ShareFormat)
            {
                case 0: // JSON
                    fileExtName = "json";
                    Text = GetBarcodeJsonData();
                    break;

                case 1:
                    fileExtName = "csv";
                    Text = GetBarcodeCSVData();
                    break;

                case 2:
                    fileExtName = "csv";
                    Text = GetBarcodeExcelCSVData();
                    break;

                default:
                    fileExtName = "txt";
                    break;
            }

            switch (Xamarin.Forms.Device.RuntimePlatform)
            {
                case Xamarin.Forms.Device.Android:
                    {
                        if (await Permissions.CheckStatusAsync<Permissions.StorageRead>() != PermissionStatus.Granted)
                        {
                            await Permissions.RequestAsync<Permissions.StorageRead>();
                        }

                        var documents = DependencyService.Get<IExternalStorage>().GetPath();
                        var filename = System.IO.Path.Combine(documents, "BarcodeData-" + System.DateTime.Now.ToString("yyyyMMddHHmmss") + "." + fileExtName);
                        //System.IO.File.WriteAllText(filename, Text);
                        using (var writer = System.IO.File.CreateText(filename))
                        {
                            await writer.WriteLineAsync(Text);
                        }
                    }
                    break;

                default:
                    {
                        var documents = System.Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
                        var filename = System.IO.Path.Combine(documents, "BarcodeData-" + System.DateTime.Now.ToString("yyyyMMddHHmmss") + "." + fileExtName);
                        System.IO.File.WriteAllText(filename, Text);
                    }
                    break;
            }

            _userDialogs.AlertAsync("File saved, please check file in public folder");

            return true;
        }

        async System.Threading.Tasks.Task<bool> BackupData()
        {
            try
            {
                RESTfulHeader data = new RESTfulHeader();

                data.sequenceNumber = BleMvxApplication._sequenceNumber ++;
                data.rfidReaderName = BleMvxApplication._reader.ReaderName;

                switch (BleMvxApplication._reader.rfid.GetModelName())
                {
                    case "CS108":
                        data.rfidReaderSerialNumber = BleMvxApplication._reader.siliconlabIC.GetSerialNumberSync().Substring(0, 13);
                        break;

                    case "CS710S":
                        data.rfidReaderSerialNumber = BleMvxApplication._reader.siliconlabIC.GetSerialNumberSync().Substring(0, 16);
                        break;
                }
                if (data.rfidReaderSerialNumber == null)
                    _userDialogs.Alert("No Serial Number");

                data.rfidReaderInternalSerialNumber = BleMvxApplication._reader.rfid.GetPCBAssemblyCode().Substring(0,13);
                data.numberOfTags = (UInt16)_TagInfoList.Count;

                foreach (var tagitem in _TagInfoList)
                {
                    RESTfulSDetail item = new RESTfulSDetail();
                    item.pc = tagitem.PC.ToString("X4");
                    item.epc = tagitem.EPC.ToString();
                    item.timeOfRead = tagitem.timeOfRead.ToString("yyyy/MM/dd HH:mm:ss.fff");
                    item.timeZone = tagitem.timeOfRead.ToString("zzz");
                    data.tags.Add(item);
                }

                string JSONdata = Newtonsoft.Json.JsonConvert.SerializeObject(data);

                // Post to server when parameters
                if (BleMvxApplication._config.RFID_SavetoCloud && BleMvxApplication._config.RFID_CloudProtocol == 1)
                {
                    //string rootPath = @"https://www.convergence.com.hk:29090/WebServiceRESTs/1.0/req";
                    //string rootPath = @"https://192.168.25.21:29090/WebServiceRESTs/1.0/req";
                    string fullPath = BleMvxApplication._config.RFID_IPAddress;

                    if (fullPath.Length >= 28 && fullPath.Substring(8, 28) == "democloud.convergence.com.hk")
                        fullPath += @"/create-update-delete/update-entity/tagdata";

                    var uri = new Uri(fullPath + "?" + JSONdata);
                    var handler = new HttpClientHandler();
#if NETSTANDARD2_1
                    handler.ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator;
#elif NETSTANDARD2_0
                    ServicePointManager.ServerCertificateValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
#endif
                    HttpClient client = new HttpClient(handler);
                    client.MaxResponseContentBufferSize = 102400;

                    HttpResponseMessage response = null;

                    try
                    {
                        response = await client.PostAsync(uri, new StringContent("", System.Text.Encoding.UTF8, "application/json"));
                        if (response.IsSuccessStatusCode)
                        {
                            var a = response.Content;
                            var b = await a.ReadAsStringAsync();
                            _userDialogs.Alert("Success Save to Cloud Server : " + b);
                            return true;
                        }
                    }
                    catch (Exception ex)
                    {
                        Trace.Message(ex.Message);
                    }

                    _userDialogs.Alert("Fail to Save to Cloud Server !!!!!");
                }

                // Post to server when body
                if (BleMvxApplication._config.RFID_SavetoCloud && BleMvxApplication._config.RFID_CloudProtocol == 0)
                {
                    //string rootPath = @"https://www.convergence.com.hk:29090/WebServiceRESTs/1.0/req";
                    //string rootPath = @"https://192.168.25.21:29090/WebServiceRESTs/1.0/req";
                    string fullPath1 = BleMvxApplication._config.RFID_IPAddress;

                    if (fullPath1.Length >= 28 && fullPath1.Substring(8, 28) == "democloud.convergence.com.hk")
                        fullPath1 += @"/create-update-delete/update-entity/tagdata";

                    var uri1 = new Uri(string.Format(fullPath1, string.Empty));
                    var content1 = new StringContent(JSONdata, System.Text.Encoding.UTF8, "application/json");
                    var handler = new HttpClientHandler();
#if NETSTANDARD2_1
                    handler.ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator;
#elif NETSTANDARD2_0
                    ServicePointManager.ServerCertificateValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
#endif
                    HttpClient client1 = new HttpClient(handler);
                    client1.MaxResponseContentBufferSize = 102400;

                    HttpResponseMessage response1 = null;

                    try
                    {
                        response1 = await client1.PostAsync(uri1, content1);
                        //response = await client.PutAsync(uri, content);
                        if (response1.IsSuccessStatusCode)
                        {
                            var a = response1.Content;
                            var b = await a.ReadAsStringAsync();
                            _userDialogs.Alert("Success Save to Cloud Server : " + b);
                            return true;
                        }
                    }
                    catch (Exception ex1)
                    {
                        Trace.Message(ex1.Message);
                        _userDialogs.Alert("Fail to Save to Cloud Server !!!!!" + Environment.NewLine + ex1.Message);
                    }
                }

            }
            catch (Exception ex)
            {
                Trace.Message(ex.Message);
                _userDialogs.Alert("URL Fail !!!!!" + Environment.NewLine + ex.Message);
            }

            return false;
        }

        async System.Threading.Tasks.Task<bool> BackupBarCodeData()
        {
            try
            {
                RESTfulHeader data = new RESTfulHeader();

                data.sequenceNumber = BleMvxApplication._sequenceNumber++;
                data.rfidReaderName = BleMvxApplication._reader.ReaderName;

                switch (BleMvxApplication._reader.rfid.GetModelName())
                {
                    case "CS108":
                        data.rfidReaderSerialNumber = BleMvxApplication._reader.siliconlabIC.GetSerialNumberSync().Substring(0, 13);
                        break;

                    case "CS710S":
                        data.rfidReaderSerialNumber = BleMvxApplication._reader.siliconlabIC.GetSerialNumberSync().Substring(0, 16);
                        break;
                }
                if (data.rfidReaderSerialNumber == null)
                    _userDialogs.Alert("No Serial Number");

                data.rfidReaderInternalSerialNumber = BleMvxApplication._reader.rfid.GetPCBAssemblyCode().Substring(0, 13);
                data.numberOfTags = (UInt16)barcodeData.Count;

                foreach (var tagitem in barcodeData)
                {
                    RESTfulSDetail item = new RESTfulSDetail();
                    item.pc = "";
                    item.epc = tagitem.code.ToString();
                    item.timeOfRead = tagitem.timeOfRead.ToString("yyyy/MM/dd HH:mm:ss.fff");
                    item.timeZone = tagitem.timeOfRead.ToString("zzz");
                    data.tags.Add(item);
                }

                string JSONdata = Newtonsoft.Json.JsonConvert.SerializeObject(data);

                // Post to server when parameters
                if (BleMvxApplication._config.RFID_SavetoCloud && BleMvxApplication._config.RFID_CloudProtocol == 1)
                {
                    //string rootPath = @"https://www.convergence.com.hk:29090/WebServiceRESTs/1.0/req";
                    //string rootPath = @"https://192.168.25.21:29090/WebServiceRESTs/1.0/req";
                    string fullPath = BleMvxApplication._config.RFID_IPAddress;

                    if (fullPath.Length >= 28 && fullPath.Substring(8, 28) == "democloud.convergence.com.hk")
                        fullPath += @"/create-update-delete/update-entity/tagdata";

                    var uri = new Uri(fullPath + "?" + JSONdata);
                    var handler = new HttpClientHandler();
#if NETSTANDARD2_1
                    handler.ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator;
#elif NETSTANDARD2_0
                    ServicePointManager.ServerCertificateValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
//                    ServicePointManager.ServerCertificateValidationCallback += SelfSignedForLocalhost;
#endif
                    HttpClient client = new HttpClient(handler);
                    client.MaxResponseContentBufferSize = 102400;

                    HttpResponseMessage response = null;

                    try
                    {
                        response = await client.PostAsync(uri, new StringContent("", System.Text.Encoding.UTF8, "application/json"));
                        if (response.IsSuccessStatusCode)
                        {
                            var a = response.Content;
                            var b = await a.ReadAsStringAsync();
                            _userDialogs.Alert("Success Save to Cloud Server : " + b);
                            return true;
                        }
                    }
                    catch (Exception ex)
                    {
                        Trace.Message(ex.Message);
                    }

                    _userDialogs.Alert("Fail to Save to Cloud Server !!!!!");
                }

                // Post to server when body
                if (BleMvxApplication._config.RFID_SavetoCloud && BleMvxApplication._config.RFID_CloudProtocol == 0)
                {
                    //string rootPath = @"https://www.convergence.com.hk:29090/WebServiceRESTs/1.0/req";
                    //string rootPath = @"https://192.168.25.21:29090/WebServiceRESTs/1.0/req";
                    string fullPath1 = BleMvxApplication._config.RFID_IPAddress;

                    if (fullPath1.Length >= 28 && fullPath1.Substring(8, 28) == "democloud.convergence.com.hk")
                        fullPath1 += @"/create-update-delete/update-entity/tagdata";

                    var uri1 = new Uri(string.Format(fullPath1, string.Empty));
                    var handler = new HttpClientHandler();
#if NETSTANDARD2_1
                    handler.ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator;
#elif NETSTANDARD2_0
                    ServicePointManager.ServerCertificateValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
#endif
                    HttpClient client1 = new HttpClient(handler);
                    client1.MaxResponseContentBufferSize = 102400;

                    var content1 = new StringContent(JSONdata, System.Text.Encoding.UTF8, "application/json");

                    HttpResponseMessage response1 = null;

                    try
                    {
                        response1 = await client1.PostAsync(uri1, content1);
                        //response = await client.PutAsync(uri, content);
                        if (response1.IsSuccessStatusCode)
                        {
                            var a = response1.Content;
                            var b = await a.ReadAsStringAsync();
                            _userDialogs.Alert("Success Save to Cloud Server : " + b);
                            return true;
                        }
                    }
                    catch (Exception ex1)
                    {
                        Trace.Message(ex1.Message);
                        _userDialogs.Alert("Fail to Save to Cloud Server !!!!!" + Environment.NewLine + ex1.Message);
                    }
                }

            }
            catch (Exception ex)
            {
                Trace.Message(ex.Message);
                _userDialogs.Alert("URL Fail !!!!!" + Environment.NewLine + ex.Message);
            }

            return false;
        }

#if NETSTANDARD2_0
        private static bool SelfSignedForLocalhost(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
        {
            if (sslPolicyErrors == SslPolicyErrors.None)
            {
                return true;
            }

            // For HTTPS requests to this specific host, we expect this specific certificate.
            // In practice, you'd want this to be configurable and allow for multiple certificates per host, to enable
            // seamless certificate rotations.
            return sender is HttpWebRequest httpWebRequest
                    && httpWebRequest.RequestUri.Host == "localhost"
                    && certificate is X509Certificate2 x509Certificate2
                    && x509Certificate2.Thumbprint == "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
                    && sslPolicyErrors == SslPolicyErrors.RemoteCertificateChainErrors;
        }
#endif
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/PagesViewModelsSet/PageMainMenu.xaml.cs">
using BLE.Client.ViewModels;
using MvvmCross.Forms.Views;
using Xamarin.Forms;

namespace BLE.Client.Pages
{
    public partial class PageMainMenu : MvxContentPage<ViewModelMainMenu>
    {
        public PageMainMenu()
        {
            InitializeComponent();
            //this.Title = "CSL RFID Reader (C# " + DependencyService.Get<IAppVersion>().GetVersion() + ")";
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/PagesViewModelsSet/Settings/PageAbout.xaml.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using Xamarin.Forms;
using Xamarin.Forms.Xaml;
using Xamarin.Essentials;
using MvvmCross.Forms.Views;

namespace BLE.Client.Pages
{
    public partial class PageAbout : MvxContentPage
    {
        public PageAbout()
        {
            InitializeComponent();

            if (Device.RuntimePlatform == Device.iOS)
            {
                this.Icon = new FileImageSource();
                this.Icon.File = "icons8-Settings-50-4-30x30.png";
            }

            labelModel.Text = "Model " + BleMvxApplication._reader.rfid.GetFullModelName();
            labelAppVer.Text = "Application Version " + DependencyService.Get<IAppVersion>().GetVersion() + "-" + DependencyService.Get<IAppVersion>().GetBuild().ToString();
            labelLibVer.Text = "Library Version " + BleMvxApplication._reader.GetVersion().ToString();
            labelBtFwVer.Text = "Bluetooth Firmware Version " + Version2String(BleMvxApplication._reader.bluetoothIC.GetFirmwareVersion());
            labelRFIDFwVer.Text = "RFID Firmware Version " + (BleMvxApplication._reader.rfid.GetFirmwareVersionString());
            if (BleMvxApplication._reader.rfid.GetModelName() == "CS710S")
                labelSiliconlabFwVer.Text = "ATMEL IC Firmware Version " + Version2String(BleMvxApplication._reader.siliconlabIC.GetFirmwareVersion());
            else
                labelSiliconlabFwVer.Text = "SiliconLab IC Firmware Version " + Version2String(BleMvxApplication._reader.siliconlabIC.GetFirmwareVersion());
            labelSerialNumber.Text = "Reader Serial Number " + BleMvxApplication._reader.siliconlabIC.GetSerialNumberSync();
            labelPCBSerialNumber.Text = "PCB Serial Number " + BleMvxApplication._reader.rfid.GetPCBAssemblyCode();
        }

        string Version2String(uint ver)
        {
            return string.Format("{0}.{1}.{2}", (ver >> 16) & 0xff, (ver >> 8) & 0xff, ver & 0xff);
        }

        string GetPCBVersion ()
        {
            try
            {
                var ver = BleMvxApplication._reader.siliconlabIC.GetPCBVersion();

                if (ver.Substring(2, 1) != "0")
                    return ver.Substring(0, 1) + "." + ver.Substring(1, 2);
                else
                    return ver.Substring(0, 1) + "." + ver.Substring(1, 1);
            }
            catch(Exception ex)
            {
                return "No PCB Version";
            }
        }

        public async void buttonOpenPrivacypolicyClicked(object sender, EventArgs args)
        {
            await Launcher.OpenAsync(new Uri("https://www.convergence.com.hk/apps-privacy-policy/"));
        }



    }
}
</file>

<file path="MobileMvxApp/BLE.Client/PagesViewModelsSet/Settings/PageSetting.xaml.cs">
using BLE.Client.ViewModels;
using MvvmCross.Forms.Presenters.Attributes;
using MvvmCross.Forms.Views;
using Xamarin.Forms;

namespace BLE.Client.Pages
{
    [MvxContentPagePresentation(WrapInNavigationPage = true, NoHistory = false, Animated = true)]
    public partial class PageSetting : MvxTabbedPage<ViewModelSetting>
	{
        public PageSetting()
        {
            InitializeComponent();

            switch (BleMvxApplication._reader.rfid.GetModelName())
            {
                case "CS108":
                case "CS710S":
                    this.Children.RemoveAt(2);
                    break;

                default:
                    this.Children.RemoveAt(3);
                    break;
            }

        }

        protected override void OnSizeAllocated(double width, double height)
        {
            base.OnSizeAllocated(width, height); //must be called
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/PagesViewModelsSet/Settings/PageSettingAdministration.xaml.cs">
using System;
using MvvmCross.Forms.Views;
using Xamarin.Forms;


namespace BLE.Client.Pages
{
	public partial class PageSettingAdministration : MvxContentPage
	{
        readonly string [] _ShareDataFormatOptions = new string[] { "JSON", "CSV", "Excel CSV" };

        public PageSettingAdministration()
        {
            InitializeComponent();

            if (Device.RuntimePlatform == Device.iOS)
            {
                this.Icon = new FileImageSource();
                this.Icon.File = "icons8-Settings-50-2-30x30.png";
            }

            switch (BleMvxApplication._config.BatteryLevelIndicatorFormat)
            {
                case 0:
                    buttonBatteryLevelFormat.Text = "Voltage";
                    break;

                default:
                    buttonBatteryLevelFormat.Text = "Percentage";
                    break;
            }

            switchInventoryAlertSound.IsToggled = BleMvxApplication._config.RFID_InventoryAlertSound;

            F1.Text = BleMvxApplication._config.RFID_Shortcut[0].Function.ToString();
            F1MinTime.Text = BleMvxApplication._config.RFID_Shortcut[0].DurationMin.ToString();
            F1MaxTime.Text = BleMvxApplication._config.RFID_Shortcut[0].DurationMax.ToString();
            F2.Text = BleMvxApplication._config.RFID_Shortcut[1].Function.ToString();
            F2MinTime.Text = BleMvxApplication._config.RFID_Shortcut[1].DurationMin.ToString();
            F2MaxTime.Text = BleMvxApplication._config.RFID_Shortcut[1].DurationMax.ToString();

            //entryTagDelay.Text = BleMvxApplication._config.RFID_TagDelayTime.ToString();
            //entryInventoryDuration.Text = BleMvxApplication._config.RFID_InventoryDuration.ToString();

            entryReaderName.Text = BleMvxApplication._reader.ReaderName;

            labelReaderModel.Text = "Reader Model : " + BleMvxApplication._reader.rfid.GetFullModelName();

            switchNewTagLocation.IsToggled = BleMvxApplication._config.RFID_NewTagLocation;
            buttonShareDataFormat.Text = _ShareDataFormatOptions[BleMvxApplication._config.RFID_ShareFormat];

            switchRSSIDBm.IsToggled = BleMvxApplication._config.RFID_DBm;
            //switchSavetoFile.IsToggled = BleMvxApplication._config.RFID_SavetoFile;
            switchSavetoCloud.IsToggled = BleMvxApplication._config.RFID_SavetoCloud;
            switchhttpProtocol.IsToggled = (BleMvxApplication._config.RFID_CloudProtocol == 0) ? false : true;
            entryServerIP.Text = BleMvxApplication._config.RFID_IPAddress;

            switchVibration.IsToggled = BleMvxApplication._config.RFID_Vibration;
            //switchVibrationTag.IsToggled = BleMvxApplication._config.RFID_VibrationTag;
            entryVibrationWindow.Text = BleMvxApplication._config.RFID_VibrationWindow.ToString();
            entryVibrationTime.Text = BleMvxApplication._config.RFID_VibrationTime.ToString();

            switchKeepScreenOn.IsToggled = BleMvxApplication._config._keepScreenOn;

            //entryBatteryIntervalTime.Text = BleMvxApplication._config.RFID_BatteryPollingTime.ToString();

            entryAuthServerURL.Text = BleMvxApplication._config.Impinj_AuthenticateServerURL;
            entryVerificationemail.Text = BleMvxApplication._config.Impinj_AuthenticateEmail;
            entryVerificationpassword.Text = BleMvxApplication._config.Impinj_AuthenticatePassword;

            if (Device.RuntimePlatform != Device.Android)
            {
                //switchSavetoFile.IsEnabled = false;
            }
        }

        protected override void OnAppearing()
        {
            base.OnAppearing();
        }

        public async void btnOKClicked(object sender, EventArgs e)
        {
            int cnt;

            Xamarin.Forms.DependencyService.Get<ISystemSound>().SystemSound(1);

            switch (buttonBatteryLevelFormat.Text)
            {
                case "Voltage":
                    BleMvxApplication._config.BatteryLevelIndicatorFormat = 0;
                    break;

                default:
                    BleMvxApplication._config.BatteryLevelIndicatorFormat = 1;
                    break;
            }

            BleMvxApplication._config.RFID_InventoryAlertSound = switchInventoryAlertSound.IsToggled;

            BleMvxApplication._config.RFID_Shortcut[0].Function = (CONFIG.MAINMENUSHORTCUT.FUNCTION)Enum.Parse(typeof(CONFIG.MAINMENUSHORTCUT.FUNCTION), F1.Text);
            BleMvxApplication._config.RFID_Shortcut[0].DurationMin = uint.Parse(F1MinTime.Text);
            BleMvxApplication._config.RFID_Shortcut[0].DurationMax = uint.Parse(F1MaxTime.Text);
            BleMvxApplication._config.RFID_Shortcut[1].Function = (CONFIG.MAINMENUSHORTCUT.FUNCTION)Enum.Parse(typeof(CONFIG.MAINMENUSHORTCUT.FUNCTION), F2.Text);
            BleMvxApplication._config.RFID_Shortcut[1].DurationMin = uint.Parse(F2MinTime.Text);
            BleMvxApplication._config.RFID_Shortcut[1].DurationMax = uint.Parse(F2MaxTime.Text);

            BleMvxApplication._config.RFID_DBm = switchRSSIDBm.IsToggled;
            //BleMvxApplication._config.RFID_SavetoFile = switchSavetoFile.IsToggled;
            BleMvxApplication._config.RFID_SavetoCloud = switchSavetoCloud.IsToggled;
            BleMvxApplication._config.RFID_CloudProtocol = switchhttpProtocol.IsToggled ? 1 : 0;
            BleMvxApplication._config.RFID_IPAddress = entryServerIP.Text;

            BleMvxApplication._config.RFID_NewTagLocation = switchNewTagLocation.IsToggled;
            BleMvxApplication._config.RFID_ShareFormat = Array.IndexOf(_ShareDataFormatOptions, buttonShareDataFormat.Text);

            //BleMvxApplication._config.RFID_TagDelayTime = int.Parse(entryTagDelay.Text);
            //BleMvxApplication._config.RFID_InventoryDuration = UInt32.Parse(entryInventoryDuration.Text);

            BleMvxApplication._config.RFID_Vibration = switchVibration.IsToggled;
            //BleMvxApplication._config.RFID_VibrationTag = switchVibrationTag.IsToggled;
            BleMvxApplication._config.RFID_VibrationWindow = UInt32.Parse(entryVibrationWindow.Text);
            BleMvxApplication._config.RFID_VibrationTime = UInt32.Parse(entryVibrationTime.Text);

            //BleMvxApplication._config._keepScreenOn = Xamarin.Essentials.DeviceDisplay.KeepScreenOn = switchKeepScreenOn.IsToggled;

            BleMvxApplication._config.Impinj_AuthenticateServerURL = entryAuthServerURL.Text;
            BleMvxApplication._config.Impinj_AuthenticateEmail = entryVerificationemail.Text;
            BleMvxApplication._config.Impinj_AuthenticatePassword = entryVerificationpassword.Text;

            BleMvxApplication.SaveConfig();

            if (entryReaderName.Text != BleMvxApplication._reader.ReaderName)
            {
                BleMvxApplication._reader.bluetoothIC.SetDeviceName (entryReaderName.Text);
                await DisplayAlert("New Reader Name effective after reset CS108", "", null, "OK");
            }
        }

        public async void buttonBatteryLevelFormatClicked(object sender, EventArgs e)
        {
            var answer = await DisplayActionSheet("View Battery Level Format", "Cancel", null, "Voltage", "Percentage");

            if (answer != null && answer !="Cancel")
                buttonBatteryLevelFormat.Text = answer;
        }

        public async void buttonShareDataFormatClicked(object sender, EventArgs e)
        {
            var answer = await DisplayActionSheet("Share Data Format", null, null, _ShareDataFormatOptions);

            if (answer != null)
                buttonShareDataFormat.Text = answer;
        }

        public void btnBarcodeResetClicked(object sender, EventArgs e)
        {
            Xamarin.Forms.DependencyService.Get<ISystemSound>().SystemSound(1);

            if (BleMvxApplication._reader.barcode.state == CSLibrary.BarcodeReader.STATE.NOTVALID)
            {
                DisplayAlert(null, "Barcode module not exists", "OK");
                return;
            }

            BleMvxApplication._reader.barcode.FactoryReset();
        }

        public async void btnConfigResetClicked(object sender, EventArgs e)
        {
            Xamarin.Forms.DependencyService.Get<ISystemSound>().SystemSound(1);
            BleMvxApplication.ResetConfig();
            BleMvxApplication._reader.rfid.SetDefaultChannel();

            if (BleMvxApplication._reader.rfid.IsFixedChannel())
            {
                BleMvxApplication._config.RFID_FrequenceSwitch = 1;
                BleMvxApplication._config.RFID_FixedChannel = BleMvxApplication._reader.rfid.GetCurrentFrequencyChannel();
            }
            else
            {
                BleMvxApplication._config.RFID_FrequenceSwitch = 0; // Hopping
            }

            BleMvxApplication.SaveConfig();


            string macadd = BleMvxApplication._reader.GetMacAddress();

            if (macadd.Length >= 6)
            {
                if (BleMvxApplication._reader.rfid.GetModel() == CSLibrary.RFIDDEVICE.MODEL.CS108)
                {

                    BleMvxApplication._reader.bluetoothIC.SetDeviceName("CS108Reader" + macadd.Substring(macadd.Length - 6));
                    await DisplayAlert("New Reader Name effective after reset CS108", "", null, "OK");
                }
                else if (BleMvxApplication._reader.rfid.GetModel() == CSLibrary.RFIDDEVICE.MODEL.CS710S)
                {
                    BleMvxApplication._reader.bluetoothIC.SetDeviceName("CS710SReader" + macadd.Substring(macadd.Length - 6));
                    await DisplayAlert("New Reader Name effective after reset CS710S", "", null, "OK");
                }
            }
        }

        public async void btnGetSerialNumber(object sender, EventArgs e)
        {
            BleMvxApplication._reader.siliconlabIC.GetSerialNumber();
        }

        public async void btnFunctionSelectedClicked(object sender, EventArgs e)
        {
            var answer = await DisplayActionSheet(null, BLE.Client.CONFIG.MAINMENUSHORTCUT.FUNCTION.NONE.ToString(), null, BLE.Client.CONFIG.MAINMENUSHORTCUT.FUNCTION.INVENTORY.ToString(), BLE.Client.CONFIG.MAINMENUSHORTCUT.FUNCTION.BARCODE.ToString());

            Button b = (Button)sender;
            b.Text = answer;
        }

        public async void btnCSLCloudClicked(object sender, EventArgs e)
        {
            switchhttpProtocol.IsToggled = false;
            //entryServerIP.Text = "https://www.convergence.com.hk:29090/WebServiceRESTs/1.0/req";
            entryServerIP.Text = "https://democloud.convergence.com.hk:29090/WebServiceRESTs/1.0/req";
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/PagesViewModelsSet/Settings/PageSettingAntenna.xaml.cs">
using System;
using MvvmCross.Forms.Views;
using Xamarin.Forms;

namespace BLE.Client.Pages
{
	public partial class PageSettingAntenna : MvxContentPage
	{
        class ANTENNAOPTION
        {
            private global::Xamarin.Forms.Switch switchAntennaEnable;
            private global::Xamarin.Forms.Entry entryPower;
            private global::Xamarin.Forms.Entry entryDwell;
        }

        public PageSettingAntenna()
        {
            InitializeComponent();

            // the page only support 4 ports
            if (BleMvxApplication._reader.rfid.GetAntennaPort() != 4)
                return;

            if (Device.RuntimePlatform == Device.iOS)
            {
                this.Icon = new FileImageSource();
                this.Icon.File = "icons8-Settings-50-3-30x30.png";
            }

            ANTENNAOPTION[] antennaOptions = new ANTENNAOPTION[BleMvxApplication._reader.rfid.AntennaList.Count];

            switchAntenna1Enable.IsToggled = BleMvxApplication._config.RFID_AntennaEnable[0];
            switchAntenna2Enable.IsToggled = BleMvxApplication._config.RFID_AntennaEnable[1];
            switchAntenna3Enable.IsToggled = BleMvxApplication._config.RFID_AntennaEnable[2];
            switchAntenna4Enable.IsToggled = BleMvxApplication._config.RFID_AntennaEnable[3];

            entryPower1.Text = BleMvxApplication._config.RFID_Antenna_Power[0].ToString();
            entryPower2.Text = BleMvxApplication._config.RFID_Antenna_Power[1].ToString();
            entryPower3.Text = BleMvxApplication._config.RFID_Antenna_Power[2].ToString();
            entryPower4.Text = BleMvxApplication._config.RFID_Antenna_Power[3].ToString();

            entryDwell1.Text = BleMvxApplication._config.RFID_Antenna_Dwell[0].ToString();
            entryDwell2.Text = BleMvxApplication._config.RFID_Antenna_Dwell[1].ToString();
            entryDwell3.Text = BleMvxApplication._config.RFID_Antenna_Dwell[2].ToString();
            entryDwell4.Text = BleMvxApplication._config.RFID_Antenna_Dwell[3].ToString();
        }

        protected override void OnAppearing()
        {
            if (BleMvxApplication._settingPage1TagPopulationChanged)
            {
                BleMvxApplication._settingPage1TagPopulationChanged = false;
            }

            base.OnAppearing();
        }

        public async void btnOKClicked(object sender, EventArgs e)
        {
            Xamarin.Forms.DependencyService.Get<ISystemSound>().SystemSound(1);

            BleMvxApplication._config.RFID_AntennaEnable[0] = switchAntenna1Enable.IsToggled;
            BleMvxApplication._config.RFID_AntennaEnable[1] = switchAntenna2Enable.IsToggled;
            BleMvxApplication._config.RFID_AntennaEnable[2] = switchAntenna3Enable.IsToggled;
            BleMvxApplication._config.RFID_AntennaEnable[3] = switchAntenna4Enable.IsToggled;

            BleMvxApplication._config.RFID_Antenna_Power[0] = uint.Parse(entryPower1.Text);
            BleMvxApplication._config.RFID_Antenna_Power[1] = uint.Parse(entryPower2.Text);
            BleMvxApplication._config.RFID_Antenna_Power[2] = uint.Parse(entryPower3.Text);
            BleMvxApplication._config.RFID_Antenna_Power[3] = uint.Parse(entryPower4.Text);

            BleMvxApplication._config.RFID_Antenna_Dwell[0] = uint.Parse(entryDwell1.Text);
            BleMvxApplication._config.RFID_Antenna_Dwell[1] = uint.Parse(entryDwell2.Text);
            BleMvxApplication._config.RFID_Antenna_Dwell[2] = uint.Parse(entryDwell3.Text);
            BleMvxApplication._config.RFID_Antenna_Dwell[3] = uint.Parse(entryDwell4.Text);

            BleMvxApplication.SaveConfig();

            for (uint cnt = 0; cnt < 4; cnt++)
            {
                BleMvxApplication._reader.rfid.SetAntennaPortState(cnt, BleMvxApplication._config.RFID_AntennaEnable[cnt] ? CSLibrary.Constants.AntennaPortState.ENABLED : CSLibrary.Constants.AntennaPortState.DISABLED);
                BleMvxApplication._reader.rfid.SetPowerLevel(BleMvxApplication._config.RFID_Antenna_Power[cnt], cnt);
                BleMvxApplication._reader.rfid.SetInventoryDuration(BleMvxApplication._config.RFID_Antenna_Dwell[cnt], cnt);
            }
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/PagesViewModelsSet/Settings/PageSettingOperation.xaml.cs">
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using MvvmCross.Forms.Views;
using Xamarin.Forms;

using static CSLibrary.FrequencyBand;

namespace BLE.Client.Pages
{

	public partial class PageSettingOperation : MvxContentPage
	{
        string[] ActiveRegionsTextList;
        double[] ActiveFrequencyList;
        string[] ActiveFrequencyTextList;
        string[] _profileList;
        string[] _freqOrderOptions;

        public PageSettingOperation()
        {
            InitializeComponent();

            _profileList = BleMvxApplication._reader.rfid.GetActiveLinkProfileName();

            if (Device.RuntimePlatform == Device.iOS)
            {
                this.Icon = new FileImageSource();
                this.Icon.File = "icons8-Settings-50-1-30x30.png";
            }

            stackLayoutInventoryDuration.IsVisible = stackLayoutPower.IsVisible = (BleMvxApplication._reader.rfid.GetAntennaPort() == 1);

            ActiveRegionsTextList = BleMvxApplication._reader.rfid.GetActiveCountryNameList();
            ActiveFrequencyList = BleMvxApplication._reader.rfid.GetAvailableFrequencyTable();
            ActiveFrequencyTextList = ActiveFrequencyList.OfType<object>().Select(o => o.ToString() + " MHz").ToArray();
            buttonRegion.Text = BleMvxApplication._config.RFID_Region;

            switch (BleMvxApplication._config.RFID_FrequenceSwitch)
            {
                case 0:
                    buttonFrequencyOrder.Text = "Hopping";
                    break;
                case 1:
                    buttonFrequencyOrder.Text = "Fixed";
                    break;
            }

            if (ActiveRegionsTextList.Count() == 1)
                buttonRegion.IsEnabled = false;

//            if (_freqOrderOptions.Length == 1)
                buttonFrequencyOrder.IsEnabled = false;

            if (BleMvxApplication._config.RFID_FixedChannel == -1)
                buttonFixedChannel.Text = ActiveFrequencyTextList[0];
            else
                buttonFixedChannel.Text = ActiveFrequencyTextList[BleMvxApplication._config.RFID_FixedChannel];

            checkbuttonFixedChannel();

            entryPower.Text = BleMvxApplication._config.RFID_Antenna_Power[0].ToString();
            entryInventoryDuration.Text = BleMvxApplication._config.RFID_Antenna_Dwell[0].ToString();
            entryCompactInventoryDelay.Text = BleMvxApplication._config.RFID_CompactInventoryDelayTime.ToString();
            entryIntraPacketDelay.Text = BleMvxApplication._config.RFID_IntraPacketDelayTime.ToString();
            entryDuplicateEliminationRollingWindow.Text = BleMvxApplication._config.RFID_DuplicateEliminationRollingWindow.ToString();

            buttonSession.Text = BleMvxApplication._config.RFID_TagGroup.session.ToString();
            if (BleMvxApplication._config.RFID_ToggleTarget)
            {
                buttonTarget.Text = "Toggle A/B";
            }
            else
            {
                buttonTarget.Text = BleMvxApplication._config.RFID_TagGroup.target.ToString();
            }

            switchFocus.IsToggled = BleMvxApplication._config.RFID_Focus;
            switchFastId.IsToggled = BleMvxApplication._config.RFID_FastId;

            buttonAlgorithm.Text = BleMvxApplication._config.RFID_Algorithm.ToString();
            entryTagPopulation.Text = BleMvxApplication._config.RFID_TagPopulation.ToString();
            if (BleMvxApplication._config.RFID_QOverride)
            {
                entryQOverride.IsEnabled = true;
                buttonQOverride.Text = "Reset";
            }
            else
            {
                entryQOverride.IsEnabled = false;
                buttonQOverride.Text = "Override";
            }

            entryMaxQ.Text = BleMvxApplication._config.RFID_DynamicQParms.maxQValue.ToString();
            entryMinQ.Text = BleMvxApplication._config.RFID_DynamicQParms.minQValue.ToString();
            entryMinQCycled.Text = BleMvxApplication._config.RFID_DynamicQParms.MinQCycles.ToString();

            switchQIncreaseUseQuery.IsToggled = BleMvxApplication._config.RFID_DynamicQParms.QIncreaseUseQuery;
            switchQDecreaseUseQuery.IsToggled = BleMvxApplication._config.RFID_DynamicQParms.QDecreaseUseQuery;
            entryNoEPCMaxQ.Text = BleMvxApplication._config.RFID_DynamicQParms.NoEPCMaxQ.ToString();

            foreach (string profilestr in _profileList)
            {
                int colonIndex = profilestr.IndexOf(":");
                if (colonIndex > 0 && uint.Parse(profilestr.Substring(0, colonIndex)) == BleMvxApplication._config.RFID_Profile)
                {
                    buttonProfile.Text = profilestr;
                    break;
                }
            }

            SetQvalue();
        }

        public async void buttonRegionClicked(object sender, EventArgs e)
        {
            var answer = await DisplayActionSheet("Regions", "Cancel", null, ActiveRegionsTextList);

            if (answer != null && answer != "Cancel")
            {
                int cnt;

                buttonRegion.Text = answer;

                for (cnt = 0; cnt < ActiveRegionsTextList.Length; cnt++)
                {
                    if (ActiveRegionsTextList[cnt] == answer)
                    {
                        ActiveFrequencyList = BleMvxApplication._reader.rfid.GetAvailableFrequencyTable(ActiveRegionsTextList[cnt]).ToArray();
                        break;
                    }
                }
                if (cnt == ActiveRegionsTextList.Length)
                    ActiveFrequencyList = new double[1] { 0.0 };

                ActiveFrequencyTextList = ActiveFrequencyList.OfType<object>().Select(o => o.ToString()).ToArray();
                buttonFixedChannel.Text = ActiveFrequencyTextList[0];
            }
        }

        public async void buttonFrequencyOrderClicked(object sender, EventArgs e)
        {
            string answer;

            answer = await DisplayActionSheet("Frequence Channel Order", "Cancel", null, _freqOrderOptions);

            if (answer != null && answer != "Cancel")
                buttonFrequencyOrder.Text = answer;

            checkbuttonFixedChannel();
        }

        void checkbuttonFixedChannel()
        {
            if (buttonFrequencyOrder.Text == "Fixed")
                buttonFixedChannel.IsEnabled = true;
            else
                buttonFixedChannel.IsEnabled = false;
        }

        public async void buttonFixedChannelClicked(object sender, EventArgs e)
        {
            var answer = await DisplayActionSheet("Frequency Channel Order", "Cancel", null, ActiveFrequencyTextList);

            if (answer != null && answer != "Cancel")
                buttonFixedChannel.Text = answer;
        }

        public async void entryPowerCompleted(object sender, EventArgs e)
        {
            uint value;

            try
            {
                value = uint.Parse(entryPower.Text);
                if (value < 0 || value > 320)
                    throw new System.ArgumentException("Power can only be set to 320 or below", "Power");
                entryPower.Text = value.ToString();
            }
            catch (Exception ex)
            {
                await DisplayAlert("Power", "Power can only be set to 320 or below", "OK");
                entryPower.Text = "300";
            }
        }

        public async void entryTagPopulationCompleted(object sender, EventArgs e)
        {
            uint tagPopulation;

            try
            {
                tagPopulation = uint.Parse(entryTagPopulation.Text);
                if (tagPopulation < 1 || tagPopulation > 8192)
                    throw new System.ArgumentException("Value not valid", "tagPopulation");
                entryTagPopulation.Text = tagPopulation.ToString();
            }
            catch (Exception ex)
            {
                await DisplayAlert("", "Value not valid!!!", "OK");
                tagPopulation = 60;
                entryTagPopulation.Text = "60";
            }

            if (!entryQOverride.IsEnabled)
                entryQOverride.Text = ((uint)(Math.Log((tagPopulation * 2), 2)) + 1).ToString();
        }

        public async void entryQOverrideCompiled(object sender, EventArgs e)
        {
            uint Q;
            try
            {
                Q = uint.Parse(entryQOverride.Text);
                if (Q < 0 || Q > 15)
                    throw new System.ArgumentException("Value not valid", "tagPopulation");
                entryQOverride.Text = Q.ToString();
            }
            catch (Exception ex)
            {
                await DisplayAlert("", "Value not valid!!!", "OK");
                Q = 7;
                entryQOverride.Text = "7";
            }

            //entryTagPopulation.Text = (1U << (int)Q).ToString();
        }

        public async void buttonQOverrideClicked(object sender, EventArgs e)
        {
            if (entryQOverride.IsEnabled)
            {
                entryQOverride.IsEnabled = false;
                buttonQOverride.Text = "Override";
                entryTagPopulationCompleted(null, null);
            }
            else
            {
                entryQOverride.IsEnabled = true;
                buttonQOverride.Text = "Reset";
            }
        }

        public async void entryDuplicateEliminationRollingWindowCompleted(object sender, EventArgs e)
        {
            uint value;

            try
            {
                value = uint.Parse(entryDuplicateEliminationRollingWindow.Text);
                if (value < 0 || value > 255)
                    throw new System.ArgumentException("Value not valid", "DuplicateEliminationRollingWindow");
                entryDuplicateEliminationRollingWindow.Text = value.ToString();
            }
            catch (Exception ex)
            {
                await DisplayAlert("", "Value not valid!!!", "OK");
                entryDuplicateEliminationRollingWindow.Text = "0";
            }
        }

        public async void entryCompactInventoryDelayCompleted(object sender, EventArgs e)
        {
            int value;

            try
            {
                value = int.Parse(entryCompactInventoryDelay.Text);
                if (value < 0 || value > 15)
                    throw new System.ArgumentException("Value not valid", "tagPopulation");
                entryCompactInventoryDelay.Text = value.ToString();
            }
            catch (Exception ex)
            {
                await DisplayAlert("", "Value not valid!!!", "OK");
                entryCompactInventoryDelay.Text = "0";
            }
        }

        public async void entryIntraPacketDelayCompleted(object sender, EventArgs e)
        {
            int value;

            try
            {
                value = int.Parse(entryIntraPacketDelay.Text);
                if (value < 0 || value > 255)
                    throw new System.ArgumentException("Value not valid", "tagPopulation");
                entryIntraPacketDelay.Text = value.ToString();
            }
            catch (Exception ex)
            {
                await DisplayAlert("", "Value not valid!!!", "OK");
                entryIntraPacketDelay.Text = "0";
            }
        }



        protected override void OnAppearing()
        {
            if (BleMvxApplication._settingPage1TagPopulationChanged)
            {
                BleMvxApplication._settingPage1TagPopulationChanged = false;
                entryTagPopulation.Text = BleMvxApplication._config.RFID_TagPopulation.ToString();
            }

            base.OnAppearing();
        }

        public async void btnOKClicked(object sender, EventArgs e)
        {
            int cnt;

            Xamarin.Forms.DependencyService.Get<ISystemSound>().SystemSound(1);

            for (cnt = 0; cnt < ActiveRegionsTextList.Length; cnt++)
            {
                if (ActiveRegionsTextList[cnt] == buttonRegion.Text)
                {
                    BleMvxApplication._config.RFID_Region = ActiveRegionsTextList[cnt];
                    break;
                }
            }
            if (cnt == ActiveRegionsTextList.Length)
                BleMvxApplication._config.RFID_Region = "UNKNOWN";

            switch (buttonFrequencyOrder.Text)
            {
                case "Hopping":
                    BleMvxApplication._config.RFID_FrequenceSwitch = 0;
                    break;
                case "Fixed":
                    BleMvxApplication._config.RFID_FrequenceSwitch = 1;
                    break;
            }

            for (cnt = 0; cnt < ActiveFrequencyTextList.Length; cnt++)
            {
                if (buttonFixedChannel.Text == ActiveFrequencyTextList[cnt])
                {
                    BleMvxApplication._config.RFID_FixedChannel = cnt;
                    break;
                }
            }
            if (cnt == ActiveFrequencyTextList.Length)
                BleMvxApplication._config.RFID_FixedChannel = 0;

            BleMvxApplication._config.RFID_Antenna_Power[0] = UInt16.Parse(entryPower.Text);
            BleMvxApplication._config.RFID_Antenna_Dwell[0] = UInt16.Parse(entryInventoryDuration.Text);
            BleMvxApplication._config.RFID_CompactInventoryDelayTime = int.Parse(entryCompactInventoryDelay.Text);
            BleMvxApplication._config.RFID_IntraPacketDelayTime = int.Parse(entryIntraPacketDelay.Text);
            BleMvxApplication._config.RFID_DuplicateEliminationRollingWindow = byte.Parse(entryDuplicateEliminationRollingWindow.Text);

            switch (buttonSession.Text)
            {
                case "S0":
                    BleMvxApplication._config.RFID_TagGroup.session = CSLibrary.Constants.Session.S0;
                    break;

                case "S1":
                    BleMvxApplication._config.RFID_TagGroup.session = CSLibrary.Constants.Session.S1;
                    break;

                case "S2":
                    BleMvxApplication._config.RFID_TagGroup.session = CSLibrary.Constants.Session.S2;
                    break;

                case "S3":
                    BleMvxApplication._config.RFID_TagGroup.session = CSLibrary.Constants.Session.S3;
                    break;
            }

            switch (buttonTarget.Text)
            {
                case "A":
                    BleMvxApplication._config.RFID_ToggleTarget = false;
                    BleMvxApplication._config.RFID_TagGroup.target = CSLibrary.Constants.SessionTarget.A;
                    BleMvxApplication._config.RFID_FixedQParms.toggleTarget = 0;
                    BleMvxApplication._config.RFID_DynamicQParms.toggleTarget = 0;
                    break;
                case "B":
                    BleMvxApplication._config.RFID_ToggleTarget = false;
                    BleMvxApplication._config.RFID_TagGroup.target = CSLibrary.Constants.SessionTarget.B;
                    BleMvxApplication._config.RFID_FixedQParms.toggleTarget = 0;
                    BleMvxApplication._config.RFID_DynamicQParms.toggleTarget = 0;
                    break;
                default:
                    BleMvxApplication._config.RFID_ToggleTarget = true;
                    BleMvxApplication._config.RFID_DynamicQParms.toggleTarget = 1;
                    BleMvxApplication._config.RFID_FixedQParms.toggleTarget = 1;
                    break;
            }
            BleMvxApplication._config.RFID_Focus = switchFocus.IsToggled;
            BleMvxApplication._config.RFID_FastId = switchFastId.IsToggled;

            if (buttonAlgorithm.Text == "DYNAMICQ")
            {
                BleMvxApplication._config.RFID_Algorithm = CSLibrary.Constants.SingulationAlgorithm.DYNAMICQ;
            }
            else
            {
                BleMvxApplication._config.RFID_Algorithm = CSLibrary.Constants.SingulationAlgorithm.FIXEDQ;
            }
            BleMvxApplication._config.RFID_TagPopulation = UInt16.Parse(entryTagPopulation.Text);
            BleMvxApplication._config.RFID_QOverride = entryQOverride.IsEnabled;
            BleMvxApplication._config.RFID_DynamicQParms.startQValue = uint.Parse(entryQOverride.Text);
            BleMvxApplication._config.RFID_DynamicQParms.maxQValue = uint.Parse(entryMaxQ.Text);
            BleMvxApplication._config.RFID_DynamicQParms.minQValue = uint.Parse(entryMinQ.Text);
            BleMvxApplication._config.RFID_FixedQParms.qValue = uint.Parse(entryQOverride.Text);
            BleMvxApplication._config.RFID_DynamicQParms.QIncreaseUseQuery = switchQIncreaseUseQuery.IsToggled;
            BleMvxApplication._config.RFID_DynamicQParms.QDecreaseUseQuery = switchQDecreaseUseQuery.IsToggled;
            BleMvxApplication._config.RFID_DynamicQParms.MinQCycles = uint.Parse(entryMinQCycled.Text);
            BleMvxApplication._config.RFID_DynamicQParms.NoEPCMaxQ = uint.Parse(entryNoEPCMaxQ.Text);

            int colonIndex = buttonProfile.Text.IndexOf(":");
            if (colonIndex > 0)
                BleMvxApplication._config.RFID_Profile = UInt16.Parse(buttonProfile.Text.Substring(0, colonIndex));

            BleMvxApplication.SaveConfig();

            BleMvxApplication._reader.rfid.SetCountry(BleMvxApplication._config.RFID_Region, (int)BleMvxApplication._config.RFID_FixedChannel);
        }

        public async void entryInventoryDurationCompleted(object sender, EventArgs e)
        {
            uint value;

            try
            {
                value = uint.Parse(entryInventoryDuration.Text);
                if (value < 0 || value > 3000)
                    throw new System.ArgumentException("Value not valid", "tagPopulation");
                entryInventoryDuration.Text = value.ToString();
            }
            catch (Exception ex)
            {
                await DisplayAlert("", "Value not valid!!!", "OK");
                entryInventoryDuration.Text = "0";
            }
        }

        public async void buttonSessionClicked(object sender, EventArgs e)
        {
            var answer = await DisplayActionSheet("Session", "Cancel", null, "S0", "S1", "S2", "S3"); // S2 S3

            if (answer != null && answer !="Cancel")
                buttonSession.Text = answer;
        }

        public async void buttonTargetClicked(object sender, EventArgs e)
        {
            var answer = await DisplayActionSheet(null, "Cancel", null, "A", "B", "Toggle A/B");

            if (answer != null && answer !="Cancel")
                buttonTarget.Text = answer;
        }

        public async void buttonAlgorithmClicked(object sender, EventArgs e)
        {
            var answer = await DisplayAlert("Algorithm", "", "DYNAMICQ", "FIXEDQ");
            buttonAlgorithm.Text = answer ? "DYNAMICQ" : "FIXEDQ";
        }

        void SetQvalue ()
        {
            switch (buttonAlgorithm.Text)
            {
                default:
                    entryQOverride.Text = "0";
                    break;

                case "DYNAMICQ":
                    entryQOverride.Text = BleMvxApplication._config.RFID_DynamicQParms.startQValue.ToString();
                    break;

                case "FIXEDQ":
                    entryQOverride.Text = BleMvxApplication._config.RFID_FixedQParms.qValue.ToString();
                    break;
            }
        }

        public async void buttonProfileClicked(object sender, EventArgs e)
        {
            var answer = await DisplayActionSheet(null, "Cancel", null, _profileList);

            if (answer != null && answer != "Cancel")
            {
                buttonProfile.Text = answer;

                if (BleMvxApplication._reader.rfid.GetModel() == CSLibrary.RFIDDEVICE.MODEL.CS108)
                {
                    if (uint.Parse(answer.Substring(0, 3)) == 3)
                        entryCompactInventoryDelay.Text = "2";
                    else
                        entryCompactInventoryDelay.Text = "0";
                }
            }
        }

        public async void switchFocusPropertyChanged(object sender, EventArgs e)
        {
            if (switchFocus == null)
                return;

            if (switchFocus.IsToggled)
            {
                buttonSession.Text = "S1";
                buttonTarget.Text = "A";
                entryCompactInventoryDelay.Text = "0";
                entryInventoryDuration.Text = "2000";
                buttonSession.IsEnabled = false;
                buttonTarget.IsEnabled = false;
                entryCompactInventoryDelay.IsEnabled = false;
                entryInventoryDuration.IsEnabled = false;
            }
            else
            {
                buttonSession.IsEnabled = true;
                buttonTarget.IsEnabled = true;
                entryCompactInventoryDelay.IsEnabled = true;
                entryInventoryDuration.IsEnabled = true;
            }

        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/PagesViewModelsSet/Settings/PageSettingPowerSequencing.xaml.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MvvmCross.Forms.Views;
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace BLE.Client.Pages
{
	public partial class PageSettingPower : MvxContentPage
    {
        public PageSettingPower()
        {
            InitializeComponent();

            if (Device.RuntimePlatform == Device.iOS)
            {
                this.Icon = new FileImageSource();
                this.Icon.File = "icons8-Settings-50-3-30x30.png";
            }

            entryNumberofPower.Text = BleMvxApplication._config.RFID_PowerSequencing_NumberofPower.ToString();
            entryPower1.Text = BleMvxApplication._config.RFID_PowerSequencing_Level[0].ToString();
            entryDWell1.Text = BleMvxApplication._config.RFID_PowerSequencing_DWell[0].ToString();
            entryPower2.Text = BleMvxApplication._config.RFID_PowerSequencing_Level[1].ToString();
            entryDWell2.Text = BleMvxApplication._config.RFID_PowerSequencing_DWell[1].ToString();
            entryPower3.Text = BleMvxApplication._config.RFID_PowerSequencing_Level[2].ToString();
            entryDWell3.Text = BleMvxApplication._config.RFID_PowerSequencing_DWell[2].ToString();
            entryPower4.Text = BleMvxApplication._config.RFID_PowerSequencing_Level[3].ToString();
            entryDWell4.Text = BleMvxApplication._config.RFID_PowerSequencing_DWell[3].ToString();
            entryPower5.Text = BleMvxApplication._config.RFID_PowerSequencing_Level[4].ToString();
            entryDWell5.Text = BleMvxApplication._config.RFID_PowerSequencing_DWell[4].ToString();
            entryPower6.Text = BleMvxApplication._config.RFID_PowerSequencing_Level[5].ToString();
            entryDWell6.Text = BleMvxApplication._config.RFID_PowerSequencing_DWell[5].ToString();
            entryPower7.Text = BleMvxApplication._config.RFID_PowerSequencing_Level[6].ToString();
            entryDWell7.Text = BleMvxApplication._config.RFID_PowerSequencing_DWell[6].ToString();
            entryPower8.Text = BleMvxApplication._config.RFID_PowerSequencing_Level[7].ToString();
            entryDWell8.Text = BleMvxApplication._config.RFID_PowerSequencing_DWell[7].ToString();
            entryPower9.Text = BleMvxApplication._config.RFID_PowerSequencing_Level[8].ToString();
            entryDWell9.Text = BleMvxApplication._config.RFID_PowerSequencing_DWell[8].ToString();
            entryPower10.Text = BleMvxApplication._config.RFID_PowerSequencing_Level[9].ToString();
            entryDWell10.Text = BleMvxApplication._config.RFID_PowerSequencing_DWell[9].ToString();
            entryPower11.Text = BleMvxApplication._config.RFID_PowerSequencing_Level[10].ToString();
            entryDWell11.Text = BleMvxApplication._config.RFID_PowerSequencing_DWell[10].ToString();
            entryPower12.Text = BleMvxApplication._config.RFID_PowerSequencing_Level[11].ToString();
            entryDWell12.Text = BleMvxApplication._config.RFID_PowerSequencing_DWell[11].ToString();
            entryPower13.Text = BleMvxApplication._config.RFID_PowerSequencing_Level[12].ToString();
            entryDWell13.Text = BleMvxApplication._config.RFID_PowerSequencing_DWell[12].ToString();
            entryPower14.Text = BleMvxApplication._config.RFID_PowerSequencing_Level[13].ToString();
            entryDWell14.Text = BleMvxApplication._config.RFID_PowerSequencing_DWell[13].ToString();
            entryPower15.Text = BleMvxApplication._config.RFID_PowerSequencing_Level[14].ToString();
            entryDWell15.Text = BleMvxApplication._config.RFID_PowerSequencing_DWell[14].ToString();
            entryPower16.Text = BleMvxApplication._config.RFID_PowerSequencing_Level[15].ToString();
            entryDWell16.Text = BleMvxApplication._config.RFID_PowerSequencing_DWell[15].ToString();

            entryNumberofPowerUnfocused(null, null);
        }

        protected override void OnAppearing()
        {
            base.OnAppearing();
        }

        public async void entryNumberofPowerUnfocused(object sender, EventArgs e)
        {
            int numberofPower;

            try
            {
                numberofPower = int.Parse(entryNumberofPower.Text);

                if (numberofPower > 16)
                    numberofPower = 16;
                else if (numberofPower < 0)
                    numberofPower = 0;
            }
            catch (Exception ex)
            {
                numberofPower = 0; 
            }

            entryNumberofPower.Text = numberofPower.ToString();

            stackPower1.IsVisible = (numberofPower >= 1);
            stackPower2.IsVisible = (numberofPower >= 2);
            stackPower3.IsVisible = (numberofPower >= 3);
            stackPower4.IsVisible = (numberofPower >= 4);
            stackPower5.IsVisible = (numberofPower >= 5);
            stackPower6.IsVisible = (numberofPower >= 6);
            stackPower7.IsVisible = (numberofPower >= 7);
            stackPower8.IsVisible = (numberofPower >= 8);
            stackPower9.IsVisible = (numberofPower >= 9);
            stackPower10.IsVisible = (numberofPower >= 10);
            stackPower11.IsVisible = (numberofPower >= 11);
            stackPower12.IsVisible = (numberofPower >= 12);
            stackPower13.IsVisible = (numberofPower >= 13);
            stackPower14.IsVisible = (numberofPower >= 14);
            stackPower15.IsVisible = (numberofPower >= 15);
            stackPower16.IsVisible = (numberofPower >= 16);
        }

        public async void btnOKClicked(object sender, EventArgs e)
        {
            Xamarin.Forms.DependencyService.Get<ISystemSound>().SystemSound(1);

            BleMvxApplication._config.RFID_PowerSequencing_NumberofPower = int.Parse(entryNumberofPower.Text);
            BleMvxApplication._config.RFID_PowerSequencing_Level[0] = uint.Parse(entryPower1.Text);
            BleMvxApplication._config.RFID_PowerSequencing_DWell[0] = uint.Parse(entryDWell1.Text);
            BleMvxApplication._config.RFID_PowerSequencing_Level[1] = uint.Parse(entryPower2.Text);
            BleMvxApplication._config.RFID_PowerSequencing_DWell[1] = uint.Parse(entryDWell2.Text);
            BleMvxApplication._config.RFID_PowerSequencing_Level[2] = uint.Parse(entryPower3.Text);
            BleMvxApplication._config.RFID_PowerSequencing_DWell[2] = uint.Parse(entryDWell3.Text);
            BleMvxApplication._config.RFID_PowerSequencing_Level[3] = uint.Parse(entryPower4.Text);
            BleMvxApplication._config.RFID_PowerSequencing_DWell[3] = uint.Parse(entryDWell4.Text);
            BleMvxApplication._config.RFID_PowerSequencing_Level[4] = uint.Parse(entryPower5.Text);
            BleMvxApplication._config.RFID_PowerSequencing_DWell[4] = uint.Parse(entryDWell5.Text);
            BleMvxApplication._config.RFID_PowerSequencing_Level[5] = uint.Parse(entryPower6.Text);
            BleMvxApplication._config.RFID_PowerSequencing_DWell[5] = uint.Parse(entryDWell6.Text);
            BleMvxApplication._config.RFID_PowerSequencing_Level[6] = uint.Parse(entryPower7.Text);
            BleMvxApplication._config.RFID_PowerSequencing_DWell[6] = uint.Parse(entryDWell7.Text);
            BleMvxApplication._config.RFID_PowerSequencing_Level[7] = uint.Parse(entryPower8.Text);
            BleMvxApplication._config.RFID_PowerSequencing_DWell[7] = uint.Parse(entryDWell8.Text);
            BleMvxApplication._config.RFID_PowerSequencing_Level[8] = uint.Parse(entryPower9.Text);
            BleMvxApplication._config.RFID_PowerSequencing_DWell[8] = uint.Parse(entryDWell9.Text);
            BleMvxApplication._config.RFID_PowerSequencing_Level[9] = uint.Parse(entryPower10.Text);
            BleMvxApplication._config.RFID_PowerSequencing_DWell[9] = uint.Parse(entryDWell10.Text);
            BleMvxApplication._config.RFID_PowerSequencing_Level[10] = uint.Parse(entryPower11.Text);
            BleMvxApplication._config.RFID_PowerSequencing_DWell[10] = uint.Parse(entryDWell11.Text);
            BleMvxApplication._config.RFID_PowerSequencing_Level[11] = uint.Parse(entryPower12.Text);
            BleMvxApplication._config.RFID_PowerSequencing_DWell[11] = uint.Parse(entryDWell12.Text);
            BleMvxApplication._config.RFID_PowerSequencing_Level[12] = uint.Parse(entryPower13.Text);
            BleMvxApplication._config.RFID_PowerSequencing_DWell[12] = uint.Parse(entryDWell13.Text);
            BleMvxApplication._config.RFID_PowerSequencing_Level[13] = uint.Parse(entryPower14.Text);
            BleMvxApplication._config.RFID_PowerSequencing_DWell[13] = uint.Parse(entryDWell14.Text);
            BleMvxApplication._config.RFID_PowerSequencing_Level[14] = uint.Parse(entryPower15.Text);
            BleMvxApplication._config.RFID_PowerSequencing_DWell[14] = uint.Parse(entryDWell15.Text);
            BleMvxApplication._config.RFID_PowerSequencing_Level[15] = uint.Parse(entryPower16.Text);
            BleMvxApplication._config.RFID_PowerSequencing_DWell[15] = uint.Parse(entryDWell16.Text);

            BleMvxApplication.SaveConfig();

            if (BleMvxApplication._config.RFID_PowerSequencing_NumberofPower == 0)
                BleMvxApplication._reader.rfid.SetPowerSequencing(0);
            else
                BleMvxApplication._reader.rfid.SetPowerSequencing(BleMvxApplication._config.RFID_PowerSequencing_NumberofPower, BleMvxApplication._config.RFID_PowerSequencing_Level, BleMvxApplication._config.RFID_PowerSequencing_DWell);
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/PagesViewModelsSet/Settings/ViewModelSetting.cs">
using System;
using Acr.UserDialogs;
using Plugin.BLE.Abstractions.Contracts;

using MvvmCross.ViewModels;

namespace BLE.Client.ViewModels
{
    public class ViewModelSetting : BaseViewModel
    {
        private readonly IUserDialogs _userDialogs;


        public ViewModelSetting(IAdapter adapter, IUserDialogs userDialogs) : base(adapter)
        {
            _userDialogs = userDialogs;
        }

        public override void ViewAppearing()
        {
            base.ViewAppearing();

            BleMvxApplication._reader.siliconlabIC.OnAccessCompleted += new EventHandler<CSLibrary.SiliconLabIC.Events.OnAccessCompletedEventArgs>(OnAccessCompletedEvent);
        }

        public override void ViewDisappearing()
        {
            BleMvxApplication._reader.siliconlabIC.OnAccessCompleted -= new EventHandler<CSLibrary.SiliconLabIC.Events.OnAccessCompletedEventArgs>(OnAccessCompletedEvent);

            base.ViewDisappearing();
        }

        protected override void InitFromBundle(IMvxBundle parameters)
        {
            base.InitFromBundle(parameters);
        }

        void OnAccessCompletedEvent(object sender, CSLibrary.SiliconLabIC.Events.OnAccessCompletedEventArgs e)
        {
            InvokeOnMainThread(() =>
            {
                switch (e.type)
                {
                    case CSLibrary.SiliconLabIC.Constants.AccessCompletedCallbackType.SERIALNUMBER:
                        _userDialogs.Alert("Serial Number : " + (string)e.info);
                        break;
                }
            });
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/PagesViewModelsSet/ViewModelMainMenu.cs">
using System;
using System.Collections.Generic;
using Acr.UserDialogs;
using MvvmCross;
using Plugin.BLE.Abstractions.Contracts;

using System.ComponentModel;
using System.Windows.Input;
using Xamarin.Forms;

using BLE.Client.Extensions;

using Plugin.BLE.Abstractions;
using Plugin.Settings.Abstractions;
using MvvmCross.ViewModels;
using MvvmCross.Navigation;
using BLE.Client.Pages;
using BLE.Client.ViewModels;

using static CSLibrary.RFIDDEVICE;
using static CSLibrary.FrequencyBand;
using Xamarin.Essentials;
using System.Threading.Tasks;

namespace BLE.Client.ViewModels
{
    public class ViewModelMainMenu : BaseViewModel
    {
        private readonly IUserDialogs _userDialogs;
        private IDevice _device;

        public string connectedButton { get; set; }
        public string labelVoltage { get; set; }
        public string labelVoltageTextColor { get { return BleMvxApplication._batteryLow ? "Red" : "Black"; } }
        public string connectedButtonTextColor { get; set; } = "Black";
        public string labelAppVersion { get; set; }

        public ViewModelMainMenu(IBluetoothLE bluetoothLe, IAdapter adapter, IUserDialogs userDialogs, ISettings settings) : base(adapter)
        {
            _userDialogs = userDialogs;

            this.labelAppVersion = "Version\n" + DependencyService.Get<IAppVersion>().GetVersion();
            RaisePropertyChanged(() => labelAppVersion);

            Adapter.DeviceConnectionLost += OnDeviceConnectionLost;

            OnInventoryButtonCommand = new Command(OnInventoryButtonClicked);
			OnGeigerButtonCommand = new Command(OnGeigerButtonClicked);
			OnSettingButtonCommand = new Command(OnSettingButtonClicked);
            OnConnectButtonCommand = new Command(OnConnectButtonClicked);

            GetPermission();
        }

        ~ViewModelMainMenu()
        {
            SetEvent(false);
        }

        // MUST be geant location permission
        private async void GetPermission()
        {
            if (Device.RuntimePlatform == Device.Android)
            {
                while (await Permissions.CheckStatusAsync<Permissions.LocationWhenInUse>() != PermissionStatus.Granted)
                {
                    await _userDialogs.AlertAsync("This app collects location data in the background.  In terms of the features using this location data in the background, this App collects location data when it is reading temperature RFID tag in the Magnus S3 with GPS for Advantech page.  The purpose of this is to correlate the RFID tag with the actual GNSS location of the tag.  In other words, this is to track the physical location of the logistics item tagged with the RFID tag.");
                    //                await _userDialogs.AlertAsync("This app collects location data to enable temperature RFID tag inventory with GNSS location mapped to each tag data when the app is open and in the foreground.  This location data collection is not carried out when the app is closed or not in use.   Specifically, this App collects location data when it is reading temperature RFID tag in the Magnus S3 with GPS for Advantech page.");

                    await Permissions.RequestAsync<Permissions.LocationWhenInUse>();
                }
            }
        }

        private void CheckConnection ()
        {
            if (BleMvxApplication._reader.Status != CSLibrary.HighLevelInterface.READERSTATE.DISCONNECT)
            {
                connectedButton = "Connected to " + BleMvxApplication._reader.ReaderName + "/Select Another";
                connectedButtonTextColor = "Blue";
            }
            else
            {
                connectedButton = "Press to Scan/Connect Reader";
                connectedButtonTextColor = "Red";
            }

            RaisePropertyChanged(() => connectedButton);
            RaisePropertyChanged(() => connectedButtonTextColor);
        }

        public override void ViewAppearing()
        {
            BleMvxApplication._reader.rfid.StopOperation();
            BleMvxApplication._reader.barcode.Stop();

            base.ViewAppearing();

            BleMvxApplication._inventoryEntryPoint = 0;

            SetEvent(true);

            CheckConnection();

            if (BleMvxApplication._reader.rfid.GetModel() != MODEL.UNKNOWN)
            {
                BleMvxApplication._reader.rfid.CancelAllSelectCriteria();
                //BleMvxApplication._reader.rfid.SetRSSIFilter(CSLibrary.Constants.RSSIFILTERTYPE.DISABLE);
            }
            BleMvxApplication._reader.rfid.Options.TagRanging.focus = false;
            BleMvxApplication._reader.rfid.Options.TagRanging.fastid = false;
        }

        public override void ViewDisappearing()
        {
            base.ViewDisappearing();
        }

        protected override void InitFromBundle(IMvxBundle parameters)
        {
            base.InitFromBundle(parameters);

            _device = GetDeviceFromBundle(parameters);

            if (_device == null)
            {
                var navigation = Mvx.IoCProvider.Resolve<IMvxNavigationService>();
                navigation.Close(this);
            }
		}

        void SetEvent(bool onoff)
        {
            BleMvxApplication._reader.CancelEventOnReaderStateChanged();
            BleMvxApplication._reader.notification.ClearEventHandler(); // Key Button event handler
            BleMvxApplication._reader.rfid.ClearEventHandler(); // Cancel RFID event handler
            BleMvxApplication._reader.barcode.ClearEventHandler(); // Cancel Barcode event handler

            if (onoff)
            {
                BleMvxApplication._reader.OnReaderStateChanged += new EventHandler<CSLibrary.Events.OnReaderStateChangedEventArgs>(ReaderStateCChangedEvent);
                BleMvxApplication._reader.notification.OnVoltageEvent += new EventHandler<CSLibrary.Notification.VoltageEventArgs>(VoltageEvent);
                BleMvxApplication._reader.notification.OnKeyEvent += new EventHandler<CSLibrary.Notification.HotKeyEventArgs>(HotKeys_OnKeyEvent);
                BleMvxApplication._reader.rfid.OnStateChanged += new EventHandler<CSLibrary.Events.OnStateChangedEventArgs>(StateChangedEvent);
            }
        }

        private async void Disconnect()
        {
            BleMvxApplication._reader.DisconnectAsync();
        }

        void StateChangedEvent(object sender, CSLibrary.Events.OnStateChangedEventArgs e)
        {
            if (e.state == CSLibrary.Constants.RFState.INITIALIZATION_COMPLETE)
            {
                //Trace.Message("load config");
                {
                    //_ = BleMvxApplication.LoadConfig(BleMvxApplication._deviceinfo.Id.ToString(), BleMvxApplication._reader.rfid.GetModel(), (int)BleMvxApplication._reader.rfid.GetCountry());
                    //BleMvxApplication._config.readerID = BleMvxApplication._deviceinfo.Id.ToString();
                    if (BleMvxApplication._reader.rfid.GetModel() == MODEL.CS710S)
                    {
                        if (new Version(BleMvxApplication._reader.rfid.GetFirmwareVersionString()) < new Version("2.1.2"))
                        {
                            if (BleMvxApplication._config.RFID_Profile == 343)
                                BleMvxApplication._config.RFID_Profile = 244;
                        }

                        if (new Version(BleMvxApplication._reader.rfid.GetFirmwareVersionString()) >= new Version("2.1.2"))
                        {
                            if (BleMvxApplication._reader.rfid.GetModelCountry().Equals("CS710S-1"))
                            {
                                if (BleMvxApplication._config.RFID_Profile == 343)
                                    BleMvxApplication._config.RFID_Profile = 342;
                                else if (BleMvxApplication._config.RFID_Profile == 244)
                                    BleMvxApplication._config.RFID_Profile = 241;
                            }
                        }
                    }
                }

                // System Setting
                //                Xamarin.Essentials.DeviceDisplay.KeepScreenOn = BleMvxApplication._config._keepScreenOn;
                BleMvxApplication._batteryLow = false;
                RaisePropertyChanged(() => labelVoltageTextColor);

                // Set Country and Region information
                if (BleMvxApplication._config.RFID_Region == "" || BleMvxApplication._config.readerModel != BleMvxApplication._reader.rfid.GetModel())
                {
                    BleMvxApplication._config.readerModel = BleMvxApplication._reader.rfid.GetModel();
                    BleMvxApplication._config.RFID_Region = BleMvxApplication._reader.rfid.GetCurrentCountry();

                    if (BleMvxApplication._reader.rfid.IsFixedChannel())
                    {
                        BleMvxApplication._config.RFID_FrequenceSwitch = 1;
                        BleMvxApplication._config.RFID_FixedChannel = BleMvxApplication._reader.rfid.GetCurrentFrequencyChannel();
                    }
                    else
                    {
                        BleMvxApplication._config.RFID_FrequenceSwitch = 0; // Hopping
                    }
                }

                uint portNum = BleMvxApplication._reader.rfid.GetAntennaPort();
                for (uint cnt = 0; cnt < portNum; cnt++)
                {
                    BleMvxApplication._reader.rfid.SetAntennaPortState(cnt, BleMvxApplication._config.RFID_AntennaEnable[cnt] ? CSLibrary.Constants.AntennaPortState.ENABLED : CSLibrary.Constants.AntennaPortState.DISABLED);
                    BleMvxApplication._reader.rfid.SetPowerLevel(BleMvxApplication._config.RFID_Antenna_Power[cnt], cnt);
                    BleMvxApplication._reader.rfid.SetInventoryDuration(BleMvxApplication._config.RFID_Antenna_Dwell[cnt], cnt);
                }

                if ((BleMvxApplication._reader.bluetoothIC.GetFirmwareVersion() & 0x0F0000) != 0x030000) // ignore CS463
                    /*
                if (BleMvxApplication._reader.rfid.GetFirmwareVersion() < 0x0002061D || BleMvxApplication._reader.siliconlabIC.GetFirmwareVersion() < 0x00010010 || BleMvxApplication._reader.bluetoothIC.GetFirmwareVersion() < 0x00010011)
                {
                    _userDialogs.AlertAsync("Firmware too old" + Environment.NewLine + 
                                            "Please upgrade firmware to at least :" + Environment.NewLine +
                                            "RFID Processor firmware: V2.6.44" + Environment.NewLine +
                                            "SiliconLab Firmware: V1.0.16" + Environment.NewLine +
                                            "Bluetooth Firmware: V1.0.17");
                }
                    */
                ClassBattery.SetBatteryMode(ClassBattery.BATTERYMODE.IDLE);
                BleMvxApplication._reader.battery.SetPollingTime(BleMvxApplication._config.RFID_BatteryPollingTime);
            }
        }

        void ReaderStateCChangedEvent(object sender, CSLibrary.Events.OnReaderStateChangedEventArgs e)
        {
            InvokeOnMainThread(() =>
            {
                Trace.Message(e.type.ToString());

                switch (e.type)
                {
                    case CSLibrary.Constants.ReaderCallbackType.COMMUNICATION_ERROR:
                        {
                            _userDialogs.AlertAsync("Reader communication error, Please reset reader");

                            //                        _userDialogs.HideLoading();
                            //                        _userDialogs.ErrorToast("Error", $"BLE protocol error, Please reset reader", TimeSpan.MaxValue);
                        }
                        break;

                    case CSLibrary.Constants.ReaderCallbackType.CONNECTION_LOST:
                        break;

                    default:
                        break;
                }

                CheckConnection();
            });
        }

        DateTime _keyPressStartTime;

        void HotKeys_OnKeyEvent(object sender, CSLibrary.Notification.HotKeyEventArgs e)
        {
            if (BleMvxApplication._config == null) // reader not connected
                return;

            if (e.KeyCode == CSLibrary.Notification.Key.BUTTON)
            {
                if (e.KeyDown)
                {
                    _keyPressStartTime = DateTime.Now;
                }
                else
                {
                    double duration = (DateTime.Now - _keyPressStartTime).TotalMilliseconds;

                    for (int cnt = 0; cnt < BleMvxApplication._config.RFID_Shortcut.Length; cnt++)
                    {
                        if (duration >= BleMvxApplication._config.RFID_Shortcut[cnt].DurationMin && duration <= BleMvxApplication._config.RFID_Shortcut[cnt].DurationMax)
                        {
                            switch (BleMvxApplication._config.RFID_Shortcut[cnt].Function)
                            {
                                case CONFIG.MAINMENUSHORTCUT.FUNCTION.INVENTORY:
                                    BleMvxApplication._inventoryEntryPoint = 0;
                                    OnInventoryButtonClicked();
                                    break;

                                case CONFIG.MAINMENUSHORTCUT.FUNCTION.BARCODE:
                                    BleMvxApplication._inventoryEntryPoint = 1;
                                    OnInventoryButtonClicked();
                                    break;
                            }

                            break;
                        }
                    }
                }
            }
        }

        bool _firstTimeBatteryLowAlert = true;

        void VoltageEvent(object sender, CSLibrary.Notification.VoltageEventArgs e)
		{
            if (BleMvxApplication._config == null) // reader not connected
                return;

			if (e.Voltage == 0xffff)
			{
				labelVoltage = "Battery ERROR"; //			3.98v
			}
			else
			{
                double voltage = (double)e.Voltage / 1000;

                {
                    var batlow = ClassBattery.BatteryLow(voltage);

                    if (BleMvxApplication._batteryLow && batlow == ClassBattery.BATTERYLEVELSTATUS.NORMAL)
                    {
                        BleMvxApplication._batteryLow = false;
                        RaisePropertyChanged(() => labelVoltageTextColor);
                    }
                    else
                    if (!BleMvxApplication._batteryLow && batlow != ClassBattery.BATTERYLEVELSTATUS.NORMAL)
                    {
                        BleMvxApplication._batteryLow = true;

                        if (batlow == ClassBattery.BATTERYLEVELSTATUS.LOW)
                            _userDialogs.AlertAsync("20% Battery Life Left, Please Recharge RFID Reader or Replace Freshly Charged Battery");
                        //else if (batlow == ClassBattery.BATTERYLEVELSTATUS.LOW_17)
                        //    _userDialogs.AlertAsync("8% Battery Life Left, Please Recharge RFID Reader or Replace with Freshly Charged Battery");

                        RaisePropertyChanged(() => labelVoltageTextColor);
                    }
                }

                switch (BleMvxApplication._config.BatteryLevelIndicatorFormat)
                {
                    case 0:
                        labelVoltage = "Battery " + voltage.ToString("0.000") + "v"; //			v
                        break;

                    default:
                        labelVoltage = "Battery " + ClassBattery.Voltage2Percent(voltage).ToString("0") + "%" + " " + voltage.ToString("0.000") + "v"; //			%
                        break;
                }
            }

            RaisePropertyChanged(() => labelVoltage);
		}

		public ICommand OnInventoryButtonCommand { protected set; get; }

        void OnInventoryButtonClicked()
        {
            if (BleMvxApplication._reader.BLEBusy)
            {
                _userDialogs.ShowSuccess("Configuring Reader, Please Wait", 1000);
            }
            else
            {
                if (BleMvxApplication._reader.Status == CSLibrary.HighLevelInterface.READERSTATE.DISCONNECT)
                {
                    ShowConnectionWarringMessage();
                    return;
                }

                //ShowViewModel<ViewModelInventorynScan>(new MvxBundle());
                var navigation = Mvx.IoCProvider.Resolve<IMvxNavigationService>();
                navigation.Navigate<ViewModelInventorynScan>(new MvxBundle());
            }
        }

		public ICommand OnGeigerButtonCommand { protected set; get; }

		void OnGeigerButtonClicked()
		{
            if (BleMvxApplication._reader.Status == CSLibrary.HighLevelInterface.READERSTATE.DISCONNECT)
            {
                ShowConnectionWarringMessage();
                return;
            }

            //ShowViewModel<ViewModelGeiger>(new MvxBundle());
            var navigation = Mvx.IoCProvider.Resolve<IMvxNavigationService>();
            navigation.Navigate<ViewModelGeiger>(new MvxBundle());
        }

		public ICommand OnSettingButtonCommand { protected set; get; }

        void OnSettingButtonClicked()
        {
            if (BleMvxApplication._reader.BLEBusy)
            {
                _userDialogs.ShowSuccess("Configuring Reader, Please Wait", 1000);
            }
            else
            {
                if (BleMvxApplication._reader.Status == CSLibrary.HighLevelInterface.READERSTATE.DISCONNECT)
                {
                    ShowConnectionWarringMessage();
                    return;
                }

                //ShowViewModel<ViewModelSetting>(new MvxBundle());
                var navigation = Mvx.IoCProvider.Resolve<IMvxNavigationService>();
                navigation.Navigate<ViewModelSetting>(new MvxBundle());
            }
        }

        public ICommand OnConnectButtonCommand { protected set; get; }

        void OnConnectButtonClicked()
        {
            if (BleMvxApplication._reader.BLEBusy)
            {
                _userDialogs.ShowSuccess("Configuring Reader, Please Wait", 1000);
                return;
            }

            // for Geiger and Read/Write
            BleMvxApplication._SELECT_EPC = "";
            //BleMvxApplication._SELECT_EPC = "E280115020001144766E1800"; // for testing
            BleMvxApplication._SELECT_PC = 3000;

            // for PreFilter
            BleMvxApplication._PREFILTER_MASK_EPC = "";
            BleMvxApplication._PREFILTER_MASK_Offset = 0;
            BleMvxApplication._PREFILTER_MASK_Truncate = 0;
            BleMvxApplication._PREFILTER_Enable = false;

            // for Post Filter
            BleMvxApplication._POSTFILTER_MASK_EPC = "";
            BleMvxApplication._POSTFILTER_MASK_Offset = 0;
            BleMvxApplication._POSTFILTER_MASK_MatchNot = false;
            BleMvxApplication._POSTFILTER_MASK_Enable = false;

            labelVoltage = "";
            RaisePropertyChanged(() => labelVoltage);

            //ShowViewModel<DeviceListViewModel>(new MvxBundle());
            var navigation = Mvx.IoCProvider.Resolve<IMvxNavigationService>();
            navigation.Navigate<DeviceListViewModel>(new MvxBundle());

            CheckConnection();
        }

        async void ShowConnectionWarringMessage ()
        {
            string connectWarringMsg = "Reader NOT connected\n\nPlease connect to reader first!!!";

            _userDialogs.ShowSuccess (connectWarringMsg, 2500);
        }

        private void OnDeviceConnectionLost(object sender, Plugin.BLE.Abstractions.EventArgs.DeviceErrorEventArgs e)
        {
            CheckConnection();
        }

    }
}
</file>

<file path="MobileMvxApp/BLE.Client/ViewModels/BaseViewModel.cs">
using System;
using System.Linq;
using System.Threading.Tasks;
using MvvmCross;
using MvvmCross.Logging;
using MvvmCross.ViewModels;
using Plugin.BLE.Abstractions.Contracts;

namespace BLE.Client.ViewModels
{
    public class BaseViewModel : MvxViewModel<MvxBundle>
    {
        protected readonly IAdapter Adapter;
        protected const string DeviceIdKey = "DeviceIdNavigationKey";
        protected const string ServiceIdKey = "ServiceIdNavigationKey";
        protected const string CharacteristicIdKey = "CharacteristicIdNavigationKey";
        protected const string DescriptorIdKey = "DescriptorIdNavigationKey";

        private readonly IMvxLog _log;

        public BaseViewModel(IAdapter adapter)
        {
            Adapter = adapter;
            _log = Mvx.IoCProvider.Resolve<IMvxLog>();
        }

        public override void ViewAppeared()
        {
            _log.Trace("ViewAppeared {0}", GetType().Name);
        }

        public override void ViewDisappeared()
        {
            _log.Trace("ViewDisappeared {0}", GetType().Name);
        }

        public override void Prepare(MvxBundle parameters)
        {
            Bundle = parameters;
        }

        protected IMvxBundle Bundle { get; private set; }

        protected IDevice GetDeviceFromBundle(IMvxBundle parameters)
        {
            if (!parameters.Data.ContainsKey(DeviceIdKey)) return null;
            var deviceId = parameters.Data[DeviceIdKey];

            return Adapter.ConnectedDevices.FirstOrDefault(d => d.Id.ToString().Equals(deviceId));

        }

        protected Task<IService> GetServiceFromBundleAsync(IMvxBundle parameters)
        {

            var device = GetDeviceFromBundle(parameters);
            if (device == null || !parameters.Data.ContainsKey(ServiceIdKey))
            {
                return Task.FromResult<IService>(null);
            }

            var serviceId = parameters.Data[ServiceIdKey];
            return device.GetServiceAsync(Guid.Parse(serviceId));
        }

        protected async Task<ICharacteristic> GetCharacteristicFromBundleAsync(IMvxBundle parameters)
        {
            var service = await GetServiceFromBundleAsync(parameters);
            if (service == null || !parameters.Data.ContainsKey(CharacteristicIdKey))
            {
                return null;
            }

            var characteristicId = parameters.Data[CharacteristicIdKey];
            return await service.GetCharacteristicAsync(Guid.Parse(characteristicId));
        }

        protected async Task<IDescriptor> GetDescriptorFromBundleAsync(IMvxBundle parameters)
        {
            var characteristic = await GetCharacteristicFromBundleAsync(parameters);
            if (characteristic == null || !parameters.Data.ContainsKey(DescriptorIdKey))
            {
                return null;
            }

            var descriptorId = parameters.Data[DescriptorIdKey];
            return await characteristic.GetDescriptorAsync(Guid.Parse(descriptorId));
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/ViewModels/DeviceListItemViewModel.cs">
using System;
using MvvmCross.ViewModels;
using Plugin.BLE.Abstractions;
using Plugin.BLE.Abstractions.Contracts;
using static CSLibrary.RFIDDEVICE;

namespace BLE.Client.ViewModels
{
    public class DeviceListItemViewModel : MvxNotifyPropertyChanged
    {
        public IDevice Device { get; private set; }
        public MODEL BTServiceType { get; private set; }
        
        public Guid Id => Device.Id;
        public string IdString {
            get {
                if (Xamarin.Forms.Device.RuntimePlatform == Xamarin.Forms.Device.iOS)
                    return Id.ToString();

                string idString = Id.ToString().ToUpper();
                string macString = idString.Substring(idString.Length - 12, 2) + ":";
                macString += idString.Substring(idString.Length - 10, 2) + ":";
                macString += idString.Substring(idString.Length - 8, 2) + ":";
                macString += idString.Substring(idString.Length - 6, 2) + ":";
                macString += idString.Substring(idString.Length - 4, 2) + ":";
                macString += idString.Substring(idString.Length - 2, 2);
                return macString;
            } 
        }
        public string Model => BTServiceType.ToString();
        //public bool IsConnected => Device.State == DeviceState.Connected;
        public bool IsConnected { get; private set; }
        public int Rssi => Device.Rssi;
        public string Name => Device.Name;

        public DeviceListItemViewModel(IDevice device, MODEL BTServiceType, bool isConnected = false)
        {
            this.Device = device;
            this.BTServiceType = BTServiceType;
            this.IsConnected = isConnected;
        }

        public void Update(IDevice newDevice = null)
        {
            if (newDevice != null)
            {
                Device = newDevice;
            }
            RaisePropertyChanged(nameof(IsConnected));
            RaisePropertyChanged(nameof(Rssi));
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/ViewModels/DeviceListViewModel.cs">
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Acr.UserDialogs;
using BLE.Client.Extensions;
using CSLibrary;
using MvvmCross;
using MvvmCross.Commands;
using MvvmCross.Navigation;
using Plugin.BLE.Abstractions;
using Plugin.BLE.Abstractions.Contracts;
using Plugin.BLE.Abstractions.EventArgs;
using Plugin.BLE.Abstractions.Extensions;
using Plugin.Settings.Abstractions;
using Xamarin.Forms;
using static CSLibrary.RFIDDEVICE;

namespace BLE.Client.ViewModels
{
    public class DeviceListViewModel : BaseViewModel
    {
        private readonly IBluetoothLE _bluetoothLe;
        private readonly IUserDialogs _userDialogs;
        private readonly ISettings _settings;
        private readonly IMvxNavigationService _navigation;
        
        private Guid _previousGuid;
        private CancellationTokenSource _cancellationTokenSource;

        public IList<IService> Services { get; private set; }
        public IDescriptor Descriptor { get; private set; }

        private string _version;
        public string version { get; set; }

        //public MvxCommand RefreshCommand => new MvxCommand(() => TryStartScanning(true));
        public MvxCommand<DeviceListItemViewModel> DisconnectCommand => new MvxCommand<DeviceListItemViewModel>(DisconnectDevice);

        public MvxCommand<DeviceListItemViewModel> ConnectDisposeCommand => new MvxCommand<DeviceListItemViewModel>(ConnectAndDisposeDevice);

        public ObservableCollection<DeviceListItemViewModel> Devices { get; set; } = new ObservableCollection<DeviceListItemViewModel>();
        public bool IsRefreshing => Adapter.IsScanning;
        public bool IsStateOn => _bluetoothLe.IsOn;
        public string StateText => GetStateText();
        public DeviceListItemViewModel SelectedDevice
        {
            get { return null; }
            set
            {
                if (value != null)
                {
                    if (value.IsConnected)
                    {
                        _userDialogs.ConfirmAsync($"This device is in OS Bluetooth list, please do the following:" + Environment.NewLine +
                            "1) in OS Bluetooth list, 'forget' it." + Environment.NewLine +
                            "2) after doing #1 above, make sure reader is not in HID mode. (characterized by fast Bluetooth LED flash). If reader is in HID mode, change to normal mode." + Environment.NewLine + 
                            Environment.NewLine +
                            "After #1 & #2 above, restart this App.");
                    }
                    else
                        HandleSelectedDevice(value);
                }

                RaisePropertyChanged();
            }
        }

        public MvxCommand StopScanCommand => new MvxCommand(() =>
        {
            try
            {
                Devices.Clear();

                _cancellationTokenSource.Cancel();
                CleanupCancellationToken();
                RaisePropertyChanged(() => IsRefreshing);
                Task.Delay(100).Wait();
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("can not stop _cancellationTokenSource");
            }
        }, () => _cancellationTokenSource != null);

        public DeviceListViewModel(IBluetoothLE bluetoothLe, IAdapter adapter, IUserDialogs userDialogs, ISettings settings, IMvxNavigationService navigation) : base(adapter)
        {
            _bluetoothLe = bluetoothLe;
            _userDialogs = userDialogs;
            _settings = settings;
            _navigation = navigation;

            _ = BleMvxApplication._reader.DisconnectAsync();

            // quick and dirty :>
            _bluetoothLe.StateChanged += OnStateChanged;
            //Adapter.DeviceDiscovered += OnDeviceDiscovered;
            Adapter.DeviceAdvertised += OnDeviceDiscovered;
            Adapter.ScanTimeoutElapsed += Adapter_ScanTimeoutElapsed;
            //            Adapter.DeviceDisconnected += OnDeviceDisconnected;
            //            Adapter.DeviceConnectionLost += OnDeviceConnectionLost;
            //Adapter.DeviceConnected += (sender, e) => Adapter.DisconnectDeviceAsync(e.Device);
        }

        private void OnDeviceConnectionLost(object sender, DeviceErrorEventArgs e)
        {
            Devices.FirstOrDefault(d => d.Id == e.Device.Id)?.Update();

            _userDialogs.HideLoading();
            _userDialogs.ErrorToast("Error", $"Connection LOST {e.Device.Name} Please reconnect reader", TimeSpan.FromMilliseconds(5000));
        }

        private void OnStateChanged(object sender, BluetoothStateChangedArgs e)
        {
            RaisePropertyChanged(nameof(IsStateOn));
            RaisePropertyChanged(nameof(StateText));
        }

        private string GetStateText()
        {
            try
            {
                switch (_bluetoothLe.State)
                {
                    //case BluetoothState.Unknown:
                    //return "Unknown BLE state.";
                    case BluetoothState.Unavailable:
                        return "BLE is not available on this device.";
                    case BluetoothState.Unauthorized:
                        return "You are not allowed to use BLE.";
                    case BluetoothState.TurningOn:
                        return "BLE is warming up, please wait.";
                    case BluetoothState.On:
                        return "BLE is on.";
                    case BluetoothState.TurningOff:
                        return "BLE is turning off. That's sad!";
                    case BluetoothState.Off:
                        if (Xamarin.Forms.Device.RuntimePlatform == Xamarin.Forms.Device.iOS)
                            _userDialogs.Alert("Please put finger at bottom of screen and swipe up Control Center and turn on Bluetooth.  If Bluetooth is already on, turn it off and on again");
                        return "BLE is off. Turn it on!";
                }
            }
            catch (Exception ex)
            {
            }

            return "Unknown BLE state.";
        }

        bool _scanAgain = true;

        private void Adapter_ScanTimeoutElapsed(object sender, EventArgs e)
        {
            RaisePropertyChanged(() => IsRefreshing);

            CleanupCancellationToken();

            if (_scanAgain)
                ScanForDevices();
        }

        private void OnDeviceDiscovered(object sender, DeviceEventArgs args)
        {
            try
            {
                bool CSLRFIDReaderService = false;
                MODEL BTServiceType = MODEL.UNKNOWN;

                // CS108 filter
                switch (Xamarin.Forms.Device.RuntimePlatform)
                {
                    case Xamarin.Forms.Device.UWP:
                        if (args.Device.AdvertisementRecords.Count < 1)
                            return;

                        foreach (AdvertisementRecord service in args.Device.AdvertisementRecords)
                        {
                            if (service.Data.Length == 2)
                            {
                                // CS108 Service ID = 0x0098
                                if (service.Data[0] == 0x00 && service.Data[1] == 0x98)
                                {
                                    BTServiceType = MODEL.CS108;
                                    CSLRFIDReaderService = true;
                                    break;
                                }

                                // CS710S Service ID = 0x0298
                                if ((service.Data[0] == 0x02 && service.Data[1] == 0x98))
                                {
                                    BTServiceType = MODEL.CS710S;
                                    CSLRFIDReaderService = true;
                                    break;
                                }
                            }
                        }
                        break;

                    default:
                        if (args.Device.AdvertisementRecords.Count < 1)
                            return;

                        foreach (AdvertisementRecord service in args.Device.AdvertisementRecords)
                        {
                            if (service.Data.Length == 2)
                            {
                                // CS108 Service ID = 0x9800
                                if (service.Data[0] == 0x98 && service.Data[1] == 0x00)
                                {
                                    BTServiceType = MODEL.CS108;
                                    CSLRFIDReaderService = true;
                                    break;
                                }

                                // CS710S Service ID ios = 0x9802, android = 0x5350
                                if ((service.Data[0] == 0x98 && service.Data[1] == 0x02) || (service.Data[0] == 0x53 && service.Data[1] == 0x50))
                                {
                                    BTServiceType = MODEL.CS710S;
                                    CSLRFIDReaderService = true;
                                    break;
                                }
                            }else if (service.Data.Length == 4)
                            {
                                if (service.Data[0] == 0x18 && service.Data[1] == 0x0d && service.Data[2] == 0x98 && service.Data[3] == 0x02)
                                {
                                    BTServiceType = MODEL.CS710S;
                                    CSLRFIDReaderService = true;
                                    break;
                                }
                            }
                        }
                        break;
                }

                if (!CSLRFIDReaderService)
                    return;

                AddOrUpdateDevice(args.Device, BTServiceType);
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("Can not handle desconvered device");
            }
        }

        private void AddOrUpdateDevice(IDevice device, MODEL BTServiceType, bool isConnected = false)
        {
            InvokeOnMainThread(() =>
            {
                try
                {
                    var vm = Devices.FirstOrDefault(d => d.Device.Id == device.Id);
                    if (vm != null)
                    {
                        vm.Update(device);
                    }
                    else
                    {
                        Devices.Add(new DeviceListItemViewModel(device, BTServiceType, isConnected));
                    }
                }
                catch (Exception ex)
                {
                    CSLibrary.Debug.WriteLine("Can not add device");
                }
            });
        }

        bool _runningViewAppearing = false;
        public override async void ViewAppearing()
        {
            if (_runningViewAppearing)
                return;
            _runningViewAppearing = true;

            try
            {
                base.ViewAppearing();
                TryStartScanning();
                ListConnectedDevicesAsync();
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("Device Resume Error");
            }
        }

        public List<DeviceListItemViewModel> SystemDevices { get; private set; }

        public override void ViewDisappearing()
        {
            try
            {
                base.ViewDisappearing();

                Adapter.StopScanningForDevicesAsync();
                RaisePropertyChanged(() => IsRefreshing);
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("Device Suspend error");
            }
        }


        public async Task ListConnectedDevicesAsync()
        {
            //await Task.Delay(2000); // Give some time for the device disconnect
            if (Xamarin.Forms.Device.RuntimePlatform == Xamarin.Forms.Device.iOS)
                await iosListConnectedDevicesAsync();
            //else if (Xamarin.Forms.Device.RuntimePlatform == Xamarin.Forms.Device.Android)
            //    await androidListConnectedDevicesAsync();
        }

        public async Task iosListConnectedDevicesAsync()
        {
            if (Xamarin.Forms.Device.RuntimePlatform != Xamarin.Forms.Device.iOS)
                return;

            Console.WriteLine("Fetching connected devices...");

            Guid serviceUuid;
            serviceUuid = new Guid("00009802-0000-1000-8000-00805f9b34fb");
            var connectedDevices = Adapter.GetSystemConnectedOrPairedDevices(new[] { serviceUuid });

            foreach (var device in connectedDevices)
                AddOrUpdateDevice(device, MODEL.CS710S, true);
        }

        public async Task androidListConnectedDevicesAsync()
        {
            if (Xamarin.Forms.Device.RuntimePlatform != Xamarin.Forms.Device.Android)
                return;

            var connectedDevices = Adapter.GetSystemConnectedOrPairedDevices();

            Guid specualuuid = Guid.Parse("00009802-0000-1000-8000-00805f9b34fb");
            foreach (var device in connectedDevices)
            {
                try
                {
                    await Adapter.ConnectToDeviceAsync(device);

                    var services = await device.GetServicesAsync();
                    foreach (var service in services)
                    {
                        if (service.Id == specualuuid)
                        {
                            AddOrUpdateDevice(device, MODEL.CS710S, true);
                            break;
                        }
                    }

                    //await Adapter.DisconnectDeviceAsync(device);
                }
                catch (Exception ex)
                {
                }
            }
        }

        private async void TryStartScanning(bool refresh = false)
        {
            if (IsStateOn && (refresh || !Devices.Any()) && !IsRefreshing)
            {
                Devices.Clear();
                ScanForDevices();
            }
        }

        private async void ScanForDevices()
        {
            try
            {
                _cancellationTokenSource = new CancellationTokenSource();
                RaisePropertyChanged(() => StopScanCommand);

                RaisePropertyChanged(() => IsRefreshing);
                Adapter.ScanMode = ScanMode.LowLatency;

                await Adapter.StartScanningForDevicesAsync(_cancellationTokenSource.Token);
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("Can not Scan devices");
            }
        }

        private void CleanupCancellationToken()
        {
            try
            {
                _cancellationTokenSource.Dispose();
                _cancellationTokenSource = null;
                RaisePropertyChanged(() => StopScanCommand);

                if (_scanAgain)
                    ScanForDevices();
            }
            catch (Exception ex)
            {
                CSLibrary.Debug.WriteLine("Can not stop _cancellationTokenSource");
            }
        }

        private async void DisconnectDevice(DeviceListItemViewModel device)
        {
            if (BleMvxApplication._reader.Status != CSLibrary.HighLevelInterface.READERSTATE.DISCONNECT)
            {
                BleMvxApplication._reader.DisconnectAsync();
            }

            try
            {
                if (!device.IsConnected)
                    return;

                _userDialogs.ShowLoading($"Disconnecting {device.Name}...");

                await Adapter.DisconnectDeviceAsync(device.Device);
            }
            catch (Exception ex)
            {
                _userDialogs.Alert(ex.Message, "Disconnect error");
            }
            finally
            {
                device.Update();
                _userDialogs.HideLoading();
            }
        }

        private async void HandleSelectedDevice(DeviceListItemViewModel devices)
        {
            try
            {
                if (await ConnectDeviceAsync(devices))
                {
                    // Connect to CS108

                    //var Services = Adapter.ConnectedDevices.FirstOrDefault(d => d.Id.ToString().Equals(device.Device.Id.ToString()));
                    var device = Adapter.ConnectedDevices.FirstOrDefault(d => d.Id.Equals(devices.Device.Id));

                    if (device == null)
                        return;

                    Connect(device, devices.BTServiceType);

                    _ = _navigation.Close(this);
                }
            }
            catch (Exception ex)
            {
                _userDialogs.Alert(ex.Message, "Disconnect error");
            }

        }

        private async Task<bool> ConnectDeviceAsync(DeviceListItemViewModel device, bool showPrompt = true)
        {
            if (showPrompt && !await _userDialogs.ConfirmAsync($"Connect to device '{device.Name}'?"))
            {
                return false;
            }

            try
            {
                CancellationTokenSource tokenSource = new CancellationTokenSource();

                await Adapter.ConnectToDeviceAsync(device.Device, new ConnectParameters(autoConnect: false, forceBleTransport: true), tokenSource.Token);

                //CSLibraryv4: increase wait time to 10s
                _userDialogs.ShowSuccess($"Initializing Reader, Please Wait.", 10000);

                return true;

            }
            catch (Exception ex)
            {
                await _userDialogs.AlertAsync(ex.Message, "Connection error");
                Trace.Message(ex.Message);
                return false;
            }
            finally
            {
                //_userDialogs.HideLoading();
                device.Update();
            }
        }

        private async void Connect(IDevice _device, MODEL deviceType)
        {
            //Trace.Message("device name :" + _device.Name);

            BleMvxApplication._deviceinfo = _device;

            await BleMvxApplication._reader.ConnectAsync(Adapter, _device, deviceType);

            Trace.Message("load config");

            //bool LoadSuccess = await BleMvxApplication.LoadConfig(_device.Name);
            //BleMvxApplication._config.readerID = _device.Name;
            //bool LoadSuccess = await BleMvxApplication.LoadConfig(_device.Id.ToString(), BleMvxApplication._reader.rfid.GetAntennaPort());
            bool LoadSuccess = await BleMvxApplication.LoadConfig(_device.Id.ToString(), deviceType);
            BleMvxApplication._config.readerID = _device.Id.ToString();
        }

        private async void ConnectAndDisposeDevice(DeviceListItemViewModel item)
        {
            try
            {
                using (item.Device)
                {
                    await Adapter.ConnectToDeviceAsync(item.Device);
                    item.Update();
                }
            }
            catch (Exception ex)
            {
                _userDialogs.Alert(ex.Message, "Failed to connect and dispose.");
            }
            finally
            {
                _userDialogs.HideLoading();
            }
        }

        private void OnDeviceDisconnected(object sender, DeviceEventArgs e)
        {
            Devices.FirstOrDefault(d => d.Id == e.Device.Id)?.Update();
            _userDialogs.HideLoading();
            _userDialogs.Toast($"Disconnected {e.Device.Name}");
        }
    }
}
</file>

<file path="MobileMvxApp/BLE.Client/ViewModels/ViewModelViewPage.cs">
using System;
using System.Collections.ObjectModel;
using System.Collections.Generic;
using Acr.UserDialogs;

using System.Windows.Input;
using Xamarin.Forms;

using Plugin.BLE.Abstractions.Contracts;

namespace BLE.Client.ViewModels
{
    public class ViewModelViewPage : BaseViewModel
    {
        private readonly IUserDialogs _userDialogs;

        public ViewModelViewPage(IAdapter adapter, IUserDialogs userDialogs) : base(adapter)
        {
            _userDialogs = userDialogs;
        }
    }
}
</file>

<file path="README.md">
# C# CS710S MvvmCross App for Android

CS710S Xamarin C# Bluetooth Demo App and SDK 

- .NET Standard 2.0 and MvvmCross 7
- Support implementations on Android platform

This application provides demonstrations to the programming interface made available on the CS710S handheld reader for configuring, controlling, and accessing the RFID reader.  The development was based on the unified CS710S C# Callback-based API that made available on different CSL readers.  This API is applicable to Android environment.  

[Product Information](https://www.convergence.com.hk/CS710S/)
<br>

## Pre-requisite

The build environment consists of tools and the corresponding configurations of the Visual Studio 2022(Windows).  It is expected that the system integrator or the software system programming house will be developing the applications on Visual Studio 2022(Windows).  With this tool, typically he has to write programs on the PC.  The following are needed to set up the build environment.

## Basic configuration on PC

Operating System requirement:
-	Microsoft Windows 10 (English)

Software package required:
-	Microsoft Visual Studio 2022

To build demo application successfully, you need to install Microsoft Visual Studio 2022 or above. For more detailed information, please go to [Microsoft webpage](https://docs.microsoft.com/en-us/visualstudio/welcome-to-visual-studio).
<br><br>
[Visual Studio 2019](https://www.visualstudio.com/zh-hant/vs/whatsnew/)

In Visual Studio, you need to use the Visual Studio Installer to add the Xamarin package:<br>

<img src="app_img/CS108-DotnetMobileDev.png" width="800"/> <br><br>

To run the application on a desktop device, Visual Studio 2022 provides emulator capabilities for Android, supporting the x86_64 architecture. Ensure the project configuration in `BLE.Client.Droid.csproj` includes the following in the `<PropertyGroup>` for emulator compatibility:

```xml
<AndroidSupportedAbis>armeabi-v7a;arm64-v8a;x86_64</AndroidSupportedAbis>
```

## Project Files
1. CS710S-C-Sharp-APP-for-ANDROID.sln for Android platform (BLE.Clinet Target framework set to .net Standard 2.1)
<br><br>

## Callback-based API Library

The CS710S Callback-based API Library consists of the following files. 

|File   | Location of source code |Remarks  |
|-------|-------------------------|---------|
|CSLibrary.dll|Inside folder /CSLibrary/bin/Debug of the CS710S Demo Code|CSL C# Callback-based API Class Library. Different library files.|
<br>

## CS710S C# API: Theory of Operation

The CS710S C# Application Programming Interface (API) provides a programming interface for controlling CS710S integrated reader. The interface is loaded by a mobile application; the application in turn explicitly initializes the interface. The interface supports enumeration of attached RFID radio modules, returning unique identification information for each currently-attached RFID radio modules. An mobile application uses the CS710S C# API to establish a connection and grant the application exclusive control of the corresponding RFID radio module. After an application is granted exclusive control of an RFID radio module, the application can configure the RFID radio module for operation and tag protocol operations can be issued. The CS710S C# API allows an application control of low level functions of the Firmware, including but not limited to: 

- regulatory configuration of frequencies 
- antenna output power 
- air protocol parameters, such as Q value 

Some of these configuration parameters are abstracted by the CS710S and CS108 C# API. The application initiates transactions with ISO 18000-6C tags or tag populations by executing ISO 18000-6C tag-protocol operations. The interface exposes direct access to the following ISO 18000-6C tag-protocol operations: 

- Inventory 
- Read 
- Write 
- Kill 
- Erase 
- Lock 

When executing tag-protocol operations, the interface provides the application with the ability to configure tag-selection (i.e., ISO 18000-6C Select) criteria and query (i.e. ISO 18000-6C Query) parameters. The interface extends the ISO 18000-6C tag- protocol operations by additionally providing the application the ability to specify a post-singulation Electronic Product Code (EPC) match mask as well as the number of tags to which the operation is to be applied. Additionally, the interface supports configuration of dense-reader mode during ISO 18000-6C tag-protocol operations. The interface supports the configuration and control of the antenna. The application is given fine-grained control to configure: 

- A time limit for performing tag-protocol operations (dwell time) 
- The number of times a tag-protocol operation is executed (number of inventory rounds) 
- RF characteristics (for example, RF power). 

The interface supports a callback model for presenting tag-protocol operation response data to the application. When an application issues a tag-protocol request (i.e. inventory, read, etc.), it also provides a pointer to a callback function API invokes. To help simplify the packet-processing code the API provides complete tag-protocol operation response packets. Tag-protocol operation results include EPC values returned by the Inventory operation, read data returned by the Read operation, and operation status returned by the Write, Kill, Erase, and Lock operations. The application can request the returned data be presented in one of three formats: compact, normal, or extended. Compact mode contains the minimum amount of data necessary to return the results of tag-protocol operations to the application. Normal mode augments compact mode by interleaving additional status/contextual information in the operation results, so that the application can detect, for example, the start of inventory rounds, when a new antenna is being used, etc. Extended mode augments normal mode by interleaving additional diagnostic and statistical data with the operation results. The interface supports diagnostic and statistical reporting for radio, inventory, singulation, tag access, and tag performance as well as status packets to alert the application to unexpected errors during tag- protocol operations. 

The interface provides the application with access to (i.e., read and write) the configuration data area on the RFID radio module. The application can use the configuration data area to store and retrieve the specific hardware configuration and capabilities of the radio. The application can read a RFID radio modules configuration data area immediately after gaining exclusive control of the RFID radio module and use that data to configure and control low-level radio parameters. The interface also supports low-level control of the RFID Firmware. 

## Callback-based API Classes, Methods and Events

Please refer to the documentation under the folder Library/CSLibrary/Readme.txt and CSLibrary/docs
</file>

<file path="repomix-instruction.md">
# Repomix Instructions  CS710S Android (C# / Xamarin / MvvmCross)

**Goal**  
Produce a single packed context for AI agents to analyze BLE and RFID flows in the CS710S handheld reader app on Android (Xamarin.Forms + MvvmCross), excluding build artifacts, binaries, and noise. Ensure the full output is generated without truncation.

---

## What to Include (Priority Order)
1) Solution & Projects  
- `CS710S-C-Sharp-APP-for-ANDROID.sln`  
- `Library/CSLibrary/*.csproj` (NETStandard, NET8-MAUI, .NET4 variants)  
- `MobileMvxApp/BLE.Client.csproj`  
- `MobileMvxApp/BLE.Client.Droid.csproj`

2) Core Library (RFID + HAL + Tools)  
- `Library/CSLibrary/Source/**.cs`  
  - RFID Unified API: `CSLUnifiedAPI/**` (Public/Private/Basic_*; CS710S, CS108 focus)  
  - Comm Protocol: `Ex10Commands/**`, `RX000Commands/**`  
  - HAL BLE: `HAL/**` (MvvmCross/Plugin.BLE integrations)  
  - Utilities: `Tools/**`, `SystemInformation/**`, `BarcodeReader/**`

3) Android App (UI + ViewModels)  
- `MobileMvxApp/BLE.Client/**.cs` (Shared logic, ViewModels, Pages)  
- `MobileMvxApp/BLE.Client.Droid/**.cs` (Platform-specific, e.g., MainActivity.cs, Setup.cs)  
- `MobileMvxApp/BLE.Client.Droid/Properties/AndroidManifest.xml`  
- `MobileMvxApp/BLE.Client.Droid/Resources/values/*.xml`  
- `MobileMvxApp/BLE.Client.Droid/Resources/layout/*.axml`

4) Docs / Metadata  
- `README.md`  
- `repomix-instruction.md`  
- `repomix.config.json` (For Repomix self-reference)

---

## Exclude (Noise & Generated)
- Build & IDE: `**/bin/**`, `**/obj/**`, `.vs/**`, `.idea/**`, `.vscode/**`  
- Packages & NuGet: `packages/**`, `**/Packages/**`  
- Designer/Generated: `**/Resource.designer.cs`, `**/*.g.cs`, `**/*.Designer.cs`  
- Binaries/Archives: `**/*.dll`, `**/*.so`, `**/*.a`, `**/*.jar`, `**/*.aar`, `**/*.nupkg`, `**/*.keystore`, `**/*.apk`, `**/*.aab`, `**/*.zip`  
- Images/Misc: `**/*.png`, `**/*.jpg`, `**/*.gif`, `**/*.pdf`  
- Local Config: `**/*.user`, `**/*.userprefs`, `**/*.csproj.user`

---

## Logical Read Order (for AI Prospecting)
Guide AI agents in "prospecting" interconnected paths:  
1) `CS710S-C-Sharp-APP-for-ANDROID.sln`  Project dependencies.  
2) App Entry: `BLE.Client.Droid/MainApplication.cs`, `MainActivity.cs`, `Setup.cs` (MvvmCross initialization).  
3) ViewModels: `BLE.Client/ViewModels/**` (e.g., `DeviceListViewModel.cs`, `ViewModelMainMenu.cs` for BLE scanning).  
4) BLE HAL: `Library/CSLibrary/Source/HAL/**` (Device discovery, GATT connections via Plugin.BLE).  
5) RFID Unified API (CS710S Focus): `CSLUnifiedAPI/Basic_API/CS710S/**` (Public/Private; Inventory/Read/Write/Antenna/Powertrace cross-links from public to private layers).  
6) Comm Protocol: `Comm_Protocol/**` (Ex10/RX000 commands).  
7) Utilities: `Tools/**`, `SystemInformation/**`.  

This order reflects app flow: Android bootstrap  MvvmCross setup  BLE connect/scan  RFID operations. Emphasize tracing dependencies (e.g., how `ClassRFID.Public.*` invokes private/driver layers).

---

## Summarization Hints (Chunking for AI)
- Group by Feature: **BLE Connect** (HAL + ViewModels), **Inventory** (CSLUnifiedAPI/Private.Inventory.cs), **Read/Write** (Private.Read/Write.cs), **Antenna/Power** (Antenna/**, Public.Power.cs), **Tag Filters/QT** (QTCommandParms.cs), **Errors/Status** (CS710SErrorCode.cs).  
- Limit chunks to 2k tokens; prefix each with file paths.  
- Cross-link public APIs to private implementations (e.g., `ClassRFID.Public.Operation.cs`  `ClassRFID.Private.*`).  
- Note response modes (compact/normal/extended) in tag operations.  
- Flag Token-Heavy Files (>1k tokens): `ClassRFID.cs`, `ClassRFID.Private.cs`, `DeviceListViewModel.cs`suggest splitting in AI analysis.

---

## Important Callouts
- Android: `MainActivity.cs`, `AndroidManifest.xml`, `Resources/values/*.xml`.  
- ViewModels: `DeviceListViewModel.cs`, `ViewModelViewPage.cs`.  
- CS710S API: Public (`ClassRFID.Public.*.cs`, `ClassRFID.UnifiedAPI.cs`), Operations (`ClassRFID.Private.*.cs` for Read/Write/Inventory/Select), Antenna/Power (`Antenna/**`, `ClassRFID.Public.Power.cs`), Protocol (`Ex10Commands/**`, `RX000Commands/**`).  
- Utilities: `Tools/HexEncoding.cs`, `Tools/ClassCRC16.cs`.

---

## Output Requirements
- Single packed file: **Summary  Repo Info  Structure  Files (path + contents)**.  
- Preserve code blocks verbatim; include file headers.  
- Mark **excluded** areas clearly.  
- Note token-heavy files with byte/token counts.  
- Use relative paths from repo root.  
- Style: XML, with file summaries and directory structure.  
- Ensure full output without truncation (support up to 100MB).

---

## Build Context
- Targets: Android (armeabi-v7a, arm64-v8a, x86_64 for emulators).  
- Key Packages: MvvmCross.Plugin.BLE (2.2.0-pre5), Plugin.BLE (3.0.0).  
- Build: Open solution in VS 2022  Select `BLE.Client.Droid`  Debug/Release  Deploy to device/emulator.

---

## Quality Checks (for AI Post-Packing)
- Flag BLE timing issues, UI thread marshaling, and disconnect edges (e.g., in `DeviceListViewModel.cs`).  
- Confirm frequency/power settings are configurable (e.g., `ClassRFID.Public.Country.cs`).  
- Verify no UI-blocking I/O; check cancellation tokens in scans/reads (e.g., `ClassRFID.Private.Inventory.cs`).
</file>

<file path="repomix.config.json">
{
  "input": {
    "maxFileSize": 100000000
  },
  "output": {
    "filePath": "CS710S-C-Sharp-ENTIRE-CONTEXT.txt",
    "style": "xml",
    "parsableStyle": true,
    "compress": true,
    "headerText": "Packed CS710S Android codebase for AI analysis of BLE/RFID flows, including C# source, projects, and docs.",
    "instructionFilePath": "repomix-instruction.md",
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "includeEmptyDirectories": false,
    "topFilesLength": 5,
    "tokenCountTree": 1000
  },
  "include": [
    "CS710S-C-Sharp-APP-for-ANDROID.sln",
    "Library/CSLibrary/*.csproj",
    "MobileMvxApp/BLE.Client/*.csproj",
    "MobileMvxApp/BLE.Client.Droid/*.csproj",
    "Library/CSLibrary/Source/**/*.cs",
    "MobileMvxApp/BLE.Client/**/*.cs",
    "MobileMvxApp/BLE.Client.Droid/**/*.cs",
    "MobileMvxApp/BLE.Client.Droid/Properties/AndroidManifest.xml",
    "MobileMvxApp/BLE.Client.Droid/Resources/values/*.xml",
    "MobileMvxApp/BLE.Client.Droid/Resources/layout/*.axml",
    "README.md",
    "repomix-instruction.md",
    "repomix.config.json"
  ],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": [
      "**/bin/**",
      "**/obj/**",
      "**/Debug/**",
      "**/Release/**",
      "**/.vs/**",
      "**/TestResult*/**",
      "**/node_modules/**",
      "**/*.dll",
      "**/*.so",
      "**/*.a",
      "**/*.jar",
      "**/*.aar",
      "**/*.nupkg",
      "**/*.keystore",
      "**/*.apk",
      "**/*.aab",
      "**/*.zip",
      "**/*.png",
      "**/*.jpg",
      "**/*.gif",
      "**/*.pdf",
      "**/*.user",
      "**/*.userprefs",
      "**/*.csproj.user",
      "**/Resource.designer.cs",
      "**/*.g.cs",
      "**/*.Designer.cs"
    ]
  },
  "security": {
    "enableSecurityCheck": false
  },
  "tokenCount": {
    "encoding": "o200k_base"
  },
  "git": {
    "includeLogs": false,
    "sortByChanges": false,
    "sortByChangesMaxCommits": 0,
    "includeDiffs": false,
    "includeLogsCount": 0
  },
  "metadata": {
    "version": "1.0",
    "lastUpdated": "2025-08-29",
    "description": "Configuration for packing CS710S Android codebase for AI analysis."
  }
}
</file>

</repository_files>

<instruction>
# Repomix Instructions  CS710S Android (C# / Xamarin / MvvmCross)

**Goal**  
Produce a single packed context for AI agents to analyze BLE and RFID flows in the CS710S handheld reader app on Android (Xamarin.Forms + MvvmCross), excluding build artifacts, binaries, and noise. Ensure the full output is generated without truncation.

---

## What to Include (Priority Order)
1) Solution & Projects  
- `CS710S-C-Sharp-APP-for-ANDROID.sln`  
- `Library/CSLibrary/*.csproj` (NETStandard, NET8-MAUI, .NET4 variants)  
- `MobileMvxApp/BLE.Client.csproj`  
- `MobileMvxApp/BLE.Client.Droid.csproj`

2) Core Library (RFID + HAL + Tools)  
- `Library/CSLibrary/Source/**.cs`  
  - RFID Unified API: `CSLUnifiedAPI/**` (Public/Private/Basic_*; CS710S, CS108 focus)  
  - Comm Protocol: `Ex10Commands/**`, `RX000Commands/**`  
  - HAL BLE: `HAL/**` (MvvmCross/Plugin.BLE integrations)  
  - Utilities: `Tools/**`, `SystemInformation/**`, `BarcodeReader/**`

3) Android App (UI + ViewModels)  
- `MobileMvxApp/BLE.Client/**.cs` (Shared logic, ViewModels, Pages)  
- `MobileMvxApp/BLE.Client.Droid/**.cs` (Platform-specific, e.g., MainActivity.cs, Setup.cs)  
- `MobileMvxApp/BLE.Client.Droid/Properties/AndroidManifest.xml`  
- `MobileMvxApp/BLE.Client.Droid/Resources/values/*.xml`  
- `MobileMvxApp/BLE.Client.Droid/Resources/layout/*.axml`

4) Docs / Metadata  
- `README.md`  
- `repomix-instruction.md`  
- `repomix.config.json` (For Repomix self-reference)

---

## Exclude (Noise & Generated)
- Build & IDE: `**/bin/**`, `**/obj/**`, `.vs/**`, `.idea/**`, `.vscode/**`  
- Packages & NuGet: `packages/**`, `**/Packages/**`  
- Designer/Generated: `**/Resource.designer.cs`, `**/*.g.cs`, `**/*.Designer.cs`  
- Binaries/Archives: `**/*.dll`, `**/*.so`, `**/*.a`, `**/*.jar`, `**/*.aar`, `**/*.nupkg`, `**/*.keystore`, `**/*.apk`, `**/*.aab`, `**/*.zip`  
- Images/Misc: `**/*.png`, `**/*.jpg`, `**/*.gif`, `**/*.pdf`  
- Local Config: `**/*.user`, `**/*.userprefs`, `**/*.csproj.user`

---

## Logical Read Order (for AI Prospecting)
Guide AI agents in "prospecting" interconnected paths:  
1) `CS710S-C-Sharp-APP-for-ANDROID.sln`  Project dependencies.  
2) App Entry: `BLE.Client.Droid/MainApplication.cs`, `MainActivity.cs`, `Setup.cs` (MvvmCross initialization).  
3) ViewModels: `BLE.Client/ViewModels/**` (e.g., `DeviceListViewModel.cs`, `ViewModelMainMenu.cs` for BLE scanning).  
4) BLE HAL: `Library/CSLibrary/Source/HAL/**` (Device discovery, GATT connections via Plugin.BLE).  
5) RFID Unified API (CS710S Focus): `CSLUnifiedAPI/Basic_API/CS710S/**` (Public/Private; Inventory/Read/Write/Antenna/Powertrace cross-links from public to private layers).  
6) Comm Protocol: `Comm_Protocol/**` (Ex10/RX000 commands).  
7) Utilities: `Tools/**`, `SystemInformation/**`.  

This order reflects app flow: Android bootstrap  MvvmCross setup  BLE connect/scan  RFID operations. Emphasize tracing dependencies (e.g., how `ClassRFID.Public.*` invokes private/driver layers).

---

## Summarization Hints (Chunking for AI)
- Group by Feature: **BLE Connect** (HAL + ViewModels), **Inventory** (CSLUnifiedAPI/Private.Inventory.cs), **Read/Write** (Private.Read/Write.cs), **Antenna/Power** (Antenna/**, Public.Power.cs), **Tag Filters/QT** (QTCommandParms.cs), **Errors/Status** (CS710SErrorCode.cs).  
- Limit chunks to 2k tokens; prefix each with file paths.  
- Cross-link public APIs to private implementations (e.g., `ClassRFID.Public.Operation.cs`  `ClassRFID.Private.*`).  
- Note response modes (compact/normal/extended) in tag operations.  
- Flag Token-Heavy Files (>1k tokens): `ClassRFID.cs`, `ClassRFID.Private.cs`, `DeviceListViewModel.cs`suggest splitting in AI analysis.

---

## Important Callouts
- Android: `MainActivity.cs`, `AndroidManifest.xml`, `Resources/values/*.xml`.  
- ViewModels: `DeviceListViewModel.cs`, `ViewModelViewPage.cs`.  
- CS710S API: Public (`ClassRFID.Public.*.cs`, `ClassRFID.UnifiedAPI.cs`), Operations (`ClassRFID.Private.*.cs` for Read/Write/Inventory/Select), Antenna/Power (`Antenna/**`, `ClassRFID.Public.Power.cs`), Protocol (`Ex10Commands/**`, `RX000Commands/**`).  
- Utilities: `Tools/HexEncoding.cs`, `Tools/ClassCRC16.cs`.

---

## Output Requirements
- Single packed file: **Summary  Repo Info  Structure  Files (path + contents)**.  
- Preserve code blocks verbatim; include file headers.  
- Mark **excluded** areas clearly.  
- Note token-heavy files with byte/token counts.  
- Use relative paths from repo root.  
- Style: XML, with file summaries and directory structure.  
- Ensure full output without truncation (support up to 100MB).

---

## Build Context
- Targets: Android (armeabi-v7a, arm64-v8a, x86_64 for emulators).  
- Key Packages: MvvmCross.Plugin.BLE (2.2.0-pre5), Plugin.BLE (3.0.0).  
- Build: Open solution in VS 2022  Select `BLE.Client.Droid`  Debug/Release  Deploy to device/emulator.

---

## Quality Checks (for AI Post-Packing)
- Flag BLE timing issues, UI thread marshaling, and disconnect edges (e.g., in `DeviceListViewModel.cs`).  
- Confirm frequency/power settings are configurable (e.g., `ClassRFID.Public.Country.cs`).  
- Verify no UI-blocking I/O; check cancellation tokens in scans/reads (e.g., `ClassRFID.Private.Inventory.cs`).

</instruction>
